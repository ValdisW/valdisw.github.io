/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/_css-loader@6.5.1@css-loader/dist/cjs.js!./src/style.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/_css-loader@6.5.1@css-loader/dist/cjs.js!./src/style.css ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/_css-loader@6.5.1@css-loader/dist/runtime/sourceMaps.js */ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_6_5_1_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/_css-loader@6.5.1@css-loader/dist/runtime/api.js */ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_6_5_1_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/_css-loader@6.5.1@css-loader/dist/runtime/getUrl.js */ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_6_5_1_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./fonts/LEXUS-Bold.ttf */ "./src/fonts/LEXUS-Bold.ttf"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ./icons/magnifier.png */ "./src/icons/magnifier.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_6_5_1_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_6_5_1_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_6_5_1_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_6_5_1_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@font-face {\r\n  font-family: \"lexus\";\r\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\r\n}\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\nhtml,\r\nbody,\r\n#main {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\nbody {\r\n  overflow: auto hidden;\r\n  background: #1a2e51;\r\n}\r\nh1 {\r\n  font-size: 36px;\r\n  font-weight: normal;\r\n  font-family: \"lexus\";\r\n  color: #7394cf;\r\n  position: absolute;\r\n  top: 30px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  user-select: none;\r\n}\r\n#magnifier {\r\n  background: #666 url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat center;\r\n  background-size: 70% 70%;\r\n  border: none;\r\n  border-radius: 8px;\r\n  width: 36px;\r\n  height: 36px;\r\n  position: absolute;\r\n  top: 36px;\r\n  left: 66.6vw;\r\n  cursor: pointer;\r\n}\r\n", "",{"version":3,"sources":["webpack://./src/style.css"],"names":[],"mappings":"AAAA;EACE,oBAAoB;EACpB,4CAAkC;AACpC;AACA;EACE,SAAS;EACT,UAAU;AACZ;AACA;;;EAGE,WAAW;EACX,YAAY;AACd;AACA;EACE,qBAAqB;EACrB,mBAAmB;AACrB;AACA;EACE,eAAe;EACf,mBAAmB;EACnB,oBAAoB;EACpB,cAAc;EACd,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,2BAA2B;EAC3B,iBAAiB;AACnB;AACA;EACE,yEAA4D;EAC5D,wBAAwB;EACxB,YAAY;EACZ,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,SAAS;EACT,YAAY;EACZ,eAAe;AACjB","sourcesContent":["@font-face {\r\n  font-family: \"lexus\";\r\n  src: url(\"./fonts/LEXUS-Bold.ttf\");\r\n}\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\nhtml,\r\nbody,\r\n#main {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\nbody {\r\n  overflow: auto hidden;\r\n  background: #1a2e51;\r\n}\r\nh1 {\r\n  font-size: 36px;\r\n  font-weight: normal;\r\n  font-family: \"lexus\";\r\n  color: #7394cf;\r\n  position: absolute;\r\n  top: 30px;\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  user-select: none;\r\n}\r\n#magnifier {\r\n  background: #666 url(./icons/magnifier.png) no-repeat center;\r\n  background-size: 70% 70%;\r\n  border: none;\r\n  border-radius: 8px;\r\n  width: 36px;\r\n  height: 36px;\r\n  position: absolute;\r\n  top: 36px;\r\n  left: 66.6vw;\r\n  cursor: pointer;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/api.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/getUrl.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/getUrl.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/sourceMaps.js":
/*!******************************************************************************!*\
  !*** ./node_modules/_css-loader@6.5.1@css-loader/dist/runtime/sourceMaps.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertBySelector.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_6_5_1_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/_css-loader@6.5.1@css-loader/dist/cjs.js!./style.css */ "./node_modules/_css-loader@6.5.1@css-loader/dist/cjs.js!./src/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_3_3_1_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_3_3_1_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_3_3_1_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_3_3_1_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_6_5_1_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_6_5_1_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_6_5_1_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_6_5_1_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertBySelector.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertBySelector.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertStyleElement.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/insertStyleElement.js ***!
  \******************************************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleDomAPI.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleDomAPI.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleTagTransform.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/_style-loader@3.3.1@style-loader/dist/runtime/styleTagTransform.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/index.js":
/*!******************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _zrender = __webpack_require__(/*! ./lib/zrender */ "./node_modules/_zrender@4.3.2@zrender/lib/zrender.js");

(function () {
  for (var key in _zrender) {
    if (_zrender == null || !_zrender.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;
    exports[key] = _zrender[key];
  }
})();

var _export = __webpack_require__(/*! ./lib/export */ "./node_modules/_zrender@4.3.2@zrender/lib/export.js");

(function () {
  for (var key in _export) {
    if (_export == null || !_export.hasOwnProperty(key) || key === 'default' || key === '__esModule') return;
    exports[key] = _export[key];
  }
})();

__webpack_require__(/*! ./lib/svg/svg */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/svg.js");

__webpack_require__(/*! ./lib/vml/vml */ "./node_modules/_zrender@4.3.2@zrender/lib/vml/vml.js");

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/Element.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/Element.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var guid = __webpack_require__(/*! ./core/guid */ "./node_modules/_zrender@4.3.2@zrender/lib/core/guid.js");

var Eventful = __webpack_require__(/*! ./mixin/Eventful */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js");

var Transformable = __webpack_require__(/*! ./mixin/Transformable */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Transformable.js");

var Animatable = __webpack_require__(/*! ./mixin/Animatable */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Animatable.js");

var zrUtil = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */
var Element = function (opts) {
  // jshint ignore:line
  Transformable.call(this, opts);
  Eventful.call(this, opts);
  Animatable.call(this, opts);
  /**
   * 画布元素ID
   * @type {string}
   */

  this.id = opts.id || guid();
};

Element.prototype = {
  /**
   * 元素类型
   * Element type
   * @type {string}
   */
  type: 'element',

  /**
   * 元素名字
   * Element name
   * @type {string}
   */
  name: '',

  /**
   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
   * ZRender instance will be assigned when element is associated with zrender
   * @name module:/zrender/Element#__zr
   * @type {module:zrender/ZRender}
   */
  __zr: null,

  /**
   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
   * If ignore drawing and events of the element object
   * @name module:/zrender/Element#ignore
   * @type {boolean}
   * @default false
   */
  ignore: false,

  /**
   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
   * 该路径会继承被裁减对象的变换
   * @type {module:zrender/graphic/Path}
   * @see http://www.w3.org/TR/2dcontext/#clipping-region
   * @readOnly
   */
  clipPath: null,

  /**
   * 是否是 Group
   * @type {boolean}
   */
  isGroup: false,

  /**
   * Drift element
   * @param  {number} dx dx on the global space
   * @param  {number} dy dy on the global space
   */
  drift: function (dx, dy) {
    switch (this.draggable) {
      case 'horizontal':
        dy = 0;
        break;

      case 'vertical':
        dx = 0;
        break;
    }

    var m = this.transform;

    if (!m) {
      m = this.transform = [1, 0, 0, 1, 0, 0];
    }

    m[4] += dx;
    m[5] += dy;
    this.decomposeTransform();
    this.dirty(false);
  },

  /**
   * Hook before update
   */
  beforeUpdate: function () {},

  /**
   * Hook after update
   */
  afterUpdate: function () {},

  /**
   * Update each frame
   */
  update: function () {
    this.updateTransform();
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {},

  /**
   * @protected
   */
  attrKV: function (key, value) {
    if (key === 'position' || key === 'scale' || key === 'origin') {
      // Copy the array
      if (value) {
        var target = this[key];

        if (!target) {
          target = this[key] = [];
        }

        target[0] = value[0];
        target[1] = value[1];
      }
    } else {
      this[key] = value;
    }
  },

  /**
   * Hide the element
   */
  hide: function () {
    this.ignore = true;
    this.__zr && this.__zr.refresh();
  },

  /**
   * Show the element
   */
  show: function () {
    this.ignore = false;
    this.__zr && this.__zr.refresh();
  },

  /**
   * @param {string|Object} key
   * @param {*} value
   */
  attr: function (key, value) {
    if (typeof key === 'string') {
      this.attrKV(key, value);
    } else if (zrUtil.isObject(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.attrKV(name, key[name]);
        }
      }
    }

    this.dirty(false);
    return this;
  },

  /**
   * @param {module:zrender/graphic/Path} clipPath
   */
  setClipPath: function (clipPath) {
    var zr = this.__zr;

    if (zr) {
      clipPath.addSelfToZr(zr);
    } // Remove previous clip path


    if (this.clipPath && this.clipPath !== clipPath) {
      this.removeClipPath();
    }

    this.clipPath = clipPath;
    clipPath.__zr = zr;
    clipPath.__clipTarget = this;
    this.dirty(false);
  },

  /**
   */
  removeClipPath: function () {
    var clipPath = this.clipPath;

    if (clipPath) {
      if (clipPath.__zr) {
        clipPath.removeSelfFromZr(clipPath.__zr);
      }

      clipPath.__zr = null;
      clipPath.__clipTarget = null;
      this.clipPath = null;
      this.dirty(false);
    }
  },

  /**
   * Add self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  addSelfToZr: function (zr) {
    this.__zr = zr; // 添加动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.addSelfToZr(zr);
    }
  },

  /**
   * Remove self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  removeSelfFromZr: function (zr) {
    this.__zr = null; // 移除动画

    var animators = this.animators;

    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }

    if (this.clipPath) {
      this.clipPath.removeSelfFromZr(zr);
    }
  }
};
zrUtil.mixin(Element, Animatable);
zrUtil.mixin(Element, Transformable);
zrUtil.mixin(Element, Eventful);
var _default = Element;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/Handler.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/Handler.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var vec2 = __webpack_require__(/*! ./core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var Draggable = __webpack_require__(/*! ./mixin/Draggable */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Draggable.js");

var Eventful = __webpack_require__(/*! ./mixin/Eventful */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js");

var eventTool = __webpack_require__(/*! ./core/event */ "./node_modules/_zrender@4.3.2@zrender/lib/core/event.js");

var GestureMgr = __webpack_require__(/*! ./core/GestureMgr */ "./node_modules/_zrender@4.3.2@zrender/lib/core/GestureMgr.js");

/**
 * [The interface between `Handler` and `HandlerProxy`]:
 *
 * The default `HandlerProxy` only support the common standard web environment
 * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).
 * But `HandlerProxy` can be replaced to support more non-standard environment
 * (e.g., mini app), or to support more feature that the default `HandlerProxy`
 * not provided (like echarts-gl did).
 * So the interface between `Handler` and `HandlerProxy` should be stable. Do not
 * make break changes util inevitable. The interface include the public methods
 * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`
 * drives `Handler`.
 */

/**
 * [Drag outside]:
 *
 * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the
 * zrender area when dragging. That is important for the improvement of the user experience
 * when dragging something near the boundary without being terminated unexpectedly.
 *
 * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`
 * to resolve this issue. But some drawbacks of it is described in
 * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899
 *
 * Instead, we referenced the specifications:
 * https://www.w3.org/TR/touch-events/#the-touchmove-event
 * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove
 * where the the mousemove/touchmove can be continue to fire if the user began a drag
 * operation and the pointer has left the boundary. (for the mouse event, browsers
 * only do it on `document` and when the pointer has left the boundary of the browser.)
 *
 * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging
 * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue
 * to fire until release the pointer. That is implemented by listen to those event on
 * `document`.
 * If we implement some other `HandlerProxy` only for touch device, that would be easier.
 * The touch event support this feature by default.
 *
 * Note:
 * There might be some cases that the mouse event can not be
 * received on `document`. For example,
 * (A) `useCapture` is not supported and some user defined event listeners on the ancestor
 * of zr dom throw Error .
 * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of
 * zr dom call `stopPropagation`.
 * In these cases, the `mousemove` event might be keep triggered event
 * if the mouse is released. We try to reduce the side-effect in those cases.
 * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.
 *
 * Note:
 * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to
 * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event
 * target is not zrender dom. Becuase it is dangerous to enable users to call them in
 * `document` capture phase to prevent the propagation to any listener of the webpage.
 * But they are needed to work when the pointer inside the zrender dom.
 */
var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event: event,
    // target can only be an element that is not silent.
    target: targetInfo.target,
    // topTarget can be a silent element.
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}

function stopEvent() {
  eventTool.stop(this.event);
}

function EmptyProxy() {}

EmptyProxy.prototype.dispose = function () {};

var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */

var Handler = function (storage, painter, proxy, painterRoot) {
  Eventful.call(this);
  this.storage = storage;
  this.painter = painter;
  this.painterRoot = painterRoot;
  proxy = proxy || new EmptyProxy();
  /**
   * Proxy of event. can be Dom, WebGLSurface, etc.
   */

  this.proxy = null;
  /**
   * {target, topTarget, x, y}
   * @private
   * @type {Object}
   */

  this._hovered = {};
  /**
   * @private
   * @type {Date}
   */

  this._lastTouchMoment;
  /**
   * @private
   * @type {number}
   */

  this._lastX;
  /**
   * @private
   * @type {number}
   */

  this._lastY;
  /**
   * @private
   * @type {module:zrender/core/GestureMgr}
   */

  this._gestureMgr;
  Draggable.call(this);
  this.setHandlerProxy(proxy);
};

Handler.prototype = {
  constructor: Handler,
  setHandlerProxy: function (proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }

    if (proxy) {
      util.each(handlerNames, function (name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this); // Attach handler

      proxy.handler = this;
    }

    this.proxy = proxy;
  },
  mousemove: function (event) {
    var x = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
    // See #6198.

    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }

    var hovered = this._hovered = isOutside ? {
      x: x,
      y: y
    } : this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, 'mouseout', event);
    } // Mouse moving on one element


    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, 'mouseover', event);
    }
  },
  mouseout: function (event) {
    var eventControl = event.zrEventControl;
    var zrIsToLocalDOM = event.zrIsToLocalDOM;

    if (eventControl !== 'only_globalout') {
      this.dispatchToElement(this._hovered, 'mouseout', event);
    }

    if (eventControl !== 'no_globalout') {
      // FIXME: if the pointer moving from the extra doms to realy "outside",
      // the `globalout` should have been triggered. But currently not.
      !zrIsToLocalDOM && this.trigger('globalout', {
        type: 'globalout',
        event: event
      });
    }
  },

  /**
   * Resize
   */
  resize: function (event) {
    this._hovered = {};
  },

  /**
   * Dispatch event
   * @param {string} eventName
   * @param {event=} eventArgs
   */
  dispatch: function (eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  },

  /**
   * Dispose
   */
  dispose: function () {
    this.proxy.dispose();
    this.storage = this.proxy = this.painter = null;
  },

  /**
   * 设置默认的cursor style
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  },

  /**
   * 事件分发代理
   *
   * @private
   * @param {Object} targetInfo {target, topTarget} 目标图形元素
   * @param {string} eventName 事件名称
   * @param {Object} event 事件对象
   */
  dispatchToElement: function (targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;

    if (el && el.silent) {
      return;
    }

    var eventHandler = 'on' + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);

    while (el) {
      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.parent;

      if (eventPacket.cancelBubble) {
        break;
      }
    }

    if (!eventPacket.cancelBubble) {
      // 冒泡到顶级 zrender 对象
      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

      this.painter && this.painter.eachOtherLayer(function (layer) {
        if (typeof layer[eventHandler] === 'function') {
          layer[eventHandler].call(layer, eventPacket);
        }

        if (layer.trigger) {
          layer.trigger(eventName, eventPacket);
        }
      });
    }
  },

  /**
   * @private
   * @param {number} x
   * @param {number} y
   * @param {module:zrender/graphic/Displayable} exclude
   * @return {model:zrender/Element}
   * @method
   */
  findHover: function (x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out = {
      x: x,
      y: y
    };

    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult;

      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out.topTarget && (out.topTarget = list[i]);

        if (hoverCheckResult !== SILENT) {
          out.target = list[i];
          break;
        }
      }
    }

    return out;
  },
  processGesture: function (event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }

    var gestureMgr = this._gestureMgr;
    stage === 'start' && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      this.dispatchToElement({
        target: gestureInfo.target
      }, type, gestureInfo.event);
    }
  }
}; // Common handlers

util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  Handler.prototype[name] = function (event) {
    var x = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var hovered;
    var hoveredTarget;

    if (name !== 'mouseup' || !isOutside) {
      // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
      hovered = this.findHover(x, y);
      hoveredTarget = hovered.target;
    }

    if (name === 'mousedown') {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

      this._upEl = hoveredTarget;
    } else if (name === 'mouseup') {
      this._upEl = hoveredTarget;
    } else if (name === 'click') {
      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
      // including the case that `mousedown` - `mousemove` - `mouseup`,
      // which should be filtered, otherwise it will bring trouble to
      // pan and zoom.
      || !this._downPoint // Arbitrary value
      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }

      this._downPoint = null;
    }

    this.dispatchToElement(hovered, name, event);
  };
});

function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
    var el = displayable;
    var isSilent;

    while (el) {
      // If clipped by ancestor.
      // FIXME: If clipPath has neither stroke nor fill,
      // el.clipPath.contain(x, y) will always return false.
      if (el.clipPath && !el.clipPath.contain(x, y)) {
        return false;
      }

      if (el.silent) {
        isSilent = true;
      }

      el = el.parent;
    }

    return isSilent ? SILENT : true;
  }

  return false;
}
/**
 * See [Drag outside].
 */


function isOutsideBoundary(handlerInstance, x, y) {
  var painter = handlerInstance.painter;
  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}

util.mixin(Handler, Eventful);
util.mixin(Handler, Draggable);
var _default = Handler;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/Layer.js":
/*!**********************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/Layer.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var _config = __webpack_require__(/*! ./config */ "./node_modules/_zrender@4.3.2@zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var Style = __webpack_require__(/*! ./graphic/Style */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Style.js");

var Pattern = __webpack_require__(/*! ./graphic/Pattern */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Pattern.js");

/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */
function returnFalse() {
  return false;
}
/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */


function createDom(id, painter, dpr) {
  var newDom = util.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;

  if (newDomStyle) {
    // In node or some other non-browser environment
    newDomStyle.position = 'absolute';
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + 'px';
    newDomStyle.height = height + 'px';
    newDom.setAttribute('data-zr-dom-id', id);
  }

  newDom.width = width * dpr;
  newDom.height = height * dpr;
  return newDom;
}
/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */


var Layer = function (id, painter, dpr) {
  var dom;
  dpr = dpr || devicePixelRatio;

  if (typeof id === 'string') {
    dom = createDom(id, painter, dpr);
  } // Not using isDom because in node it will return false
  else if (util.isObject(id)) {
      dom = id;
      id = dom.id;
    }

  this.id = id;
  this.dom = dom;
  var domStyle = dom.style;

  if (domStyle) {
    // Not in node
    dom.onselectstart = returnFalse; // 避免页面选中的尴尬

    domStyle['-webkit-user-select'] = 'none';
    domStyle['user-select'] = 'none';
    domStyle['-webkit-touch-callout'] = 'none';
    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
    domStyle['padding'] = 0; // eslint-disable-line dot-notation

    domStyle['margin'] = 0; // eslint-disable-line dot-notation

    domStyle['border-width'] = 0;
  }

  this.domBack = null;
  this.ctxBack = null;
  this.painter = painter;
  this.config = null; // Configs

  /**
   * 每次清空画布的颜色
   * @type {string}
   * @default 0
   */

  this.clearColor = 0;
  /**
   * 是否开启动态模糊
   * @type {boolean}
   * @default false
   */

  this.motionBlur = false;
  /**
   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   * @type {number}
   * @default 0.7
   */

  this.lastFrameAlpha = 0.7;
  /**
   * Layer dpr
   * @type {number}
   */

  this.dpr = dpr;
};

Layer.prototype = {
  constructor: Layer,
  __dirty: true,
  __used: false,
  __drawIndex: 0,
  __startIndex: 0,
  __endIndex: 0,
  incremental: false,
  getElementCount: function () {
    return this.__endIndex - this.__startIndex;
  },
  initContext: function () {
    this.ctx = this.dom.getContext('2d');
    this.ctx.dpr = this.dpr;
  },
  createBackBuffer: function () {
    var dpr = this.dpr;
    this.domBack = createDom('back-' + this.id, this.painter, dpr);
    this.ctxBack = this.domBack.getContext('2d');

    if (dpr !== 1) {
      this.ctxBack.scale(dpr, dpr);
    }
  },

  /**
   * @param  {number} width
   * @param  {number} height
   */
  resize: function (width, height) {
    var dpr = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;

    if (domStyle) {
      domStyle.width = width + 'px';
      domStyle.height = height + 'px';
    }

    dom.width = width * dpr;
    dom.height = height * dpr;

    if (domBack) {
      domBack.width = width * dpr;
      domBack.height = height * dpr;

      if (dpr !== 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    }
  },

  /**
   * 清空该层画布
   * @param {boolean} [clearAll]=false Clear all with out motion blur
   * @param {Color} [clearColor]
   */
  clear: function (clearAll, clearColor) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    var clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr = this.dpr;

    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }

      this.ctxBack.globalCompositeOperation = 'copy';
      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
    }

    ctx.clearRect(0, 0, width, height);

    if (clearColor && clearColor !== 'transparent') {
      var clearColorGradientOrPattern; // Gradient

      if (clearColor.colorStops) {
        // Cache canvas gradient
        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
          x: 0,
          y: 0,
          width: width,
          height: height
        });
        clearColor.__canvasGradient = clearColorGradientOrPattern;
      } // Pattern
      else if (clearColor.image) {
          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
        }

      ctx.save();
      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    if (haveMotionBLur) {
      var domBack = this.domBack;
      ctx.save();
      ctx.globalAlpha = lastFrameAlpha;
      ctx.drawImage(domBack, 0, 0, width, height);
      ctx.restore();
    }
  }
};
var _default = Layer;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/Painter.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/Painter.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _config = __webpack_require__(/*! ./config */ "./node_modules/_zrender@4.3.2@zrender/lib/config.js");

var devicePixelRatio = _config.devicePixelRatio;

var util = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var logError = __webpack_require__(/*! ./core/log */ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js");

var BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var timsort = __webpack_require__(/*! ./core/timsort */ "./node_modules/_zrender@4.3.2@zrender/lib/core/timsort.js");

var Layer = __webpack_require__(/*! ./Layer */ "./node_modules/_zrender@4.3.2@zrender/lib/Layer.js");

var requestAnimationFrame = __webpack_require__(/*! ./animation/requestAnimationFrame */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/requestAnimationFrame.js");

var Image = __webpack_require__(/*! ./graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

var env = __webpack_require__(/*! ./core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 0.001;

function parseInt10(val) {
  return parseInt(val, 10);
}

function isLayerValid(layer) {
  if (!layer) {
    return false;
  }

  if (layer.__builtin__) {
    return true;
  }

  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
    return false;
  }

  return true;
}

var tmpRect = new BoundingRect(0, 0, 0, 0);
var viewRect = new BoundingRect(0, 0, 0, 0);

function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());

  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }

  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.
  if (clipPaths === prevClipPaths) {
    return false;
  }

  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }

  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }

  return false;
}

function doClip(clipPaths, ctx) {
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip(); // Transform back

    clipPath.restoreTransform(ctx);
  }
}

function createRoot(width, height) {
  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected

  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
  // dom does not act as expected) when some of the parent dom has
  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
  // the canvas is not at the top part of the page.
  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
  // this `overflow:hidden` to avoid the bug.
  // 'overflow:hidden',
  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
  return domRoot;
}
/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */


var Painter = function (root, storage, opts) {
  this.type = 'canvas'; // In node environment using node-canvas

  var singleCanvas = !root.nodeName // In node ?
  || root.nodeName.toUpperCase() === 'CANVAS';
  this._opts = opts = util.extend({}, opts || {});
  /**
   * @type {number}
   */

  this.dpr = opts.devicePixelRatio || devicePixelRatio;
  /**
   * @type {boolean}
   * @private
   */

  this._singleCanvas = singleCanvas;
  /**
   * 绘图容器
   * @type {HTMLElement}
   */

  this.root = root;
  var rootStyle = root.style;

  if (rootStyle) {
    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
    root.innerHTML = '';
  }
  /**
   * @type {module:zrender/Storage}
   */


  this.storage = storage;
  /**
   * @type {Array.<number>}
   * @private
   */

  var zlevelList = this._zlevelList = [];
  /**
   * @type {Object.<string, module:zrender/Layer>}
   * @private
   */

  var layers = this._layers = {};
  /**
   * @type {Object.<string, Object>}
   * @private
   */

  this._layerConfig = {};
  /**
   * zrender will do compositing when root is a canvas and have multiple zlevels.
   */

  this._needsManuallyCompositing = false;

  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = this._domRoot = createRoot(this._width, this._height);
    root.appendChild(domRoot);
  } else {
    var width = root.width;
    var height = root.height;

    if (opts.width != null) {
      width = opts.width;
    }

    if (opts.height != null) {
      height = opts.height;
    }

    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly

    root.width = width * this.dpr;
    root.height = height * this.dpr;
    this._width = width;
    this._height = height; // Create layer if only one given canvas
    // Device can be specified to create a high dpi image.

    var mainLayer = new Layer(root, this, this.dpr);
    mainLayer.__builtin__ = true;
    mainLayer.initContext(); // FIXME Use canvas width and height
    // mainLayer.resize(width, height);

    layers[CANVAS_ZLEVEL] = mainLayer;
    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.

    zlevelList.push(CANVAS_ZLEVEL);
    this._domRoot = root;
  }
  /**
   * @type {module:zrender/Layer}
   * @private
   */


  this._hoverlayer = null;
  this._hoverElements = [];
};

Painter.prototype = {
  constructor: Painter,
  getType: function () {
    return 'canvas';
  },

  /**
   * If painter use a single canvas
   * @return {boolean}
   */
  isSingleCanvas: function () {
    return this._singleCanvas;
  },

  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function () {
    return this._domRoot;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

  /**
   * 刷新
   * @param {boolean} [paintAll=false] 强制绘制所有displayable
   */
  refresh: function (paintAll) {
    var list = this.storage.getDisplayList(true);
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();

    this._paintList(list, paintAll, this._redrawId); // Paint custum layers


    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];

      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }

    this.refreshHover();
    return this;
  },
  addHover: function (el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }

    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape,
      z: el.z,
      z2: el.z2,
      silent: el.silent
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    hoverStyle && elMirror.setStyle(hoverStyle);

    this._hoverElements.push(elMirror);

    return elMirror;
  },
  removeHover: function (el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = util.indexOf(hoverElements, elMirror);

    if (idx >= 0) {
      hoverElements.splice(idx, 1);
    }

    el.__hoverMir = null;
  },
  clearHover: function (el) {
    var hoverElements = this._hoverElements;

    for (var i = 0; i < hoverElements.length; i++) {
      var from = hoverElements[i].__from;

      if (from) {
        from.__hoverMir = null;
      }
    }

    hoverElements.length = 0;
  },
  refreshHover: function () {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();

    if (!len) {
      return;
    }

    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
    // FIXME?

    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
    }

    var scope = {};
    hoverLayer.ctx.save();

    for (var i = 0; i < len;) {
      var el = hoverElements[i];
      var originalEl = el.__from; // Original el is removed
      // PENDING

      if (!(originalEl && originalEl.__zr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }

      i++; // Use transform
      // FIXME style and shape ?

      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths; // el.

        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }

    hoverLayer.ctx.restore();
  },
  getHoverLayer: function () {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  },
  _paintList: function (list, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }

    paintAll = paintAll || false;

    this._updateLayerStatus(list);

    var finished = this._doPaintList(list, paintAll);

    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }

    if (!finished) {
      var self = this;
      requestAnimationFrame(function () {
        self._paintList(list, paintAll, redrawId);
      });
    }
  },
  _compositeManually: function () {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

    this.eachBuiltinLayer(function (layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  },
  _doPaintList: function (list, paintAll) {
    var layerList = [];

    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];

      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }

    var finished = true;

    for (var k = 0; k < layerList.length; k++) {
      var layer = layerList[k];
      var ctx = layer.ctx;
      var scope = {};
      ctx.save();
      var start = paintAll ? layer.__startIndex : layer.__drawIndex;
      var useTimer = !paintAll && layer.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

      if (layer.__startIndex === layer.__endIndex) {
        layer.clear(false, clearColor);
      } else if (start === layer.__startIndex) {
        var firstEl = list[start];

        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer.clear(false, clearColor);
        }
      }

      if (start === -1) {
        console.error('For some unknown reason. drawIndex is -1');
        start = layer.__startIndex;
      }

      for (var i = start; i < layer.__endIndex; i++) {
        var el = list[i];

        this._doPaintEl(el, layer, paintAll, scope);

        el.__dirty = el.__dirtyText = false;

        if (useTimer) {
          // Date.now can be executed in 13,025,305 ops/second.
          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
          // The rest elements will be drawn in the next frame.

          if (dTime > 15) {
            break;
          }
        }
      }

      layer.__drawIndex = i;

      if (layer.__drawIndex < layer.__endIndex) {
        finished = false;
      }

      if (scope.prevElClipPaths) {
        // Needs restore the state. If last drawn element is in the clipping area.
        ctx.restore();
      }

      ctx.restore();
    }

    if (env.wxa) {
      // Flush for weixin application
      util.each(this._layers, function (layer) {
        if (layer && layer.ctx && layer.ctx.draw) {
          layer.ctx.draw();
        }
      });
    }

    return finished;
  },
  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m = el.transform;

    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
    !el.invisible // Ignore transparent element
    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
    // Draw a scale 0 element can cause all following draw wrong
    // And setTransform with scale 0 will cause set back transform failed.
    && !(m && !m[0] && !m[3]) // Ignore culled element
    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths;
      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements

      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
        // If has previous clipping state, restore from it
        if (prevElClipPaths) {
          ctx.restore();
          scope.prevElClipPaths = null; // Reset prevEl since context has been restored

          scope.prevEl = null;
        } // New clipping state


        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevElClipPaths = clipPaths;
        }
      }

      el.beforeBrush && el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush && el.afterBrush(ctx);
    }
  },

  /**
   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
   * @param {number} zlevel
   * @param {boolean} virtual Virtual layer will not be inserted into dom.
   * @return {module:zrender/Layer}
   */
  getLayer: function (zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }

    var layer = this._layers[zlevel];

    if (!layer) {
      // Create a new layer
      layer = new Layer('zr_' + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;

      if (this._layerConfig[zlevel]) {
        util.merge(layer, this._layerConfig[zlevel], true);
      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number
      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
        }

      if (virtual) {
        layer.virtual = virtual;
      }

      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
      // Or excanvas will get 0px clientWidth and clientHeight

      layer.initContext();
    }

    return layer;
  },
  insertLayer: function (zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;

    if (layersMap[zlevel]) {
      logError('ZLevel ' + zlevel + ' has been used already');
      return;
    } // Check if is a valid layer


    if (!isLayerValid(layer)) {
      logError('Layer of zlevel ' + zlevel + ' is not valid');
      return;
    }

    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }

      prevLayer = layersMap[zlevelList[i]];
    }

    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
    // (It can be a WebGL layer and assigned to a ZImage element)
    // But it still under management of zrender.

    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;

        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
  },
  // Iterate each layer
  eachLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },
  // Iterate each buildin layer
  eachBuiltinLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  // Iterate each other layer except buildin layer
  eachOtherLayer: function (cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;

    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];

      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },

  /**
   * 获取所有已创建的层
   * @param {Array.<module:zrender/Layer>} [prevLayer]
   */
  getLayers: function () {
    return this._layers;
  },
  _updateLayerStatus: function (list) {
    this.eachBuiltinLayer(function (layer, z) {
      layer.__dirty = layer.__used = false;
    });

    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }

        prevLayer.__endIndex = idx;
      }
    }

    if (this._singleCanvas) {
      for (var i = 1; i < list.length; i++) {
        var el = list[i];

        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }

    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;

    for (var i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer;

      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      } // TODO Not use magic number on zlevel.
      // Each layer with increment element can be separated to 3 layers.
      //          (Other Element drawn after incremental element)
      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------
      //                      (Incremental element)
      // ----------------------zlevel + INCREMENTAL_INC------------------------
      //              (Element drawn before incremental element)
      // --------------------------------zlevel--------------------------------


      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }

      if (!layer.__builtin__) {
        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
      }

      if (layer !== prevLayer) {
        layer.__used = true;

        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }

        layer.__startIndex = i;

        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          // Mark layer draw index needs to update.
          layer.__drawIndex = -1;
        }

        updatePrevLayer(i);
        prevLayer = layer;
      }

      if (el.__dirty) {
        layer.__dirty = true;

        if (layer.incremental && layer.__drawIndex < 0) {
          // Start draw from the first dirty element.
          layer.__drawIndex = i;
        }
      }
    }

    updatePrevLayer(i);
    this.eachBuiltinLayer(function (layer, z) {
      // Used in last frame but not in this frame. Needs clear
      if (!layer.__used && layer.getElementCount() > 0) {
        layer.__dirty = true;
        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
      } // For incremental layer. In case start index changed and no elements are dirty.


      if (layer.__dirty && layer.__drawIndex < 0) {
        layer.__drawIndex = layer.__startIndex;
      }
    });
  },

  /**
   * 清除hover层外所有内容
   */
  clear: function () {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },
  _clearLayer: function (layer) {
    layer.clear();
  },
  setBackgroundColor: function (backgroundColor) {
    this._backgroundColor = backgroundColor;
  },

  /**
   * 修改指定zlevel的绘制参数
   *
   * @param {string} zlevel
   * @param {Object} config 配置对象
   * @param {string} [config.clearColor=0] 每次清空画布的颜色
   * @param {string} [config.motionBlur=false] 是否开启动态模糊
   * @param {number} [config.lastFrameAlpha=0.7]
   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function (zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;

      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        util.merge(layerConfig[zlevel], config, true);
      }

      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number

        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          util.merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  },

  /**
   * 删除指定层
   * @param {number} zlevel 层所在的zlevel
   */
  delLayer: function (zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];

    if (!layer) {
      return;
    }

    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
  },

  /**
   * 区域大小变化后重绘
   */
  resize: function (width, height) {
    if (!this._domRoot.style) {
      // Maybe in node or worker
      if (width == null || height == null) {
        return;
      }

      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot; // FIXME Why ?

      domRoot.style.display = 'none'; // Save input w/h

      var opts = this._opts;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      domRoot.style.display = ''; // 优化没有实际改变的resize

      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + 'px';
        domRoot.style.height = height + 'px';

        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }

        util.each(this._progressiveLayers, function (layer) {
          layer.resize(width, height);
        });
        this.refresh(true);
      }

      this._width = width;
      this._height = height;
    }

    return this;
  },

  /**
   * 清除单独的一个层
   * @param {number} zlevel
   */
  clearLayer: function (zlevel) {
    var layer = this._layers[zlevel];

    if (layer) {
      layer.clear();
    }
  },

  /**
   * 释放
   */
  dispose: function () {
    this.root.innerHTML = '';
    this.root = this.storage = this._domRoot = this._layers = null;
  },

  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @param {number} [opts.pixelRatio]
   */
  getRenderedCanvas: function (opts) {
    opts = opts || {};

    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }

    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);

    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width = imageLayer.dom.width;
      var height = imageLayer.dom.height;
      var ctx = imageLayer.ctx;
      this.eachLayer(function (layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          imageLayer.ctx.save();
          layer.renderToCanvas(imageLayer.ctx);
          imageLayer.ctx.restore();
        }
      });
    } else {
      // PENDING, echarts-gl and incremental rendering.
      var scope = {};
      var displayList = this.storage.getDisplayList(true);

      for (var i = 0; i < displayList.length; i++) {
        var el = displayList[i];

        this._doPaintEl(el, imageLayer, true, scope);
      }
    }

    return imageLayer.dom;
  },

  /**
   * 获取绘图区域宽度
   */
  getWidth: function () {
    return this._width;
  },

  /**
   * 获取绘图区域高度
   */
  getHeight: function () {
    return this._height;
  },
  _getSize: function (whIdx) {
    var opts = this._opts;
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];

    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  pathToImage: function (path, dpr) {
    dpr = dpr || this.dpr;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var rect = path.getBoundingRect();
    var style = path.style;
    var shadowBlurSize = style.shadowBlur * dpr;
    var shadowOffsetX = style.shadowOffsetX * dpr;
    var shadowOffsetY = style.shadowOffsetY * dpr;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr;
    var pathTransform = {
      position: path.position,
      rotation: path.rotation,
      scale: path.scale
    };
    path.position = [leftMargin - rect.x, topMargin - rect.y];
    path.rotation = 0;
    path.scale = [1, 1];
    path.updateTransform();

    if (path) {
      path.brush(ctx);
    }

    var ImageShape = Image;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });

    if (pathTransform.position != null) {
      imgShape.position = path.position = pathTransform.position;
    }

    if (pathTransform.rotation != null) {
      imgShape.rotation = path.rotation = pathTransform.rotation;
    }

    if (pathTransform.scale != null) {
      imgShape.scale = path.scale = pathTransform.scale;
    }

    return imgShape;
  }
};
var _default = Painter;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/Storage.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/Storage.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var env = __webpack_require__(/*! ./core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var Group = __webpack_require__(/*! ./container/Group */ "./node_modules/_zrender@4.3.2@zrender/lib/container/Group.js");

var timsort = __webpack_require__(/*! ./core/timsort */ "./node_modules/_zrender@4.3.2@zrender/lib/core/timsort.js");

// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      // if (a.z2 === b.z2) {
      //     // FIXME Slow has renderidx compare
      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
      //     return a.__renderidx - b.__renderidx;
      // }
      return a.z2 - b.z2;
    }

    return a.z - b.z;
  }

  return a.zlevel - b.zlevel;
}
/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */


var Storage = function () {
  // jshint ignore:line
  this._roots = [];
  this._displayList = [];
  this._displayListLen = 0;
};

Storage.prototype = {
  constructor: Storage,

  /**
   * @param  {Function} cb
   *
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  },

  /**
   * 返回所有图形的绘制队列
   * @param {boolean} [update=false] 是否在返回前更新该数组
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
   *
   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
   * @return {Array.<module:zrender/graphic/Displayable>}
   */
  getDisplayList: function (update, includeIgnore) {
    includeIgnore = includeIgnore || false;

    if (update) {
      this.updateDisplayList(includeIgnore);
    }

    return this._displayList;
  },

  /**
   * 更新图形的绘制队列。
   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
   */
  updateDisplayList: function (includeIgnore) {
    this._displayListLen = 0;
    var roots = this._roots;
    var displayList = this._displayList;

    for (var i = 0, len = roots.length; i < len; i++) {
      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
    }

    displayList.length = this._displayListLen;
    env.canvasSupported && timsort(displayList, shapeCompareFunc);
  },
  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }

    el.beforeUpdate();

    if (el.__dirty) {
      el.update();
    }

    el.afterUpdate();
    var userSetClipPath = el.clipPath;

    if (userSetClipPath) {
      // FIXME 效率影响
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }

      var currentClipPath = userSetClipPath;
      var parentClipPath = el; // Recursively add clip path

      while (currentClipPath) {
        // clipPath 的变换是基于使用这个 clipPath 的元素
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.clipPath;
      }
    }

    if (el.isGroup) {
      var children = el._children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i]; // Force to mark as dirty if group is dirty
        // FIXME __dirtyPath ?

        if (el.__dirty) {
          child.__dirty = true;
        }

        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      } // Mark group clean here


      el.__dirty = false;
    } else {
      el.__clipPaths = clipPaths;
      this._displayList[this._displayListLen++] = el;
    }
  },

  /**
   * 添加图形(Shape)或者组(Group)到根节点
   * @param {module:zrender/Element} el
   */
  addRoot: function (el) {
    if (el.__storage === this) {
      return;
    }

    if (el instanceof Group) {
      el.addChildrenToStorage(this);
    }

    this.addToStorage(el);

    this._roots.push(el);
  },

  /**
   * 删除指定的图形(Shape)或者组(Group)
   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
   */
  delRoot: function (el) {
    if (el == null) {
      // 不指定el清空
      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];

        if (root instanceof Group) {
          root.delChildrenFromStorage(this);
        }
      }

      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    }

    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }

      return;
    }

    var idx = util.indexOf(this._roots, el);

    if (idx >= 0) {
      this.delFromStorage(el);

      this._roots.splice(idx, 1);

      if (el instanceof Group) {
        el.delChildrenFromStorage(this);
      }
    }
  },
  addToStorage: function (el) {
    if (el) {
      el.__storage = this;
      el.dirty(false);
    }

    return this;
  },
  delFromStorage: function (el) {
    if (el) {
      el.__storage = null;
    }

    return this;
  },

  /**
   * 清空并且释放Storage
   */
  dispose: function () {
    this._renderList = this._roots = null;
  },
  displayableSortFunc: shapeCompareFunc
};
var _default = Storage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Animation.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/animation/Animation.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var _event = __webpack_require__(/*! ../core/event */ "./node_modules/_zrender@4.3.2@zrender/lib/core/event.js");

var Dispatcher = _event.Dispatcher;

var requestAnimationFrame = __webpack_require__(/*! ./requestAnimationFrame */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/requestAnimationFrame.js");

var Animator = __webpack_require__(/*! ./Animator */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Animator.js");

/**
 * Animation main class, dispatch and manage all animation controllers
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236

/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 */

/**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */
var Animation = function (options) {
  options = options || {};
  this.stage = options.stage || {};

  this.onframe = options.onframe || function () {}; // private properties


  this._clips = [];
  this._running = false;
  this._time;
  this._pausedTime;
  this._pauseStart;
  this._paused = false;
  Dispatcher.call(this);
};

Animation.prototype = {
  constructor: Animation,

  /**
   * Add clip
   * @param {module:zrender/animation/Clip} clip
   */
  addClip: function (clip) {
    this._clips.push(clip);
  },

  /**
   * Add animator
   * @param {module:zrender/animation/Animator} animator
   */
  addAnimator: function (animator) {
    animator.animation = this;
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.addClip(clips[i]);
    }
  },

  /**
   * Delete animation clip
   * @param {module:zrender/animation/Clip} clip
   */
  removeClip: function (clip) {
    var idx = util.indexOf(this._clips, clip);

    if (idx >= 0) {
      this._clips.splice(idx, 1);
    }
  },

  /**
   * Delete animation clip
   * @param {module:zrender/animation/Animator} animator
   */
  removeAnimator: function (animator) {
    var clips = animator.getClips();

    for (var i = 0; i < clips.length; i++) {
      this.removeClip(clips[i]);
    }

    animator.animation = null;
  },
  _update: function () {
    var time = new Date().getTime() - this._pausedTime;

    var delta = time - this._time;
    var clips = this._clips;
    var len = clips.length;
    var deferredEvents = [];
    var deferredClips = [];

    for (var i = 0; i < len; i++) {
      var clip = clips[i];
      var e = clip.step(time, delta); // Throw out the events need to be called after
      // stage.update, like destroy

      if (e) {
        deferredEvents.push(e);
        deferredClips.push(clip);
      }
    } // Remove the finished clip


    for (var i = 0; i < len;) {
      if (clips[i]._needsRemove) {
        clips[i] = clips[len - 1];
        clips.pop();
        len--;
      } else {
        i++;
      }
    }

    len = deferredEvents.length;

    for (var i = 0; i < len; i++) {
      deferredClips[i].fire(deferredEvents[i]);
    }

    this._time = time;
    this.onframe(delta); // 'frame' should be triggered before stage, because upper application
    // depends on the sequence (e.g., echarts-stream and finish
    // event judge)

    this.trigger('frame', delta);

    if (this.stage.update) {
      this.stage.update();
    }
  },
  _startLoop: function () {
    var self = this;
    this._running = true;

    function step() {
      if (self._running) {
        requestAnimationFrame(step);
        !self._paused && self._update();
      }
    }

    requestAnimationFrame(step);
  },

  /**
   * Start animation.
   */
  start: function () {
    this._time = new Date().getTime();
    this._pausedTime = 0;

    this._startLoop();
  },

  /**
   * Stop animation.
   */
  stop: function () {
    this._running = false;
  },

  /**
   * Pause animation.
   */
  pause: function () {
    if (!this._paused) {
      this._pauseStart = new Date().getTime();
      this._paused = true;
    }
  },

  /**
   * Resume animation.
   */
  resume: function () {
    if (this._paused) {
      this._pausedTime += new Date().getTime() - this._pauseStart;
      this._paused = false;
    }
  },

  /**
   * Clear animation.
   */
  clear: function () {
    this._clips = [];
  },

  /**
   * Whether animation finished.
   */
  isFinished: function () {
    return !this._clips.length;
  },

  /**
   * Creat animator for a target, whose props can be animated.
   *
   * @param  {Object} target
   * @param  {Object} options
   * @param  {boolean} [options.loop=false] Whether loop animation.
   * @param  {Function} [options.getter=null] Get value from target.
   * @param  {Function} [options.setter=null] Set value to target.
   * @return {module:zrender/animation/Animation~Animator}
   */
  // TODO Gap
  animate: function (target, options) {
    options = options || {};
    var animator = new Animator(target, options.loop, options.getter, options.setter);
    this.addAnimator(animator);
    return animator;
  }
};
util.mixin(Animation, Dispatcher);
var _default = Animation;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Animator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/animation/Animator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Clip = __webpack_require__(/*! ./Clip */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Clip.js");

var color = __webpack_require__(/*! ../tool/color */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js");

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var isArrayLike = _util.isArrayLike;

/**
 * @module echarts/animation/Animator
 */
var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
  return target[key];
}

function defaultSetter(target, key, value) {
  target[key] = value;
}
/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */


function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */


function interpolateString(p0, p1, percent) {
  return percent > 0.5 ? p1 : p0;
}
/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */


function interpolateArray(p0, p1, percent, out, arrDim) {
  var len = p0.length;

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      out[i] = interpolateNumber(p0[i], p1[i], percent);
    }
  } else {
    var len2 = len && p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
  }
} // arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1


function fillArr(arr0, arr1, arrDim) {
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;

  if (arr0Len !== arr1Len) {
    // FIXME Not work for TypedArray
    var isPreviousLarger = arr0Len > arr1Len;

    if (isPreviousLarger) {
      // Cut the previous
      arr0.length = arr1Len;
    } else {
      // Fill the previous
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  } // Handling NaN value


  var len2 = arr0[0] && arr0[0].length;

  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */


function isArraySame(arr0, arr1, arrDim) {
  if (arr0 === arr1) {
    return true;
  }

  var len = arr0.length;

  if (len !== arr1.length) {
    return false;
  }

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
  } else {
    var len2 = arr0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        if (arr0[i][j] !== arr1[i][j]) {
          return false;
        }
      }
    }
  }

  return true;
}
/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */


function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
  var len = p0.length;

  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
    }
  } else {
    var len2 = p0[0].length;

    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
      }
    }
  }
}
/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */


function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function cloneValue(value) {
  if (isArrayLike(value)) {
    var len = value.length;

    if (isArrayLike(value[0])) {
      var ret = [];

      for (var i = 0; i < len; i++) {
        ret.push(arraySlice.call(value[i]));
      }

      return ret;
    }

    return arraySlice.call(value);
  }

  return value;
}

function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]);
  rgba[1] = Math.floor(rgba[1]);
  rgba[2] = Math.floor(rgba[2]);
  return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
  var lastValue = keyframes[keyframes.length - 1].value;
  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
  var getter = animator._getter;
  var setter = animator._setter;
  var useSpline = easing === 'spline';
  var trackLen = keyframes.length;

  if (!trackLen) {
    return;
  } // Guess data type


  var firstVal = keyframes[0].value;
  var isValueArray = isArrayLike(firstVal);
  var isValueColor = false;
  var isValueString = false; // For vertices morphing

  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
  var trackMaxTime; // Sort keyframe as ascending

  keyframes.sort(function (a, b) {
    return a.time - b.time;
  });
  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

  var kfPercents = []; // Value of each keyframe

  var kfValues = [];
  var prevValue = keyframes[0].value;
  var isAllValueEqual = true;

  for (var i = 0; i < trackLen; i++) {
    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

    var value = keyframes[i].value; // Check if value is equal, deep check if value is array

    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
      isAllValueEqual = false;
    }

    prevValue = value; // Try converting a string to a color array

    if (typeof value === 'string') {
      var colorArray = color.parse(value);

      if (colorArray) {
        value = colorArray;
        isValueColor = true;
      } else {
        isValueString = true;
      }
    }

    kfValues.push(value);
  }

  if (!forceAnimate && isAllValueEqual) {
    return;
  }

  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

  for (var i = 0; i < trackLen - 1; i++) {
    if (isValueArray) {
      fillArr(kfValues[i], lastValue, arrDim);
    } else {
      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
        kfValues[i] = lastValue;
      }
    }
  }

  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
  // animation playback is sequency

  var lastFrame = 0;
  var lastFramePercent = 0;
  var start;
  var w;
  var p0;
  var p1;
  var p2;
  var p3;

  if (isValueColor) {
    var rgba = [0, 0, 0, 0];
  }

  var onframe = function (target, percent) {
    // Find the range keyframes
    // kf1-----kf2---------current--------kf3
    // find kf2 and kf3 and do interpolation
    var frame; // In the easing function like elasticOut, percent may less than 0

    if (percent < 0) {
      frame = 0;
    } else if (percent < lastFramePercent) {
      // Start from next key
      // PENDING start from lastFrame ?
      start = Math.min(lastFrame + 1, trackLen - 1);

      for (frame = start; frame >= 0; frame--) {
        if (kfPercents[frame] <= percent) {
          break;
        }
      } // PENDING really need to do this ?


      frame = Math.min(frame, trackLen - 2);
    } else {
      for (frame = lastFrame; frame < trackLen; frame++) {
        if (kfPercents[frame] > percent) {
          break;
        }
      }

      frame = Math.min(frame - 1, trackLen - 2);
    }

    lastFrame = frame;
    lastFramePercent = percent;
    var range = kfPercents[frame + 1] - kfPercents[frame];

    if (range === 0) {
      return;
    } else {
      w = (percent - kfPercents[frame]) / range;
    }

    if (useSpline) {
      p1 = kfValues[frame];
      p0 = kfValues[frame === 0 ? frame : frame - 1];
      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

      if (isValueArray) {
        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(p1, p2, w);
        } else {
          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
        }

        setter(target, propName, value);
      }
    } else {
      if (isValueArray) {
        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
      } else {
        var value;

        if (isValueColor) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
          value = rgba2String(rgba);
        } else if (isValueString) {
          // String is step(0.5)
          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
        } else {
          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
        }

        setter(target, propName, value);
      }
    }
  };

  var clip = new Clip({
    target: animator._target,
    life: trackMaxTime,
    loop: animator._loop,
    delay: animator._delay,
    onframe: onframe,
    ondestroy: oneTrackDone
  });

  if (easing && easing !== 'spline') {
    clip.easing = easing;
  }

  return clip;
}
/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */


var Animator = function (target, loop, getter, setter) {
  this._tracks = {};
  this._target = target;
  this._loop = loop || false;
  this._getter = getter || defaultGetter;
  this._setter = setter || defaultSetter;
  this._clipCount = 0;
  this._delay = 0;
  this._doneList = [];
  this._onframeList = [];
  this._clipList = [];
};

Animator.prototype = {
  /**
   * Set Animation keyframe
   * @param  {number} time 关键帧时间，单位是ms
   * @param  {Object} props 关键帧的属性值，key-value表示
   * @return {module:zrender/animation/Animator}
   */
  when: function (time
  /* ms */
  , props) {
    var tracks = this._tracks;

    for (var propName in props) {
      if (!props.hasOwnProperty(propName)) {
        continue;
      }

      if (!tracks[propName]) {
        tracks[propName] = []; // Invalid value

        var value = this._getter(this._target, propName);

        if (value == null) {
          // zrLog('Invalid property ' + propName);
          continue;
        } // If time is 0
        //  Then props is given initialize value
        // Else
        //  Initialize value from current prop value


        if (time !== 0) {
          tracks[propName].push({
            time: 0,
            value: cloneValue(value)
          });
        }
      }

      tracks[propName].push({
        time: time,
        value: props[propName]
      });
    }

    return this;
  },

  /**
   * 添加动画每一帧的回调函数
   * @param  {Function} callback
   * @return {module:zrender/animation/Animator}
   */
  during: function (callback) {
    this._onframeList.push(callback);

    return this;
  },
  pause: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].pause();
    }

    this._paused = true;
  },
  resume: function () {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].resume();
    }

    this._paused = false;
  },
  isPaused: function () {
    return !!this._paused;
  },
  _doneCallback: function () {
    // Clear all tracks
    this._tracks = {}; // Clear all clips

    this._clipList.length = 0;
    var doneList = this._doneList;
    var len = doneList.length;

    for (var i = 0; i < len; i++) {
      doneList[i].call(this);
    }
  },

  /**
   * Start the animation
   * @param  {string|Function} [easing]
   *         动画缓动函数，详见{@link module:zrender/animation/easing}
   * @param  {boolean} forceAnimate
   * @return {module:zrender/animation/Animator}
   */
  start: function (easing, forceAnimate) {
    var self = this;
    var clipCount = 0;

    var oneTrackDone = function () {
      clipCount--;

      if (!clipCount) {
        self._doneCallback();
      }
    };

    var lastClip;

    for (var propName in this._tracks) {
      if (!this._tracks.hasOwnProperty(propName)) {
        continue;
      }

      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

      if (clip) {
        this._clipList.push(clip);

        clipCount++; // If start after added to animation

        if (this.animation) {
          this.animation.addClip(clip);
        }

        lastClip = clip;
      }
    } // Add during callback on the last clip


    if (lastClip) {
      var oldOnFrame = lastClip.onframe;

      lastClip.onframe = function (target, percent) {
        oldOnFrame(target, percent);

        for (var i = 0; i < self._onframeList.length; i++) {
          self._onframeList[i](target, percent);
        }
      };
    } // This optimization will help the case that in the upper application
    // the view may be refreshed frequently, where animation will be
    // called repeatly but nothing changed.


    if (!clipCount) {
      this._doneCallback();
    }

    return this;
  },

  /**
   * Stop animation
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stop: function (forwardToLast) {
    var clipList = this._clipList;
    var animation = this.animation;

    for (var i = 0; i < clipList.length; i++) {
      var clip = clipList[i];

      if (forwardToLast) {
        // Move to last frame before stop
        clip.onframe(this._target, 1);
      }

      animation && animation.removeClip(clip);
    }

    clipList.length = 0;
  },

  /**
   * Set when animation delay starts
   * @param  {number} time 单位ms
   * @return {module:zrender/animation/Animator}
   */
  delay: function (time) {
    this._delay = time;
    return this;
  },

  /**
   * Add callback for animation end
   * @param  {Function} cb
   * @return {module:zrender/animation/Animator}
   */
  done: function (cb) {
    if (cb) {
      this._doneList.push(cb);
    }

    return this;
  },

  /**
   * @return {Array.<module:zrender/animation/Clip>}
   */
  getClips: function () {
    return this._clipList;
  }
};
var _default = Animator;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Clip.js":
/*!*******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/animation/Clip.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var easingFuncs = __webpack_require__(/*! ./easing */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/easing.js");

/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */
function Clip(options) {
  this._target = options.target; // 生命周期

  this._life = options.life || 1000; // 延时

  this._delay = options.delay || 0; // 开始时间
  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

  this._initialized = false; // 是否循环

  this.loop = options.loop == null ? false : options.loop;
  this.gap = options.gap || 0;
  this.easing = options.easing || 'Linear';
  this.onframe = options.onframe;
  this.ondestroy = options.ondestroy;
  this.onrestart = options.onrestart;
  this._pausedTime = 0;
  this._paused = false;
}

Clip.prototype = {
  constructor: Clip,
  step: function (globalTime, deltaTime) {
    // Set startTime on first step, or _startTime may has milleseconds different between clips
    // PENDING
    if (!this._initialized) {
      this._startTime = globalTime + this._delay;
      this._initialized = true;
    }

    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }

    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

    if (percent < 0) {
      return;
    }

    percent = Math.min(percent, 1);
    var easing = this.easing;
    var easingFunc = typeof easing === 'string' ? easingFuncs[easing] : easing;
    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
    this.fire('frame', schedule); // 结束

    if (percent === 1) {
      if (this.loop) {
        this.restart(globalTime); // 重新开始周期
        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

        return 'restart';
      } // 动画完成将这个控制器标识为待删除
      // 在Animation.update中进行批量删除


      this._needsRemove = true;
      return 'destroy';
    }

    return null;
  },
  restart: function (globalTime) {
    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
    this._startTime = globalTime - remainder + this.gap;
    this._pausedTime = 0;
    this._needsRemove = false;
  },
  fire: function (eventType, arg) {
    eventType = 'on' + eventType;

    if (this[eventType]) {
      this[eventType](this._target, arg);
    }
  },
  pause: function () {
    this._paused = true;
  },
  resume: function () {
    this._paused = false;
  }
};
var _default = Clip;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/animation/easing.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/animation/easing.js ***!
  \*********************************************************************/
/***/ ((module) => {

/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */
var easing = {
  /**
  * @param {number} k
  * @return {number}
  */
  linear: function (k) {
    return k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticIn: function (k) {
    return k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticOut: function (k) {
    return k * (2 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quadraticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }

    return -0.5 * (--k * (k - 2) - 1);
  },
  // 三次方的缓动（t^3）

  /**
  * @param {number} k
  * @return {number}
  */
  cubicIn: function (k) {
    return k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicOut: function (k) {
    return --k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  cubicInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k + 2);
  },
  // 四次方的缓动（t^4）

  /**
  * @param {number} k
  * @return {number}
  */
  quarticIn: function (k) {
    return k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticOut: function (k) {
    return 1 - --k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quarticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }

    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  // 五次方的缓动（t^5）

  /**
  * @param {number} k
  * @return {number}
  */
  quinticIn: function (k) {
    return k * k * k * k * k;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticOut: function (k) {
    return --k * k * k * k * k + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  quinticInOut: function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }

    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  // 正弦曲线的缓动（sin(t)）

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalIn: function (k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalOut: function (k) {
    return Math.sin(k * Math.PI / 2);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalInOut: function (k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  // 指数曲线的缓动（2^t）

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialIn: function (k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialOut: function (k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  exponentialInOut: function (k) {
    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }

    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  // 圆形曲线的缓动（sqrt(1-t^2)）

  /**
  * @param {number} k
  * @return {number}
  */
  circularIn: function (k) {
    return 1 - Math.sqrt(1 - k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularOut: function (k) {
    return Math.sqrt(1 - --k * k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  circularInOut: function (k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }

    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  // 创建类似于弹簧在停止前来回振荡的动画

  /**
  * @param {number} k
  * @return {number}
  */
  elasticIn: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  elasticInOut: function (k) {
    var s;
    var a = 0.1;
    var p = 0.4;

    if (k === 0) {
      return 0;
    }

    if (k === 1) {
      return 1;
    }

    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }

    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }

    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

  /**
  * @param {number} k
  * @return {number}
  */
  backIn: function (k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backOut: function (k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },

  /**
  * @param {number} k
  * @return {number}
  */
  backInOut: function (k) {
    var s = 1.70158 * 1.525;

    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }

    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  // 创建弹跳效果

  /**
  * @param {number} k
  * @return {number}
  */
  bounceIn: function (k) {
    return 1 - easing.bounceOut(1 - k);
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceOut: function (k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },

  /**
  * @param {number} k
  * @return {number}
  */
  bounceInOut: function (k) {
    if (k < 0.5) {
      return easing.bounceIn(k * 2) * 0.5;
    }

    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var _default = easing;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/animation/requestAnimationFrame.js":
/*!************************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/animation/requestAnimationFrame.js ***!
  \************************************************************************************/
/***/ ((module) => {

var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
  setTimeout(func, 16);
};

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/config.js":
/*!***********************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/config.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

var dpr = 1; // If in browser environment

if (typeof window !== 'undefined') {
  dpr = Math.max(window.devicePixelRatio || 1, 1);
}
/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * Debug log mode:
 * 0: Do nothing, for release.
 * 1: console.error, for debug.
 */


var debugMode = 0; // retina 屏幕优化

var devicePixelRatio = dpr;
exports.debugMode = debugMode;
exports.devicePixelRatio = devicePixelRatio;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/arc.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/arc.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _util = __webpack_require__(/*! ./util */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;
var PI2 = Math.PI * 2;
/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */

function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);

  if (d - _l > r || d + _l < r) {
    return false;
  }

  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
    // Is a circle
    return true;
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var angle = Math.atan2(y, x);

  if (angle < 0) {
    angle += PI2;
  }

  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/cubic.js":
/*!******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/cubic.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var curve = __webpack_require__(/*! ../core/curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }

  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/line.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/line.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth;
  var _a = 0;
  var _b = x0; // Quick reject

  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }

  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }

  var tmp = _a * x - y + _b;

  var _s = tmp * tmp / (_a * _a + 1);

  return _s <= _l / 2 * _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/path.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/path.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var line = __webpack_require__(/*! ./line */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/line.js");

var cubic = __webpack_require__(/*! ./cubic */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/cubic.js");

var quadratic = __webpack_require__(/*! ./quadratic */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/quadratic.js");

var arc = __webpack_require__(/*! ./arc */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/arc.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/util.js");

var normalizeRadian = _util.normalizeRadian;

var curve = __webpack_require__(/*! ../core/curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

var windingLine = __webpack_require__(/*! ./windingLine */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/windingLine.js");

var CMD = PathProxy.CMD;
var PI2 = Math.PI * 2;
var EPSILON = 1e-4;

function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
} // 临时数组


var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }

  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_;
    var y1_;

    for (var i = 0; i < nRoots; i++) {
      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = curve.cubicAt(x0, x1, x2, x3, t);

      if (x_ < x) {
        // Quick reject
        continue;
      }

      if (nExtrema < 0) {
        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }

        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

        if (nExtrema > 1) {
          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }

      if (nExtrema === 2) {
        // 分成三段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        // 分成两段单调函数
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }

    return w;
  }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  // Quick reject
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }

  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

  if (nRoots === 0) {
    return 0;
  } else {
    var t = curve.quadraticExtremum(y0, y1, y2);

    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = curve.quadraticAt(y0, y1, y2, t);

      for (var i = 0; i < nRoots; i++) {
        // Remove one endpoint.
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

        if (x_ < x) {
          // Quick reject
          continue;
        }

        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }

      return w;
    } else {
      // Remove one endpoint.
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

      if (x_ < x) {
        // Quick reject
        return 0;
      }

      return y2 < y0 ? unit : -unit;
    }
  }
} // TODO
// Arc 旋转


function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;

  if (y > r || y < -r) {
    return 0;
  }

  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var diff = Math.abs(startAngle - endAngle);

  if (diff < 1e-4) {
    return 0;
  }

  if (diff % PI2 < 1e-4) {
    // Is a circle
    startAngle = 0;
    endAngle = PI2;
    var dir = anticlockwise ? 1 : -1;

    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }

  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }

  if (startAngle > endAngle) {
    endAngle += PI2;
  }

  var w = 0;

  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];

    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir = anticlockwise ? 1 : -1;

      if (angle < 0) {
        angle = PI2 + angle;
      }

      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }

        w += dir;
      }
    }
  }

  return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;

  for (var i = 0; i < data.length;) {
    var cmd = data[i++]; // Begin a new subpath

    if (cmd === CMD.M && i > 1) {
      // Close previous subpath
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      } // 如果被任何一个 subpath 包含
      // if (w !== 0) {
      //     return true;
      // }

    }

    if (i === 1) {
      // 如果第一个命令是 L, C, Q
      // 则 previous point 同绘制命令的第一个 point
      //
      // 第一个命令为 Arc 的情况下会在后面特殊处理
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }

    switch (cmd) {
      case CMD.M:
        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
        // 在 closePath 的时候使用
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;

      case CMD.L:
        if (isStroke) {
          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.C:
        if (isStroke) {
          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.Q:
        if (isStroke) {
          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }

        xi = data[i++];
        yi = data[i++];
        break;

      case CMD.A:
        // TODO Arc 判断的开销比较大
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++]; // TODO Arc 旋转

        i += 1;
        var anticlockwise = 1 - data[i++];
        var x1 = Math.cos(theta) * rx + cx;
        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

        if (i > 1) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          // 第一个命令起点还未定义
          x0 = x1;
          y0 = y1;
        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


        var _x = (x - cx) * ry / rx + cx;

        if (isStroke) {
          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }

        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;

      case CMD.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        var x1 = x0 + width;
        var y1 = y0 + height;

        if (isStroke) {
          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // FIXME Clockwise ?
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }

        break;

      case CMD.Z:
        if (isStroke) {
          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          // Close a subpath
          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
          // FIXME subpaths may overlap
          // if (w !== 0) {
          //     return true;
          // }
        }

        xi = x0;
        yi = y0;
        break;
    }
  }

  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }

  return w !== 0;
}

function contain(pathData, x, y) {
  return containPath(pathData, 0, false, x, y);
}

function containStroke(pathData, lineWidth, x, y) {
  return containPath(pathData, lineWidth, true, x, y);
}

exports.contain = contain;
exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/quadratic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/quadratic.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _curve = __webpack_require__(/*! ../core/curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

var quadraticProjectPoint = _curve.quadraticProjectPoint;

/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }

  var _l = lineWidth; // Quick reject

  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }

  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

exports.containStroke = containStroke;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var imageHelper = __webpack_require__(/*! ../graphic/helper/image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/image.js");

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var getContext = _util.getContext;
var extend = _util.extend;
var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var trim = _util.trim;
var textWidthCache = {};
var textWidthCacheCounter = 0;
var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  methods[name] = fn;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */


function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var key = text + ':' + font;

  if (textWidthCache[key]) {
    return textWidthCache[key];
  }

  var textLines = (text + '').split('\n');
  var width = 0;

  for (var i = 0, l = textLines.length; i < l; i++) {
    // textContain.measureText may be overrided in SVG or VML
    width = Math.max(measureText(textLines[i], font).width, width);
  }

  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
    textWidthCacheCounter = 0;
    textWidthCache = {};
  }

  textWidthCacheCounter++;
  textWidthCache[key] = width;
  return width;
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */


function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);
  var outerWidth = getWidth(text, font);

  if (textPadding) {
    outerWidth += textPadding[1] + textPadding[3];
  }

  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
  rect.lineHeight = contentBlock.lineHeight;
  return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
  var contentBlock = parseRichText(text, {
    rich: rich,
    truncate: truncate,
    font: font,
    textAlign: textAlign,
    textPadding: textPadding,
    textLineHeight: textLineHeight
  });
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  return new BoundingRect(x, y, outerWidth, outerHeight);
}
/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */


function adjustTextX(x, width, textAlign) {
  // FIXME Right to left language
  if (textAlign === 'right') {
    x -= width;
  } else if (textAlign === 'center') {
    x -= width / 2;
  }

  return x;
}
/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */


function adjustTextY(y, height, textVerticalAlign) {
  if (textVerticalAlign === 'middle') {
    y -= height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y -= height;
  }

  return y;
}
/**
 * Follow same interface to `Displayable.prototype.calculateTextPosition`.
 * @public
 * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.
 * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.
 * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.
 * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}
 */


function calculateTextPosition(out, style, rect) {
  var textPosition = style.textPosition;
  var distance = style.textDistance;
  var x = rect.x;
  var y = rect.y;
  distance = distance || 0;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var textAlign = 'left';
  var textVerticalAlign = 'top';

  switch (textPosition) {
    case 'left':
      x -= distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'right':
      x += distance + width;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'top':
      x += width / 2;
      y -= distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'bottom':
      x += width / 2;
      y += height + distance;
      textAlign = 'center';
      break;

    case 'inside':
      x += width / 2;
      y += halfHeight;
      textAlign = 'center';
      textVerticalAlign = 'middle';
      break;

    case 'insideLeft':
      x += distance;
      y += halfHeight;
      textVerticalAlign = 'middle';
      break;

    case 'insideRight':
      x += width - distance;
      y += halfHeight;
      textAlign = 'right';
      textVerticalAlign = 'middle';
      break;

    case 'insideTop':
      x += width / 2;
      y += distance;
      textAlign = 'center';
      break;

    case 'insideBottom':
      x += width / 2;
      y += height - distance;
      textAlign = 'center';
      textVerticalAlign = 'bottom';
      break;

    case 'insideTopLeft':
      x += distance;
      y += distance;
      break;

    case 'insideTopRight':
      x += width - distance;
      y += distance;
      textAlign = 'right';
      break;

    case 'insideBottomLeft':
      x += distance;
      y += height - distance;
      textVerticalAlign = 'bottom';
      break;

    case 'insideBottomRight':
      x += width - distance;
      y += height - distance;
      textAlign = 'right';
      textVerticalAlign = 'bottom';
      break;
  }

  out = out || {};
  out.x = x;
  out.y = y;
  out.textAlign = textAlign;
  out.textVerticalAlign = textVerticalAlign;
  return out;
}
/**
 * To be removed. But still do not remove in case that some one has imported it.
 * @deprecated
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */


function adjustTextPositionOnRect(textPosition, rect, distance) {
  var dummyStyle = {
    textPosition: textPosition,
    textDistance: distance
  };
  return calculateTextPosition({}, dummyStyle, rect);
}
/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */


function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return '';
  }

  var textLines = (text + '').split('\n');
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
  // It is not appropriate that every line has '...' when truncate multiple lines.

  for (var i = 0, len = textLines.length; i < len; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }

  return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = extend({}, options);
  options.font = font;
  var ellipsis = retrieve2(ellipsis, '...');
  options.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
  // Other languages?

  options.cnCharWidth = getWidth('国', font); // FIXME
  // Consider proportional font?

  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }

  var ellipsisWidth = getWidth(ellipsis, font);

  if (ellipsisWidth > contentWidth) {
    ellipsis = '';
    ellipsisWidth = 0;
  }

  contentWidth = containerWidth - ellipsisWidth;
  options.ellipsis = ellipsis;
  options.ellipsisWidth = ellipsisWidth;
  options.contentWidth = contentWidth;
  options.containerWidth = containerWidth;
  return options;
}

function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;

  if (!containerWidth) {
    return '';
  }

  var lineWidth = getWidth(textLine, font);

  if (lineWidth <= containerWidth) {
    return textLine;
  }

  for (var j = 0;; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }

    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }

  if (textLine === '') {
    textLine = options.placeholder;
  }

  return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;

  for (var len = text.length; i < len && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }

  return i;
}
/**
 * @public
 * @param {string} font
 * @return {number} line height
 */


function getLineHeight(font) {
  // FIXME A rough approach.
  return getWidth('国', font);
}
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */


function measureText(text, font) {
  return methods.measureText(text, font);
} // Avoid assign to an exported variable, for transforming to cjs.


methods.measureText = function (text, font) {
  var ctx = getContext();
  ctx.font = font || DEFAULT_FONT;
  return ctx.measureText(text);
};
/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}
 *  Notice: for performance, do not calculate outerWidth util needed.
 *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.
 *  Thus we can simply comparing the `input` text to determin whether the result changed,
 *  without travel the result `lines`.
 */


function parsePlainText(text, font, padding, textLineHeight, truncate) {
  text != null && (text += '');
  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));
  var lines = text ? text.split('\n') : [];
  var height = lines.length * lineHeight;
  var outerHeight = height;
  var canCacheByTextString = true;

  if (padding) {
    outerHeight += padding[0] + padding[2];
  }

  if (text && truncate) {
    canCacheByTextString = false;
    var truncOuterHeight = truncate.outerHeight;
    var truncOuterWidth = truncate.outerWidth;

    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
      text = '';
      lines = [];
    } else if (truncOuterWidth != null) {
      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
        minChar: truncate.minChar,
        placeholder: truncate.placeholder
      }); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = lines.length; i < len; i++) {
        lines[i] = truncateSingleLine(lines[i], options);
      }
    }
  }

  return {
    lines: lines,
    height: height,
    outerHeight: outerHeight,
    lineHeight: lineHeight,
    canCacheByTextString: canCacheByTextString
  };
}
/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */


function parseRichText(text, style) {
  var contentBlock = {
    lines: [],
    width: 0,
    height: 0
  };
  text != null && (text += '');

  if (!text) {
    return contentBlock;
  }

  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;

  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;

    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
    }

    pushTokens(contentBlock, result[2], result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }

  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length));
  }

  var lines = contentBlock.lines;
  var contentHeight = 0;
  var contentWidth = 0; // For `textWidth: 100%`

  var pendingList = [];
  var stlPadding = style.textPadding;
  var truncate = style.truncate;
  var truncateWidth = truncate && truncate.outerWidth;
  var truncateHeight = truncate && truncate.outerHeight;

  if (stlPadding) {
    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
  } // Calculate layout info of tokens.


  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var lineHeight = 0;
    var lineWidth = 0;

    for (var j = 0; j < line.tokens.length; j++) {
      var token = line.tokens[j];
      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
      // as box height of the block.
      tokenStyle.textHeight, getLineHeight(font));
      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
      token.height = tokenHeight;
      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
        return {
          lines: [],
          width: 0,
          height: 0
        };
      }

      token.textWidth = getWidth(token.text, font);
      var tokenWidth = tokenStyle.textWidth;
      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
      // line when box width is needed to be auto.

      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
        token.percentWidth = tokenWidth;
        pendingList.push(token);
        tokenWidth = 0; // Do not truncate in this case, because there is no user case
        // and it is too complicated.
      } else {
        if (tokenWidthNotSpecified) {
          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
          // `getBoundingRect()` will not get correct result.

          var textBackgroundColor = tokenStyle.textBackgroundColor;
          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
          // (1) If image is not loaded, it will be loaded at render phase and call
          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
          // image, and then the right size will be calculated here at the next tick.
          // See `graphic/helper/text.js`.
          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
          // use `imageHelper.findExistImage` to find cached image.
          // `imageHelper.findExistImage` will always be called here before
          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
          // which ensures that image will not be rendered before correct size calcualted.

          if (bgImg) {
            bgImg = imageHelper.findExistImage(bgImg);

            if (imageHelper.isImageReady(bgImg)) {
              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
            }
          }
        }

        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
        tokenWidth += paddingW;
        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
            token.text = '';
            token.textWidth = tokenWidth = 0;
          } else {
            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
              minChar: truncate.minChar
            });
            token.textWidth = getWidth(token.text, font);
            tokenWidth = token.textWidth + paddingW;
          }
        }
      }

      lineWidth += token.width = tokenWidth;
      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
    }

    line.width = lineWidth;
    line.lineHeight = lineHeight;
    contentHeight += lineHeight;
    contentWidth = Math.max(contentWidth, lineWidth);
  }

  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);

  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }

  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
  }

  return contentBlock;
}

function pushTokens(block, str, styleName) {
  var isEmptyStr = str === '';
  var strs = str.split('\n');
  var lines = block.lines;

  for (var i = 0; i < strs.length; i++) {
    var text = strs[i];
    var token = {
      styleName: styleName,
      text: text,
      isLineHolder: !text && !isEmptyStr
    }; // The first token should be appended to the last line.

    if (!i) {
      var tokens = (lines[lines.length - 1] || (lines[0] = {
        tokens: []
      })).tokens; // Consider cases:
      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
      // (which is a placeholder) should be replaced by new token.
      // (2) A image backage, where token likes {a|}.
      // (3) A redundant '' will affect textAlign in line.
      // (4) tokens with the same tplName should not be merged, because
      // they should be displayed in different box (with border and padding).

      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
      (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } // Other tokens always start a new line.
    else {
        // If there is '', insert it as a placeholder.
        lines.push({
          tokens: [token]
        });
      }
  }
}

function makeFont(style) {
  // FIXME in node-canvas fontWeight is before fontStyle
  // Use `fontSize` `fontFamily` to check whether font properties are defined.
  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
  style.fontFamily || 'sans-serif'].join(' ');
  return font && trim(font) || style.textFont || style.font;
}

exports.DEFAULT_FONT = DEFAULT_FONT;
exports.$override = $override;
exports.getWidth = getWidth;
exports.getBoundingRect = getBoundingRect;
exports.adjustTextX = adjustTextX;
exports.adjustTextY = adjustTextY;
exports.calculateTextPosition = calculateTextPosition;
exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
exports.truncateText = truncateText;
exports.getLineHeight = getLineHeight;
exports.measureText = measureText;
exports.parsePlainText = parsePlainText;
exports.parseRichText = parseRichText;
exports.makeFont = makeFont;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/util.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
  angle %= PI2;

  if (angle < 0) {
    angle += PI2;
  }

  return angle;
}

exports.normalizeRadian = normalizeRadian;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/contain/windingLine.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/contain/windingLine.js ***!
  \************************************************************************/
/***/ ((module) => {

function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  } // Ignore horizontal line


  if (y1 === y0) {
    return 0;
  }

  var dir = y1 < y0 ? 1 : -1;
  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

  if (t === 1 || t === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }

  var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as "contain".

  return x_ === x ? Infinity : x_ > x ? dir : 0;
}

module.exports = windingLine;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/container/Group.js":
/*!********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/container/Group.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Element = __webpack_require__(/*! ../Element */ "./node_modules/_zrender@4.3.2@zrender/lib/Element.js");

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */

/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */
var Group = function (opts) {
  opts = opts || {};
  Element.call(this, opts);

  for (var key in opts) {
    if (opts.hasOwnProperty(key)) {
      this[key] = opts[key];
    }
  }

  this._children = [];
  this.__storage = null;
  this.__dirty = true;
};

Group.prototype = {
  constructor: Group,
  isGroup: true,

  /**
   * @type {string}
   */
  type: 'group',

  /**
   * 所有子孙元素是否响应鼠标事件
   * @name module:/zrender/container/Group#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * @return {Array.<module:zrender/Element>}
   */
  children: function () {
    return this._children.slice();
  },

  /**
   * 获取指定 index 的儿子节点
   * @param  {number} idx
   * @return {module:zrender/Element}
   */
  childAt: function (idx) {
    return this._children[idx];
  },

  /**
   * 获取指定名字的儿子节点
   * @param  {string} name
   * @return {module:zrender/Element}
   */
  childOfName: function (name) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  },

  /**
   * @return {number}
   */
  childCount: function () {
    return this._children.length;
  },

  /**
   * 添加子节点到最后
   * @param {module:zrender/Element} child
   */
  add: function (child) {
    if (child && child !== this && child.parent !== this) {
      this._children.push(child);

      this._doAdd(child);
    }

    return this;
  },

  /**
   * 添加子节点在 nextSibling 之前
   * @param {module:zrender/Element} child
   * @param {module:zrender/Element} nextSibling
   */
  addBefore: function (child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);

      if (idx >= 0) {
        children.splice(idx, 0, child);

        this._doAdd(child);
      }
    }

    return this;
  },
  _doAdd: function (child) {
    if (child.parent) {
      child.parent.remove(child);
    }

    child.parent = this;
    var storage = this.__storage;
    var zr = this.__zr;

    if (storage && storage !== child.__storage) {
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }

    zr && zr.refresh();
  },

  /**
   * 移除子节点
   * @param {module:zrender/Element} child
   */
  remove: function (child) {
    var zr = this.__zr;
    var storage = this.__storage;
    var children = this._children;
    var idx = zrUtil.indexOf(children, child);

    if (idx < 0) {
      return this;
    }

    children.splice(idx, 1);
    child.parent = null;

    if (storage) {
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }

    zr && zr.refresh();
    return this;
  },

  /**
   * 移除所有子节点
   */
  removeAll: function () {
    var children = this._children;
    var storage = this.__storage;
    var child;
    var i;

    for (i = 0; i < children.length; i++) {
      child = children[i];

      if (storage) {
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }

      child.parent = null;
    }

    children.length = 0;
    return this;
  },

  /**
   * 遍历所有子节点
   * @param  {Function} cb
   * @param  {}   context
   */
  eachChild: function (cb, context) {
    var children = this._children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }

    return this;
  },

  /**
   * 深度优先遍历所有子孙节点
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      cb.call(context, child);

      if (child.type === 'group') {
        child.traverse(cb, context);
      }
    }

    return this;
  },
  addChildrenToStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.addToStorage(child);

      if (child instanceof Group) {
        child.addChildrenToStorage(storage);
      }
    }
  },
  delChildrenFromStorage: function (storage) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage.delFromStorage(child);

      if (child instanceof Group) {
        child.delChildrenFromStorage(storage);
      }
    }
  },
  dirty: function () {
    this.__dirty = true;
    this.__zr && this.__zr.refresh();
    return this;
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function (includeChildren) {
    // TODO Caching
    var rect = null;
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (child.ignore || child.invisible) {
        continue;
      }

      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat); // TODO
      // The boundingRect cacluated by transforming original
      // rect may be bigger than the actual bundingRect when rotation
      // is used. (Consider a circle rotated aginst its center, where
      // the actual boundingRect should be the same as that not be
      // rotated.) But we can not find better approach to calculate
      // actual boundingRect yet, considering performance.

      if (transform) {
        tmpRect.copy(childRect);
        tmpRect.applyTransform(transform);
        rect = rect || tmpRect.clone();
        rect.union(tmpRect);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }

    return rect || tmpRect;
  }
};
zrUtil.inherits(Group, Element);
var _default = Group;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var vec2 = __webpack_require__(/*! ./vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var matrix = __webpack_require__(/*! ./matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

/**
 * @module echarts/core/BoundingRect
 */
var v2ApplyTransform = vec2.applyTransform;
var mathMin = Math.min;
var mathMax = Math.max;
/**
 * @alias module:echarts/core/BoundingRect
 */

function BoundingRect(x, y, width, height) {
  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }
  /**
   * @type {number}
   */


  this.x = x;
  /**
   * @type {number}
   */

  this.y = y;
  /**
   * @type {number}
   */

  this.width = width;
  /**
   * @type {number}
   */

  this.height = height;
}

BoundingRect.prototype = {
  constructor: BoundingRect,

  /**
   * @param {module:echarts/core/BoundingRect} other
   */
  union: function (other) {
    var x = mathMin(other.x, this.x);
    var y = mathMin(other.y, this.y);
    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    this.x = x;
    this.y = y;
  },

  /**
   * @param {Array.<number>} m
   * @methods
   */
  applyTransform: function () {
    var lt = [];
    var rb = [];
    var lb = [];
    var rt = [];
    return function (m) {
      // In case usage like this
      // el.getBoundingRect().applyTransform(el.transform)
      // And element has no transform
      if (!m) {
        return;
      }

      lt[0] = lb[0] = this.x;
      lt[1] = rt[1] = this.y;
      rb[0] = rt[0] = this.x + this.width;
      rb[1] = lb[1] = this.y + this.height;
      v2ApplyTransform(lt, lt, m);
      v2ApplyTransform(rb, rb, m);
      v2ApplyTransform(lb, lb, m);
      v2ApplyTransform(rt, rt, m);
      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
      this.width = maxX - this.x;
      this.height = maxY - this.y;
    };
  }(),

  /**
   * Calculate matrix of transforming from self to target rect
   * @param  {module:zrender/core/BoundingRect} b
   * @return {Array.<number>}
   */
  calculateTransform: function (b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m = matrix.create(); // 矩阵右乘

    matrix.translate(m, m, [-a.x, -a.y]);
    matrix.scale(m, m, [sx, sy]);
    matrix.translate(m, m, [b.x, b.y]);
    return m;
  },

  /**
   * @param {(module:echarts/core/BoundingRect|Object)} b
   * @return {boolean}
   */
  intersect: function (b) {
    if (!b) {
      return false;
    }

    if (!(b instanceof BoundingRect)) {
      // Normalize negative width/height.
      b = BoundingRect.create(b);
    }

    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
  },
  contain: function (x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  },

  /**
   * @return {module:echarts/core/BoundingRect}
   */
  clone: function () {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  },

  /**
   * Copy from another rect
   */
  copy: function (other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
  },
  plain: function () {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
};
/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */

BoundingRect.create = function (rect) {
  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

var _default = BoundingRect;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/GestureMgr.js":
/*!********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/GestureMgr.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eventUtil = __webpack_require__(/*! ./event */ "./node_modules/_zrender@4.3.2@zrender/lib/core/event.js");

/**
 * Only implements needed gestures for mobile.
 */
var GestureMgr = function () {
  /**
   * @private
   * @type {Array.<Object>}
   */
  this._track = [];
};

GestureMgr.prototype = {
  constructor: GestureMgr,
  recognize: function (event, target, root) {
    this._doTrack(event, target, root);

    return this._recognize(event);
  },
  clear: function () {
    this._track.length = 0;
    return this;
  },
  _doTrack: function (event, target, root) {
    var touches = event.touches;

    if (!touches) {
      return;
    }

    var trackItem = {
      points: [],
      touches: [],
      target: target,
      event: event
    };

    for (var i = 0, len = touches.length; i < len; i++) {
      var touch = touches[i];
      var pos = eventUtil.clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }

    this._track.push(trackItem);
  },
  _recognize: function (event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);

        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};

function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}

var recognizers = {
  pinch: function (track, event) {
    var trackLen = track.length;

    if (!trackLen) {
      return;
    }

    var pinchEnd = (track[trackLen - 1] || {}).points;
    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: 'pinch',
        target: track[0].target,
        event: event
      };
    }
  } // Only pinch currently.

};
var _default = GestureMgr;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/LRU.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/LRU.js ***!
  \*************************************************************/
/***/ ((module) => {

// Simple LRU cache use doubly linked list
// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */
var LinkedList = function () {
  /**
   * @type {module:zrender/core/LRU~Entry}
   */
  this.head = null;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.tail = null;
  this._len = 0;
};

var linkedListProto = LinkedList.prototype;
/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */

linkedListProto.insert = function (val) {
  var entry = new Entry(val);
  this.insertEntry(entry);
  return entry;
};
/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.insertEntry = function (entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    entry.next = null;
    this.tail = entry;
  }

  this._len++;
};
/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */


linkedListProto.remove = function (entry) {
  var prev = entry.prev;
  var next = entry.next;

  if (prev) {
    prev.next = next;
  } else {
    // Is head
    this.head = next;
  }

  if (next) {
    next.prev = prev;
  } else {
    // Is tail
    this.tail = prev;
  }

  entry.next = entry.prev = null;
  this._len--;
};
/**
 * @return {number}
 */


linkedListProto.len = function () {
  return this._len;
};
/**
 * Clear list
 */


linkedListProto.clear = function () {
  this.head = this.tail = null;
  this._len = 0;
};
/**
 * @constructor
 * @param {} val
 */


var Entry = function (val) {
  /**
   * @type {}
   */
  this.value = val;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.next;
  /**
   * @type {module:zrender/core/LRU~Entry}
   */

  this.prev;
};
/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */


var LRU = function (maxSize) {
  this._list = new LinkedList();
  this._map = {};
  this._maxSize = maxSize || 10;
  this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;
/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */

LRUProto.put = function (key, value) {
  var list = this._list;
  var map = this._map;
  var removed = null;

  if (map[key] == null) {
    var len = list.len(); // Reuse last removed entry

    var entry = this._lastRemovedEntry;

    if (len >= this._maxSize && len > 0) {
      // Remove the least recently used
      var leastUsedEntry = list.head;
      list.remove(leastUsedEntry);
      delete map[leastUsedEntry.key];
      removed = leastUsedEntry.value;
      this._lastRemovedEntry = leastUsedEntry;
    }

    if (entry) {
      entry.value = value;
    } else {
      entry = new Entry(value);
    }

    entry.key = key;
    list.insertEntry(entry);
    map[key] = entry;
  }

  return removed;
};
/**
 * @param  {string} key
 * @return {}
 */


LRUProto.get = function (key) {
  var entry = this._map[key];
  var list = this._list;

  if (entry != null) {
    // Put the latest used entry in the tail
    if (entry !== list.tail) {
      list.remove(entry);
      list.insertEntry(entry);
    }

    return entry.value;
  }
};
/**
 * Clear the cache
 */


LRUProto.clear = function () {
  this._list.clear();

  this._map = {};
};

var _default = LRU;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js":
/*!*******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var curve = __webpack_require__(/*! ./curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

var vec2 = __webpack_require__(/*! ./vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var bbox = __webpack_require__(/*! ./bbox */ "./node_modules/_zrender@4.3.2@zrender/lib/core/bbox.js");

var BoundingRect = __webpack_require__(/*! ./BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var _config = __webpack_require__(/*! ../config */ "./node_modules/_zrender@4.3.2@zrender/lib/config.js");

var dpr = _config.devicePixelRatio;

/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */
// TODO getTotalLength, getPointAtLength

/* global Float32Array */
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
}; // var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };

var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin = Math.min;
var mathMax = Math.max;
var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;
var hasTypedArray = typeof Float32Array !== 'undefined';
/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */

var PathProxy = function (notSaveData) {
  this._saveData = !(notSaveData || false);

  if (this._saveData) {
    /**
     * Path data. Stored as flat array
     * @type {Array.<Object>}
     */
    this.data = [];
  }

  this._ctx = null;
};
/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */


PathProxy.prototype = {
  constructor: PathProxy,
  _xi: 0,
  _yi: 0,
  _x0: 0,
  _y0: 0,
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux: 0,
  _uy: 0,
  _len: 0,
  _lineDash: null,
  _dashOffset: 0,
  _dashIdx: 0,
  _dashSum: 0,

  /**
   * @readOnly
   */
  setScale: function (sx, sy, segmentIgnoreThreshold) {
    // Compat. Previously there is no segmentIgnoreThreshold.
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;
    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;
  },
  getContext: function () {
    return this._ctx;
  },

  /**
   * @param  {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  beginPath: function (ctx) {
    this._ctx = ctx;
    ctx && ctx.beginPath();
    ctx && (this.dpr = ctx.dpr); // Reset

    if (this._saveData) {
      this._len = 0;
    }

    if (this._lineDash) {
      this._lineDash = null;
      this._dashOffset = 0;
    }

    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  moveTo: function (x, y) {
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  },

  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  lineTo: function (x, y) {
    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
    || this._len < 5;
    this.addData(CMD.L, x, y);

    if (this._ctx && exceedUnit) {
      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
    }

    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
    }

    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @param  {number} x3
   * @param  {number} y3
   * @return {module:zrender/core/PathProxy}
   */
  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

    if (this._ctx) {
      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }

    this._xi = x3;
    this._yi = y3;
    return this;
  },

  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {module:zrender/core/PathProxy}
   */
  quadraticCurveTo: function (x1, y1, x2, y2) {
    this.addData(CMD.Q, x1, y1, x2, y2);

    if (this._ctx) {
      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }

    this._xi = x2;
    this._yi = y2;
    return this;
  },

  /**
   * @param  {number} cx
   * @param  {number} cy
   * @param  {number} r
   * @param  {number} startAngle
   * @param  {number} endAngle
   * @param  {boolean} anticlockwise
   * @return {module:zrender/core/PathProxy}
   */
  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos(endAngle) * r + cx;
    this._yi = mathSin(endAngle) * r + cy;
    return this;
  },
  // TODO
  arcTo: function (x1, y1, x2, y2, radius) {
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }

    return this;
  },
  // TODO
  rect: function (x, y, w, h) {
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  },

  /**
   * @return {module:zrender/core/PathProxy}
   */
  closePath: function () {
    this.addData(CMD.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;

    if (ctx) {
      this._needsDash() && this._dashedLineTo(x0, y0);
      ctx.closePath();
    }

    this._xi = x0;
    this._yi = y0;
    return this;
  },

  /**
   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
   * stroke 同样
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  fill: function (ctx) {
    ctx && ctx.fill();
    this.toStatic();
  },

  /**
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  stroke: function (ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDash: function (lineDash) {
    if (lineDash instanceof Array) {
      this._lineDash = lineDash;
      this._dashIdx = 0;
      var lineDashSum = 0;

      for (var i = 0; i < lineDash.length; i++) {
        lineDashSum += lineDash[i];
      }

      this._dashSum = lineDashSum;
    }

    return this;
  },

  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDashOffset: function (offset) {
    this._dashOffset = offset;
    return this;
  },

  /**
   *
   * @return {boolean}
   */
  len: function () {
    return this._len;
  },

  /**
   * 直接设置 Path 数据
   */
  setData: function (data) {
    var len = data.length;

    if (!(this.data && this.data.length === len) && hasTypedArray) {
      this.data = new Float32Array(len);
    }

    for (var i = 0; i < len; i++) {
      this.data[i] = data[i];
    }

    this._len = len;
  },

  /**
   * 添加子路径
   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
   */
  appendPath: function (path) {
    if (!(path instanceof Array)) {
      path = [path];
    }

    var len = path.length;
    var appendSize = 0;
    var offset = this._len;

    for (var i = 0; i < len; i++) {
      appendSize += path[i].len();
    }

    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }

    for (var i = 0; i < len; i++) {
      var appendPathData = path[i].data;

      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }

    this._len = offset;
  },

  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData: function (cmd) {
    if (!this._saveData) {
      return;
    }

    var data = this.data;

    if (this._len + arguments.length > data.length) {
      // 因为之前的数组已经转换成静态的 Float32Array
      // 所以不够用时需要扩展一个新的动态数组
      this._expandData();

      data = this.data;
    }

    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }

    this._prevCmd = cmd;
  },
  _expandData: function () {
    // Only if data is Float32Array
    if (!(this.data instanceof Array)) {
      var newData = [];

      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }

      this.data = newData;
    }
  },

  /**
   * If needs js implemented dashed line
   * @return {boolean}
   * @private
   */
  _needsDash: function () {
    return this._lineDash;
  },
  _dashedLineTo: function (x1, y1) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var dx = x1 - x0;
    var dy = y1 - y0;
    var dist = mathSqrt(dx * dx + dy * dy);
    var x = x0;
    var y = y0;
    var dash;
    var nDash = lineDash.length;
    var idx;
    dx /= dist;
    dy /= dist;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum;
    x -= offset * dx;
    y -= offset * dy;

    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
      idx = this._dashIdx;
      dash = lineDash[idx];
      x += dx * dash;
      y += dy * dash;
      this._dashIdx = (idx + 1) % nDash; // Skip positive offset

      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
        continue;
      }

      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
    } // Offset for next lineTo


    dx = x - x1;
    dy = y - y1;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  // Not accurate dashed line to
  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var t;
    var dx;
    var dy;
    var cubicAt = curve.cubicAt;
    var bezierLen = 0;
    var idx = this._dashIdx;
    var nDash = lineDash.length;
    var x;
    var y;
    var tmpLen = 0;

    if (offset < 0) {
      // Convert to positive offset
      offset = dashSum + offset;
    }

    offset %= dashSum; // Bezier approx length

    for (t = 0; t < 1; t += 0.1) {
      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
      bezierLen += mathSqrt(dx * dx + dy * dy);
    } // Find idx after add offset


    for (; idx < nDash; idx++) {
      tmpLen += lineDash[idx];

      if (tmpLen > offset) {
        break;
      }
    }

    t = (tmpLen - offset) / bezierLen;

    while (t <= 1) {
      x = cubicAt(x0, x1, x2, x3, t);
      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
      // Bad result if dash is long

      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      t += lineDash[idx] / bezierLen;
      idx = (idx + 1) % nDash;
    } // Finish the last segment and calculate the new offset


    idx % 2 !== 0 && ctx.lineTo(x3, y3);
    dx = x3 - x;
    dy = y3 - y;
    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
  },
  _dashedQuadraticTo: function (x1, y1, x2, y2) {
    // Convert quadratic to cubic using degree elevation
    var x3 = x2;
    var y3 = y2;
    x2 = (x2 + 2 * x1) / 3;
    y2 = (y2 + 2 * y1) / 3;
    x1 = (this._xi + 2 * x1) / 3;
    y1 = (this._yi + 2 * y1) / 3;

    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
  },

  /**
   * 转成静态的 Float32Array 减少堆内存占用
   * Convert dynamic array to static Float32Array
   */
  toStatic: function () {
    var data = this.data;

    if (data instanceof Array) {
      data.length = this._len;

      if (hasTypedArray) {
        this.data = new Float32Array(data);
      }
    }
  },

  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function () {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];

      if (i === 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
          // 在 closePath 的时候使用
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;

        case CMD.L:
          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.C:
          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.Q:
          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;

        case CMD.A:
          // TODO Arc 判断的开销比较大
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle; // TODO Arc 旋转

          i += 1;
          var anticlockwise = 1 - data[i++];

          if (i === 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(startAngle) * rx + cx;
            y0 = mathSin(startAngle) * ry + cy;
          }

          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++]; // Use fromLine

          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;

        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      } // Union


      vec2.min(min, min, min2);
      vec2.max(max, max, max2);
    } // No data


    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },

  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath: function (ctx) {
    var d = this.data;
    var x0;
    var y0;
    var xi;
    var yi;
    var x;
    var y;
    var ux = this._ux;
    var uy = this._uy;
    var len = this._len;

    for (var i = 0; i < len;) {
      var cmd = d[i++];

      if (i === 1) {
        // 如果第一个命令是 L, C, Q
        // 则 previous point 同绘制命令的第一个 point
        //
        // 第一个命令为 Arc 的情况下会在后面特殊处理
        xi = d[i];
        yi = d[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD.M:
          x0 = xi = d[i++];
          y0 = yi = d[i++];
          ctx.moveTo(xi, yi);
          break;

        case CMD.L:
          x = d[i++];
          y = d[i++]; // Not draw too small seg between

          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
            ctx.lineTo(x, y);
            xi = x;
            yi = y;
          }

          break;

        case CMD.C:
          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.Q:
          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;

        case CMD.A:
          var cx = d[i++];
          var cy = d[i++];
          var rx = d[i++];
          var ry = d[i++];
          var theta = d[i++];
          var dTheta = d[i++];
          var psi = d[i++];
          var fs = d[i++];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var isEllipse = Math.abs(rx - ry) > 1e-3;
          var endAngle = theta + dTheta;

          if (isEllipse) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          } else {
            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
          }

          if (i === 1) {
            // 直接使用 arc 命令
            // 第一个命令起点还未定义
            x0 = mathCos(theta) * rx + cx;
            y0 = mathSin(theta) * ry + cy;
          }

          xi = mathCos(endAngle) * rx + cx;
          yi = mathSin(endAngle) * ry + cy;
          break;

        case CMD.R:
          x0 = xi = d[i];
          y0 = yi = d[i + 1];
          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
          break;

        case CMD.Z:
          ctx.closePath();
          xi = x0;
          yi = y0;
      }
    }
  }
};
PathProxy.CMD = CMD;
var _default = PathProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/arrayDiff2.js":
/*!********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/arrayDiff2.js ***!
  \********************************************************************/
/***/ ((module) => {

// Myers' Diff Algorithm
// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js
function Diff() {}

Diff.prototype = {
  diff: function (oldArr, newArr, equals) {
    if (!equals) {
      equals = function (a, b) {
        return a === b;
      };
    }

    this.equals = equals;
    var self = this;
    oldArr = oldArr.slice();
    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running

    var newLen = newArr.length;
    var oldLen = oldArr.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      var indices = [];

      for (var i = 0; i < newArr.length; i++) {
        indices.push(i);
      } // Identity per the equality and tokenizer


      return [{
        indices: indices,
        count: newArr.length
      }];
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath;
        var addPath = bestPath[diagonalPath - 1];
        var removePath = bestPath[diagonalPath + 1];
        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen;
        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return buildValues(self, basePath.components, newArr, oldArr);
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    }

    while (editLength <= maxEditLength) {
      var ret = execEditLength();

      if (ret) {
        return ret;
      }
    }
  },
  pushComponent: function (components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {
    var newLen = newArr.length;
    var oldLen = oldArr.length;
    var newPos = basePath.newPos;
    var oldPos = newPos - diagonalPath;
    var commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  tokenize: function (value) {
    return value.slice();
  },
  join: function (value) {
    return value.slice();
  }
};

function buildValues(diff, components, newArr, oldArr) {
  var componentPos = 0;
  var componentLen = components.length;
  var newPos = 0;
  var oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      var indices = [];

      for (var i = newPos; i < newPos + component.count; i++) {
        indices.push(i);
      }

      component.indices = indices;
      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      var indices = [];

      for (var i = oldPos; i < oldPos + component.count; i++) {
        indices.push(i);
      }

      component.indices = indices;
      oldPos += component.count;
    }
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var arrayDiff = new Diff();

function _default(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/bbox.js":
/*!**************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/bbox.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var vec2 = __webpack_require__(/*! ./vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var curve = __webpack_require__(/*! ./curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

/**
 * @author Yi Shen(https://github.com/pissang)
 */
var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = vec2.create();
var end = vec2.create();
var extremity = vec2.create();
/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */

function fromPoints(points, min, max) {
  if (points.length === 0) {
    return;
  }

  var p = points[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  var i;

  for (i = 1; i < points.length; i++) {
    p = points[i];
    left = mathMin(left, p[0]);
    right = mathMax(right, p[0]);
    top = mathMin(top, p[1]);
    bottom = mathMax(bottom, p[1]);
  }

  min[0] = left;
  min[1] = top;
  max[0] = right;
  max[1] = bottom;
}
/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromLine(x0, y0, x1, y1, min, max) {
  min[0] = mathMin(x0, x1);
  min[1] = mathMin(y0, y1);
  max[0] = mathMax(x0, x1);
  max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];
/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */

function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
  var cubicExtrema = curve.cubicExtrema;
  var cubicAt = curve.cubicAt;
  var i;
  var n = cubicExtrema(x0, x1, x2, x3, xDim);
  min[0] = Infinity;
  min[1] = Infinity;
  max[0] = -Infinity;
  max[1] = -Infinity;

  for (i = 0; i < n; i++) {
    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
    min[0] = mathMin(x, min[0]);
    max[0] = mathMax(x, max[0]);
  }

  n = cubicExtrema(y0, y1, y2, y3, yDim);

  for (i = 0; i < n; i++) {
    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
    min[1] = mathMin(y, min[1]);
    max[1] = mathMax(y, max[1]);
  }

  min[0] = mathMin(x0, min[0]);
  max[0] = mathMax(x0, max[0]);
  min[0] = mathMin(x3, min[0]);
  max[0] = mathMax(x3, max[0]);
  min[1] = mathMin(y0, min[1]);
  max[1] = mathMax(y0, max[1]);
  min[1] = mathMin(y3, min[1]);
  max[1] = mathMax(y3, max[1]);
}
/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
  var quadraticExtremum = curve.quadraticExtremum;
  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
  var x = quadraticAt(x0, x1, x2, tx);
  var y = quadraticAt(y0, y1, y2, ty);
  min[0] = mathMin(x0, x2, x);
  min[1] = mathMin(y0, y2, y);
  max[0] = mathMax(x0, x2, x);
  max[1] = mathMax(y0, y2, y);
}
/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */


function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
  var vec2Min = vec2.min;
  var vec2Max = vec2.max;
  var diff = Math.abs(startAngle - endAngle);

  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    // Is a circle
    min[0] = x - rx;
    min[1] = y - ry;
    max[0] = x + rx;
    max[1] = y + ry;
    return;
  }

  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min, start, end);
  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

  startAngle = startAngle % PI2;

  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }

  endAngle = endAngle % PI2;

  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }

  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }

  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  } // var number = 0;
  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min, extremity, min);
      vec2Max(max, extremity, max);
    }
  }
}

exports.fromPoints = fromPoints;
exports.fromLine = fromLine;
exports.fromCubic = fromCubic;
exports.fromQuadratic = fromQuadratic;
exports.fromArc = fromArc;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js":
/*!***************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _vector = __webpack_require__(/*! ./vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var v2Create = _vector.create;
var v2DistSquare = _vector.distSquare;

/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3; // 临时变量

var _v0 = v2Create();

var _v1 = v2Create();

var _v2 = v2Create();

function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */


function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function cubicRootAt(p0, p1, p2, p3, val, roots) {
  // Evaluate roots of cubic functions
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;

  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots[0] = 0;
    } else {
      var t1 = -c / b; //t1, t2, t3, b is not zero

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;

    if (isAroundZero(disc)) {
      var K = B / A;
      var t1 = -b / a + K; // t1, a is not zero

      var t2 = -K / 2; // t2, t3

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);

      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }

      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }

      var t1 = (-b - (Y1 + Y2)) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }

      if (t3 >= 0 && t3 <= 1) {
        roots[n++] = t3;
      }
    }
  }

  return n;
}
/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */


function cubicExtrema(p0, p1, p2, p3, extrema) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      extrema[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extrema[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        extrema[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function cubicSubdivide(p0, p1, p2, p3, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123; // Seg1

  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */


function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    prev = t - interval;
    next = t + interval; // t - interval

    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = cubicAt(x0, x1, x2, x3, t);
    out[1] = cubicAt(y0, y1, y2, y3, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}
/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */


function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */


function quadraticRootAt(p0, p1, p2, val, roots) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;

  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        roots[n++] = t1;
      }

      if (t2 >= 0 && t2 <= 1) {
        roots[n++] = t2;
      }
    }
  }

  return n;
}
/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */


function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;

  if (divider === 0) {
    // p1 is center of p0 and p2
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */


function quadraticSubdivide(p0, p1, p2, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p012 = (p12 - p01) * t + p01; // Seg0

  out[0] = p0;
  out[1] = p01;
  out[2] = p012; // Seg1

  out[3] = p012;
  out[4] = p12;
  out[5] = p2;
}
/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */


function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  // http://pomax.github.io/bezierinfo/#projections
  var t;
  var interval = 0.005;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
  // PENDING

  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    var d1 = v2DistSquare(_v0, _v1);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }

  d = Infinity; // At most 32 iteration

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }

    var prev = t - interval;
    var next = t + interval; // t - interval

    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    var d1 = v2DistSquare(_v1, _v0);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      // t + interval
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      var d2 = v2DistSquare(_v2, _v0);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  } // t


  if (out) {
    out[0] = quadraticAt(x0, x1, x2, t);
    out[1] = quadraticAt(y0, y1, y2, t);
  } // console.log(interval, i);


  return mathSqrt(d);
}

exports.cubicAt = cubicAt;
exports.cubicDerivativeAt = cubicDerivativeAt;
exports.cubicRootAt = cubicRootAt;
exports.cubicExtrema = cubicExtrema;
exports.cubicSubdivide = cubicSubdivide;
exports.cubicProjectPoint = cubicProjectPoint;
exports.quadraticAt = quadraticAt;
exports.quadraticDerivativeAt = quadraticDerivativeAt;
exports.quadraticRootAt = quadraticRootAt;
exports.quadraticExtremum = quadraticExtremum;
exports.quadraticSubdivide = quadraticSubdivide;
exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/dom.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/dom.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var env = __webpack_require__(/*! ./env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var _fourPointsTransform = __webpack_require__(/*! ./fourPointsTransform */ "./node_modules/_zrender@4.3.2@zrender/lib/core/fourPointsTransform.js");

var buildTransformer = _fourPointsTransform.buildTransformer;
var EVENT_SAVED_PROP = '___zrEVENTSAVED';
var _calcOut = [];
/**
 * Transform "local coord" from `elFrom` to `elTarget`.
 * "local coord": the coord based on the input `el`. The origin point is at
 *     the position of "left: 0; top: 0;" in the `el`.
 *
 * Support when CSS transform is used.
 *
 * Having the `out` (that is, `[outX, outY]`), we can create an DOM element
 * and set the CSS style as "left: outX; top: outY;" and append it to `elTarge`
 * to locate the element.
 *
 * For example, this code below positions a child of `document.body` on the event
 * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :
 * ```js
 * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);
 * if (!eqNaN(out[0])) {
 *     // Then locate the tip element on the event point.
 *     var tipEl = document.createElement('div');
 *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';
 *     document.body.appendChild(tipEl);
 * }
 * ```
 *
 * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.
 *
 * @param {Array.<number>} out [inX: number, inY: number] The output..
 *        If can not transform, `out` will not be modified but return `false`.
 * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.
 * @param {HTMLElement} elTarget The `out` is based on elTarget.
 * @param {number} inX
 * @param {number} inY
 * @return {boolean} Whether transform successfully.
 */

function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
}
/**
 * Transform between a "viewport coord" and a "local coord".
 * "viewport coord": the coord based on the left-top corner of the viewport
 *     of the browser.
 * "local coord": the coord based on the input `el`. The origin point is at
 *     the position of "left: 0; top: 0;" in the `el`.
 *
 * Support the case when CSS transform is used on el.
 *
 * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,
 *        it represents "local coord", otherwise "vireport coord".
 *        If can not transform, `out` will not be modified but return `false`.
 * @param {HTMLElement} el The "local coord" is based on the `el`, see comment above.
 * @param {number} inX If `inverse: false`,
 *        it represents "vireport coord", otherwise "local coord".
 * @param {number} inY If `inverse: false`,
 *        it represents "vireport coord", otherwise "local coord".
 * @param {boolean} [inverse=false]
 *        `true`: from "viewport coord" to "local coord".
 *        `false`: from "local coord" to "viewport coord".
 * @return {boolean} Whether transform successfully.
 */


function transformCoordWithViewport(out, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);

    if (transformer) {
      transformer(out, inX, inY);
      return true;
    }
  }

  return false;
}

function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;

  if (markers) {
    return markers;
  }

  markers = saved.markers = [];
  var propLR = ['left', 'right'];
  var propTB = ['top', 'bottom'];

  for (var i = 0; i < 4; i++) {
    var marker = document.createElement('div');
    var stl = marker.style;
    var idxLR = i % 2;
    var idxTB = (i >> 1) % 2;
    stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',
    // 'height: 5px',
    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');
    el.appendChild(marker);
    markers.push(marker);
  }

  return markers;
}

function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? 'invTrans' : 'trans';
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var oldCoordTheSame = true;
  var srcCoords = [];
  var destCoords = [];

  for (var i = 0; i < 4; i++) {
    var rect = markers[i].getBoundingClientRect();
    var ii = 2 * i;
    var x = rect.left;
    var y = rect.top;
    srcCoords.push(x, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  } // Cache to avoid time consuming of `buildTransformer`.


  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}

function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === 'CANVAS';
}

exports.transformLocalCoord = transformLocalCoord;
exports.transformCoordWithViewport = transformCoordWithViewport;
exports.isCanvasEl = isCanvasEl;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/env.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */

/* global wx */
var env = {};

if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
  // In Weixin Application
  env = {
    browser: {},
    os: {},
    node: false,
    wxa: true,
    // Weixin Application
    canvasSupported: true,
    svgSupported: false,
    touchEventsSupported: true,
    domSupported: false
  };
} else if (typeof document === 'undefined' && typeof self !== 'undefined') {
  // In worker
  env = {
    browser: {},
    os: {},
    node: false,
    worker: true,
    canvasSupported: true,
    domSupported: false
  };
} else if (typeof navigator === 'undefined') {
  // In node
  env = {
    browser: {},
    os: {},
    node: true,
    worker: false,
    // Assume canvas is supported
    canvasSupported: true,
    svgSupported: true,
    domSupported: false
  };
} else {
  env = detect(navigator.userAgent);
}

var _default = env; // Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.

function detect(ua) {
  var os = {};
  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
  // var touchpad = webos && ua.match(/TouchPad/);
  // var kindle = ua.match(/Kindle\/([\d.]+)/);
  // var silk = ua.match(/Silk\/([\d._]+)/);
  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
  // var playbook = ua.match(/PlayBook/);
  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
  // - discern (more) between multiple browsers on android
  // - decide if kindle fire in silk mode is android or not
  // - Firefox on Android doesn't specify the Android version
  // - possibly devide in os, device and browser hashes
  // if (browser.webkit = !!webkit) browser.version = webkit[1];
  // if (android) os.android = true, os.version = android[2];
  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  // if (webos) os.webos = true, os.version = webos[2];
  // if (touchpad) os.touchpad = true;
  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
  // if (bb10) os.bb10 = true, os.version = bb10[2];
  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
  // if (playbook) browser.playbook = true;
  // if (kindle) os.kindle = true, os.version = kindle[1];
  // if (silk) browser.silk = true, browser.version = silk[1];
  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
  // if (chrome) browser.chrome = true, browser.version = chrome[1];

  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
  // if (webview) browser.webview = true;


  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }

  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
  // not be set on win phone. So we do not consider Win Phone.


  if (weChat) {
    browser.weChat = true;
  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


  return {
    browser: browser,
    os: os,
    node: false,
    // 原生canvas支持，改极端点了
    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
    canvasSupported: !!document.createElement('canvas').getContext,
    svgSupported: typeof SVGRect !== 'undefined',
    // works on most browsers
    // IE10/11 does not support touch event, and MS Edge supports them but not by
    // default, so we dont check navigator.maxTouchPoints for them here.
    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
    // <http://caniuse.com/#search=pointer%20event>.
    pointerEventsSupported: // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer
    // events currently. So we dont use that on other browsers unless tested sufficiently.
    // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page
    // scroll, the `pointermove` event can not be fired any more. That will break some
    // features like "pan horizontally to move something and pan vertically to page scroll".
    // The horizontal pan probably be interrupted by the casually triggered page scroll.
    // (2) Although IE 10 supports pointer event, it use old style and is different from the
    // standard. So we exclude that. (IE 10 is hardly used on touch device)
    'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 11),
    // passiveSupported: detectPassiveSupport()
    domSupported: typeof document !== 'undefined'
  };
} // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
// function detectPassiveSupport() {
//     // Test via a getter in the options object to see if the passive property is accessed
//     var supportsPassive = false;
//     try {
//         var opts = Object.defineProperty({}, 'passive', {
//             get: function() {
//                 supportsPassive = true;
//             }
//         });
//         window.addEventListener('testPassive', function() {}, opts);
//     } catch (e) {
//     }
//     return supportsPassive;
// }


module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/event.js":
/*!***************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/event.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Eventful = __webpack_require__(/*! ../mixin/Eventful */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js");

exports.Dispatcher = Eventful;

var env = __webpack_require__(/*! ./env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var _dom = __webpack_require__(/*! ./dom */ "./node_modules/_zrender@4.3.2@zrender/lib/core/dom.js");

var isCanvasEl = _dom.isCanvasEl;
var transformCoordWithViewport = _dom.transformCoordWithViewport;

/**
 * Utilities for mouse or touch events.
 */
var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
/**
 * Get the `zrX` and `zrY`, which are relative to the top-left of
 * the input `el`.
 * CSS transform (2D & 3D) is supported.
 *
 * The strategy to fetch the coords:
 * + If `calculate` is not set as `true`, users of this method should
 * ensure that `el` is the same or the same size & location as `e.target`.
 * Otherwise the result coords are probably not expected. Because we
 * firstly try to get coords from e.offsetX/e.offsetY.
 * + If `calculate` is set as `true`, the input `el` can be any element
 * and we force to calculate the coords based on `el`.
 * + The input `el` should be positionable (not position:static).
 *
 * The force `calculate` can be used in case like:
 * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).
 *
 * @param {HTMLElement} el DOM element.
 * @param {Event} e Mouse event or touch event.
 * @param {Object} out Get `out.zrX` and `out.zrY` as the result.
 * @param {boolean} [calculate=false] Whether to force calculate
 *        the coordinates but not use ones provided by browser.
 */

function clientToLocal(el, e, out, calculate) {
  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
  // to the padding edge of the target element. The only browser using this convention
  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
  // not support the properties.
  // (see http://www.jacklmoore.com/notes/mouse-position/)
  // In zr painter.dom, padding edge equals to border edge.

  if (calculate || !env.canvasSupported) {
    calculateZrXY(el, e, out);
  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
  // zoom-factor, overflow / opacity layers, transforms ...)
  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
  // <https://bugs.jquery.com/ticket/8523#comment:14>
  // BTW3, In ff, offsetX/offsetY is always 0.
  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
      out.zrX = e.layerX;
      out.zrY = e.layerY;
    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } // For some other device, e.g., IOS safari.
      else {
          calculateZrXY(el, e, out);
        }

  return out;
}

function calculateZrXY(el, e, out) {
  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.
  if (env.domSupported && el.getBoundingClientRect) {
    var ex = e.clientX;
    var ey = e.clientY;

    if (isCanvasEl(el)) {
      // Original approach, which do not support CSS transform.
      // marker can not be locationed in a canvas container
      // (getBoundingClientRect is always 0). We do not support
      // that input a pre-created canvas to zr while using css
      // transform in iOS.
      var box = el.getBoundingClientRect();
      out.zrX = ex - box.left;
      out.zrY = ey - box.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
        out.zrX = _calcOut[0];
        out.zrY = _calcOut[1];
        return;
      }
    }
  }

  out.zrX = out.zrY = 0;
}
/**
 * Find native event compat for legency IE.
 * Should be called at the begining of a native event listener.
 *
 * @param {Event} [e] Mouse event or touch event or pointer event.
 *        For lagency IE, we use `window.event` is used.
 * @return {Event} The native event.
 */


function getNativeEvent(e) {
  return e || window.event;
}
/**
 * Normalize the coordinates of the input event.
 *
 * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of
 * the input `el`.
 * Get `e.zrDelta` if using mouse wheel.
 * Get `e.which`, see the comment inside this function.
 *
 * Do not calculate repeatly if `zrX` and `zrY` already exist.
 *
 * Notice: see comments in `clientToLocal`. check the relationship
 * between the result coords and the parameters `el` and `calculate`.
 *
 * @param {HTMLElement} el DOM element.
 * @param {Event} [e] See `getNativeEvent`.
 * @param {boolean} [calculate=false] Whether to force calculate
 *        the coordinates but not use ones provided by browser.
 * @return {UIEvent} The normalized native UIEvent.
 */


function normalizeEvent(el, e, calculate) {
  e = getNativeEvent(e);

  if (e.zrX != null) {
    return e;
  }

  var eventType = e.type;
  var isTouch = eventType && eventType.indexOf('touch') >= 0;

  if (!isTouch) {
    clientToLocal(el, e, e, calculate);
    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
  } else {
    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
    touch && clientToLocal(el, touch, e, calculate);
  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
  // If e.which has been defined, it may be readonly,
  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


  var button = e.button;

  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  } // [Caution]: `e.which` from browser is not always reliable. For example,
  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`
  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and
  // `mousedown (pointerdown)` is the same as Chrome does.


  return e;
}
/**
 * @param {HTMLElement} el
 * @param {string} name
 * @param {Function} handler
 * @param {Object|boolean} opt If boolean, means `opt.capture`
 * @param {boolean} [opt.capture=false]
 * @param {boolean} [opt.passive=false]
 */


function addEventListener(el, name, handler, opt) {
  if (isDomLevel2) {
    // Reproduct the console warning:
    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.
    // Consider marking event handler as 'passive' to make the page more responsive.
    // Just set console log level: verbose in chrome dev tool.
    // then the warning log will be printed when addEventListener called.
    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // We have not yet found a neat way to using passive. Because in zrender the dom event
    // listener delegate all of the upper events of element. Some of those events need
    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.
    // Before passive can be adopted, these issues should be considered:
    // (1) Whether and how a zrender user specifies an event listener passive. And by default,
    // passive or not.
    // (2) How to tread that some zrender event listener is passive, and some is not. If
    // we use other way but not preventDefault of mousewheel and touchmove, browser
    // compatibility should be handled.
    // var opts = (env.passiveSupported && name === 'mousewheel')
    //     ? {passive: true}
    //     // By default, the third param of el.addEventListener is `capture: false`.
    //     : void 0;
    // el.addEventListener(name, handler /* , opts */);
    el.addEventListener(name, handler, opt);
  } else {
    // For simplicity, do not implement `setCapture` for IE9-.
    el.attachEvent('on' + name, handler);
  }
}
/**
 * Parameter are the same as `addEventListener`.
 *
 * Notice that if a listener is registered twice, one with capture and one without,
 * remove each one separately. Removal of a capturing listener does not affect a
 * non-capturing version of the same listener, and vice versa.
 */


function removeEventListener(el, name, handler, opt) {
  if (isDomLevel2) {
    el.removeEventListener(name, handler, opt);
  } else {
    el.detachEvent('on' + name, handler);
  }
}
/**
 * preventDefault and stopPropagation.
 * Notice: do not use this method in zrender. It can only be
 * used by upper applications if necessary.
 *
 * @param {Event} e A mouse or touch event.
 */


var stop = isDomLevel2 ? function (e) {
  e.preventDefault();
  e.stopPropagation();
  e.cancelBubble = true;
} : function (e) {
  e.returnValue = false;
  e.cancelBubble = true;
};
/**
 * This method only works for mouseup and mousedown. The functionality is restricted
 * for fault tolerance, See the `e.which` compatibility above.
 *
 * @param {MouseEvent} e
 * @return {boolean}
 */

function isMiddleOrRightButtonOnMouseUpDown(e) {
  return e.which === 2 || e.which === 3;
}
/**
 * To be removed.
 * @deprecated
 */


function notLeftMouse(e) {
  // If e.which is undefined, considered as left mouse event.
  return e.which > 1;
} // For backward compatibility


exports.clientToLocal = clientToLocal;
exports.getNativeEvent = getNativeEvent;
exports.normalizeEvent = normalizeEvent;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.stop = stop;
exports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;
exports.notLeftMouse = notLeftMouse;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/fourPointsTransform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/fourPointsTransform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * The algoritm is learnt from
 * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
 * And we made some optimization for matrix inversion.
 * Other similar approaches:
 * "cv::getPerspectiveTransform", "Direct Linear Transformation".
 */
var LN2 = Math.log(2);

function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + '-' + colMask;
  var fullRank = rows.length;

  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }

  if (rank === 1) {
    // In this case the colMask must be like: `11101111`. We can find the place of `0`.
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }

  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;

  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }

  var sum = 0;

  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
    var colTag = 1 << j;

    if (!(colTag & colMask)) {
      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] // det(subMatrix(0, j))
      * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }

  detCache[cacheKey] = sum;
  return sum;
}
/**
 * Usage:
 * ```js
 * var transformer = buildTransformer(
 *     [10, 44, 100, 44, 100, 300, 10, 300],
 *     [50, 54, 130, 14, 140, 330, 14, 220]
 * );
 * var out = [];
 * transformer && transformer([11, 33], out);
 * ```
 *
 * Notice: `buildTransformer` may take more than 10ms in some Android device.
 *
 * @param {Array.<number>} src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @param {Array.<number>} dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
 * @return {Function} transformer If fail, return null/undefined.
 */


function buildTransformer(src, dest) {
  var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);

  if (det === 0) {
    // can not make transformer when and only when
    // any three of the markers are collinear.
    return;
  } // `invert(mA) * dest`, that is, `adj(mA) / det * dest`.


  var vh = [];

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))
      determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }

  return function (out, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}

exports.buildTransformer = buildTransformer;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/guid.js":
/*!**************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/guid.js ***!
  \**************************************************************/
/***/ ((module) => {

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */
var idStart = 0x0907;

function _default() {
  return idStart++;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/log.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _config = __webpack_require__(/*! ../config */ "./node_modules/_zrender@4.3.2@zrender/lib/config.js");

var debugMode = _config.debugMode;

var logError = function () {};

if (debugMode === 1) {
  logError = console.error;
}

var _default = logError;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */

/* global Float32Array */
var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * Create a identity matrix.
 * @return {Float32Array|Array.<number>}
 */

function create() {
  var out = new ArrayCtor(6);
  identity(out);
  return out;
}
/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */


function copy(out, m) {
  out[0] = m[0];
  out[1] = m[1];
  out[2] = m[2];
  out[3] = m[3];
  out[4] = m[4];
  out[5] = m[5];
  return out;
}
/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */


function mul(out, m1, m2) {
  // Consider matrix.mul(m, m2, m);
  // where out is the same as m2.
  // So use temp variable to escape error.
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = out3;
  out[4] = out4;
  out[5] = out5;
  return out;
}
/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function translate(out, a, v) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4] + v[0];
  out[5] = a[5] + v[1];
  return out;
}
/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */


function rotate(out, a, rad) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * atx + st * aty;
  out[5] = ct * aty - st * atx;
  return out;
}
/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */


function scale(out, a, v) {
  var vx = v[0];
  var vy = v[1];
  out[0] = a[0] * vx;
  out[1] = a[1] * vy;
  out[2] = a[2] * vx;
  out[3] = a[3] * vy;
  out[4] = a[4] * vx;
  out[5] = a[5] * vy;
  return out;
}
/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */


function invert(out, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Clone a new matrix.
 * @param {Float32Array|Array.<number>} a
 */


function clone(a) {
  var b = create();
  copy(b, a);
  return b;
}

exports.create = create;
exports.identity = identity;
exports.copy = copy;
exports.mul = mul;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.invert = invert;
exports.clone = clone;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/timsort.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/timsort.js ***!
  \*****************************************************************/
/***/ ((module) => {

// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
  var r = 0;

  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }

  return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;

  if (runHi === hi) {
    return 1;
  }

  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }

    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }

  return runHi - lo;
}

function reverseRun(array, lo, hi) {
  hi--;

  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }

  for (; start < hi; start++) {
    var pivot = array[start];
    var left = lo;
    var right = start;
    var mid;

    while (left < right) {
      mid = left + right >>> 1;

      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var n = start - left;

    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];

      case 2:
        array[left + 2] = array[left + 1];

      case 1:
        array[left + 1] = array[left];
        break;

      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }

    }

    array[left] = pivot;
  }
}

function gallopLeft(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }

  return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    lastOffset += hint;
    offset += hint;
  }

  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + (offset - lastOffset >>> 1);

    if (compare(value, array[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

function TimSort(array, compare) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var length = 0;
  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
  var stackLength = 0;
  var runStart;
  var runLength;
  var stackSize = 0;
  length = array.length;

  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
    tmpStorageLength = length >>> 1;
  }

  var tmp = [];
  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
  runStart = [];
  runLength = [];

  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }

  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }

      mergeAt(n);
    }
  }

  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;

      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }

      mergeAt(n);
    }
  }

  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;

    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }

    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
    start1 += k;
    length1 -= k;

    if (length1 === 0) {
      return;
    }

    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

    if (length2 === 0) {
      return;
    }

    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }

  function mergeLow(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }

    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];

    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }

      return;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
      return;
    }

    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;

    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;

          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;

          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          dest += count1;
          cursor1 += count1;
          length1 -= count1;

          if (length1 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          exit = true;
          break;
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          dest += count2;
          cursor2 += count2;
          length2 -= count2;

          if (length2 === 0) {
            exit = true;
            break;
          }
        }

        array[dest++] = tmp[cursor1++];

        if (--length1 === 1) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }

      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }

  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;

    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }

    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];

    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }

      return;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
      return;
    }

    var _minGallop = minGallop;

    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;

          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;

          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          if (length1 === 0) {
            exit = true;
            break;
          }
        }

        array[dest--] = tmp[cursor2--];

        if (--length2 === 1) {
          exit = true;
          break;
        }

        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;

          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }

          if (length2 <= 1) {
            exit = true;
            break;
          }
        }

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          exit = true;
          break;
        }

        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

      if (exit) {
        break;
      }

      if (_minGallop < 0) {
        _minGallop = 0;
      }

      _minGallop += 2;
    }

    minGallop = _minGallop;

    if (minGallop < 1) {
      minGallop = 1;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }

      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
    } else {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }

  this.mergeRuns = mergeRuns;
  this.forceMergeRuns = forceMergeRuns;
  this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
  if (!lo) {
    lo = 0;
  }

  if (!hi) {
    hi = array.length;
  }

  var remaining = hi - lo;

  if (remaining < 2) {
    return;
  }

  var runLength = 0;

  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }

  var ts = new TimSort(array, compare);
  var minRun = minRunLength(remaining);

  do {
    runLength = makeAscendingRun(array, lo, hi, compare);

    if (runLength < minRun) {
      var force = remaining;

      if (force > minRun) {
        force = minRun;
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }

    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);

  ts.forceMergeRuns();
}

module.exports = sort;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js":
/*!**************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/util.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * @module zrender/core/util
 */
// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT = {
  '[object Function]': 1,
  '[object RegExp]': 1,
  '[object Date]': 1,
  '[object Error]': 1,
  '[object CanvasGradient]': 1,
  '[object CanvasPattern]': 1,
  // For node-canvas
  '[object Image]': 1,
  '[object Canvas]': 1
};
var TYPED_ARRAY = {
  '[object Int8Array]': 1,
  '[object Uint8Array]': 1,
  '[object Uint8ClampedArray]': 1,
  '[object Int16Array]': 1,
  '[object Uint16Array]': 1,
  '[object Int32Array]': 1,
  '[object Uint32Array]': 1,
  '[object Float32Array]': 1,
  '[object Float64Array]': 1
};
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

var methods = {};

function $override(name, fn) {
  // Clear ctx instance for different environment
  if (name === 'createCanvas') {
    _ctx = null;
  }

  methods[name] = fn;
}
/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */


function clone(source) {
  if (source == null || typeof source !== 'object') {
    return source;
  }

  var result = source;
  var typeStr = objToString.call(source);

  if (typeStr === '[object Array]') {
    if (!isPrimitive(source)) {
      result = [];

      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;

      if (source.constructor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);

        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = clone(source[i]);
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};

    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = clone(source[key]);
      }
    }
  }

  return result;
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */


function merge(target, source, overwrite) {
  // We should escapse that source is string
  // and enter for ... in ...
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }

  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var targetProp = target[key];
      var sourceProp = source[key];

      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        // 如果需要递归覆盖，就递归调用merge
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
        // NOTE，在 target[key] 不存在的时候也是直接覆盖
        target[key] = clone(source[key], true);
      }
    }
  }

  return target;
}
/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */


function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];

  for (var i = 1, len = targetAndSources.length; i < len; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }

  return result;
}
/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */


function extend(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }

  return target;
}
/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */


function defaults(target, source, overlay) {
  for (var key in source) {
    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
      target[key] = source[key];
    }
  }

  return target;
}

var createCanvas = function () {
  return methods.createCanvas();
};

methods.createCanvas = function () {
  return document.createElement('canvas');
}; // FIXME


var _ctx;

function getContext() {
  if (!_ctx) {
    // Use util.createCanvas instead of createCanvas
    // because createCanvas may be overwritten in different environment
    _ctx = createCanvas().getContext('2d');
  }

  return _ctx;
}
/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */


function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }

    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */


function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;

  function F() {}

  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();

  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }

  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */


function mixin(target, source, overlay) {
  target = 'prototype' in target ? target.prototype : target;
  source = 'prototype' in source ? source.prototype : source;
  defaults(target, source, overlay);
}
/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */


function isArrayLike(data) {
  if (!data) {
    return;
  }

  if (typeof data === 'string') {
    return false;
  }

  return typeof data.length === 'number';
}
/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */


function each(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.forEach && obj.forEach === nativeForEach) {
    obj.forEach(cb, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, len = obj.length; i < len; i++) {
      cb.call(context, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        cb.call(context, obj[key], key, obj);
      }
    }
  }
}
/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function map(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.map && obj.map === nativeMap) {
    return obj.map(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      result.push(cb.call(context, obj[i], i, obj));
    }

    return result;
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */


function reduce(obj, cb, memo, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.reduce && obj.reduce === nativeReduce) {
    return obj.reduce(cb, memo, context);
  } else {
    for (var i = 0, len = obj.length; i < len; i++) {
      memo = cb.call(context, memo, obj[i], i, obj);
    }

    return memo;
  }
}
/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */


function filter(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  if (obj.filter && obj.filter === nativeFilter) {
    return obj.filter(cb, context);
  } else {
    var result = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        result.push(obj[i]);
      }
    }

    return result;
  }
}
/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */


function find(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }

  for (var i = 0, len = obj.length; i < len; i++) {
    if (cb.call(context, obj[i], i, obj)) {
      return obj[i];
    }
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */


function bind(func, context) {
  var args = nativeSlice.call(arguments, 2);
  return function () {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */


function curry(func) {
  var args = nativeSlice.call(arguments, 1);
  return function () {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isArray(value) {
  return objToString.call(value) === '[object Array]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isFunction(value) {
  return typeof value === 'function';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isString(value) {
  return objToString.call(value) === '[object String]';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type === 'function' || !!value && type === 'object';
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */


function isDom(value) {
  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
}
/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */


function eqNaN(value) {
  /* eslint-disable-next-line no-self-compare */
  return value !== value;
}
/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */


function retrieve(values) {
  for (var i = 0, len = arguments.length; i < len; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }
}

function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}

function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */


function slice() {
  return Function.call.apply(nativeSlice, arguments);
}
/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */


function normalizeCssArray(val) {
  if (typeof val === 'number') {
    return [val, val, val, val];
  }

  var len = val.length;

  if (len === 2) {
    // vertical | horizontal
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    // top | horizontal | bottom
    return [val[0], val[1], val[2], val[1]];
  }

  return val;
}
/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */


function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
/**
 * @memberOf module:zrender/core/util
 * @param {string} str string to be trimed
 * @return {string} trimed string
 */


function trim(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === 'function') {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  }
}

var primitiveKey = '__ec_primitive__';
/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */

function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}

function isPrimitive(obj) {
  return obj[primitiveKey];
}
/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */


function HashMap(obj) {
  var isArr = isArray(obj); // Key should not be set on this, otherwise
  // methods get/set/... may be overrided.

  this.data = {};
  var thisMap = this;
  obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);

  function visit(value, key) {
    isArr ? thisMap.set(value, key) : thisMap.set(key, value);
  }
}

HashMap.prototype = {
  constructor: HashMap,
  // Do not provide `has` method to avoid defining what is `has`.
  // (We usually treat `null` and `undefined` as the same, different
  // from ES6 Map).
  get: function (key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  },
  set: function (key, value) {
    // Comparing with invocation chaining, `return value` is more commonly
    // used in this case: `var someVal = map.set('a', genVal());`
    return this.data[key] = value;
  },
  // Although util.each can be performed on this hashMap directly, user
  // should not use the exposed keys, who are prefixed.
  each: function (cb, context) {
    context !== void 0 && (cb = bind(cb, context));
    /* eslint-disable guard-for-in */

    for (var key in this.data) {
      this.data.hasOwnProperty(key) && cb(this.data[key], key);
    }
    /* eslint-enable guard-for-in */

  },
  // Do not use this method if performance sensitive.
  removeKey: function (key) {
    delete this.data[key];
  }
};

function createHashMap(obj) {
  return new HashMap(obj);
}

function concatArray(a, b) {
  var newArray = new a.constructor(a.length + b.length);

  for (var i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }

  var offset = a.length;

  for (i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }

  return newArray;
}

function noop() {}

exports.$override = $override;
exports.clone = clone;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.extend = extend;
exports.defaults = defaults;
exports.createCanvas = createCanvas;
exports.getContext = getContext;
exports.indexOf = indexOf;
exports.inherits = inherits;
exports.mixin = mixin;
exports.isArrayLike = isArrayLike;
exports.each = each;
exports.map = map;
exports.reduce = reduce;
exports.filter = filter;
exports.find = find;
exports.bind = bind;
exports.curry = curry;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isString = isString;
exports.isObject = isObject;
exports.isBuiltInObject = isBuiltInObject;
exports.isTypedArray = isTypedArray;
exports.isDom = isDom;
exports.eqNaN = eqNaN;
exports.retrieve = retrieve;
exports.retrieve2 = retrieve2;
exports.retrieve3 = retrieve3;
exports.slice = slice;
exports.normalizeCssArray = normalizeCssArray;
exports.assert = assert;
exports.trim = trim;
exports.setAsPrimitive = setAsPrimitive;
exports.isPrimitive = isPrimitive;
exports.createHashMap = createHashMap;
exports.concatArray = concatArray;
exports.noop = noop;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* global Float32Array */
var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */

function create(x, y) {
  var out = new ArrayCtor(2);

  if (x == null) {
    x = 0;
  }

  if (y == null) {
    y = 0;
  }

  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */


function copy(out, v) {
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */


function clone(v) {
  var out = new ArrayCtor(2);
  out[0] = v[0];
  out[1] = v[1];
  return out;
}
/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */


function set(out, a, b) {
  out[0] = a;
  out[1] = b;
  return out;
}
/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function add(out, v1, v2) {
  out[0] = v1[0] + v2[0];
  out[1] = v1[1] + v2[1];
  return out;
}
/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */


function scaleAndAdd(out, v1, v2, a) {
  out[0] = v1[0] + v2[0] * a;
  out[1] = v1[1] + v2[1] * a;
  return out;
}
/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0];
  out[1] = v1[1] - v2[1];
  return out;
}
/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */


function len(v) {
  return Math.sqrt(lenSquare(v));
}

var length = len; // jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */

function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}

var lengthSquare = lenSquare;
/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */

function mul(out, v1, v2) {
  out[0] = v1[0] * v2[0];
  out[1] = v1[1] * v2[1];
  return out;
}
/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */


function div(out, v1, v2) {
  out[0] = v1[0] / v2[0];
  out[1] = v1[1] / v2[1];
  return out;
}
/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */


function scale(out, v, s) {
  out[0] = v[0] * s;
  out[1] = v[1] * s;
  return out;
}
/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */


function normalize(out, v) {
  var d = len(v);

  if (d === 0) {
    out[0] = 0;
    out[1] = 0;
  } else {
    out[0] = v[0] / d;
    out[1] = v[1] / d;
  }

  return out;
}
/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */


function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}

var dist = distance;
/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */

function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}

var distSquare = distanceSquare;
/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */

function negate(out, v) {
  out[0] = -v[0];
  out[1] = -v[1];
  return out;
}
/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */


function lerp(out, v1, v2, t) {
  out[0] = v1[0] + t * (v2[0] - v1[0]);
  out[1] = v1[1] + t * (v2[1] - v1[1]);
  return out;
}
/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */


function applyTransform(out, v, m) {
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function min(out, v1, v2) {
  out[0] = Math.min(v1[0], v2[0]);
  out[1] = Math.min(v1[1], v2[1]);
  return out;
}
/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */


function max(out, v1, v2) {
  out[0] = Math.max(v1[0], v2[0]);
  out[1] = Math.max(v1[1], v2[1]);
  return out;
}

exports.create = create;
exports.copy = copy;
exports.clone = clone;
exports.set = set;
exports.add = add;
exports.scaleAndAdd = scaleAndAdd;
exports.sub = sub;
exports.len = len;
exports.length = length;
exports.lenSquare = lenSquare;
exports.lengthSquare = lengthSquare;
exports.mul = mul;
exports.div = div;
exports.dot = dot;
exports.scale = scale;
exports.normalize = normalize;
exports.distance = distance;
exports.dist = dist;
exports.distanceSquare = distanceSquare;
exports.distSquare = distSquare;
exports.negate = negate;
exports.lerp = lerp;
exports.applyTransform = applyTransform;
exports.min = min;
exports.max = max;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/dom/HandlerProxy.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/dom/HandlerProxy.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _event = __webpack_require__(/*! ../core/event */ "./node_modules/_zrender@4.3.2@zrender/lib/core/event.js");

var addEventListener = _event.addEventListener;
var removeEventListener = _event.removeEventListener;
var normalizeEvent = _event.normalizeEvent;
var getNativeEvent = _event.getNativeEvent;

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Eventful = __webpack_require__(/*! ../mixin/Eventful */ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js");

var env = __webpack_require__(/*! ../core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

/* global document */
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env.domSupported;

var localNativeListenerNames = function () {
  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
    var nm = name.replace('mouse', 'pointer');
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();

var globalNativeListenerNames = {
  mouse: ['mousemove', 'mouseup'],
  pointer: ['pointermove', 'pointerup']
};

function eventNameFix(name) {
  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
}

function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === 'pen' || pointerType === 'touch';
} // function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }
// function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 *
 * @param {DOMHandlerScope} scope
 */


function setTouchTimer(scope) {
  scope.touching = true;

  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }

  scope.touchTimer = setTimeout(function () {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
} // Mark touch, which is useful in distinguish touch and
// mouse event in upper applicatoin.


function markTouch(event) {
  event && (event.zrByTouch = true);
} // function markTriggeredFromLocal(event) {
//     event && (event.__zrIsFromLocal = true);
// }
// function isTriggeredFromLocal(instance, event) {
//     return !!(event && event.__zrIsFromLocal);
// }


function normalizeGlobalEvent(instance, event) {
  // offsetX, offsetY still need to be calculated. They are necessary in the event
  // handlers of the upper applications. Set `true` to force calculate them.
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
/**
 * Detect whether the given el is in `painterRoot`.
 */


function isLocalEl(instance, el) {
  var elTmp = el;
  var isLocal = false;

  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }

  return isLocal;
}
/**
 * Make a fake event but not change the original event,
 * becuase the global event probably be used by other
 * listeners not belonging to zrender.
 * @class
 */


function FakeGlobalEvent(instance, event) {
  this.type = event.type;
  this.target = this.currentTarget = instance.dom;
  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY

  this.clientX = event.clientX;
  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,
  // we do not copy `targetTouches` and `changedTouches` here.
}

var fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,
// otherwise it is dangerous. See more details in
// [Drag outside] in `Handler.js`.

fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;
/**
 * Local DOM Handlers
 * @this {HandlerProxy}
 */

var localDOMHandlers = {
  mousedown: function (event) {
    event = normalizeEvent(this.dom, event);
    this._mayPointerCapture = [event.zrX, event.zrY];
    this.trigger('mousedown', event);
  },
  mousemove: function (event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this._mayPointerCapture;

    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      togglePointerCapture(this, true);
    }

    this.trigger('mousemove', event);
  },
  mouseup: function (event) {
    event = normalizeEvent(this.dom, event);
    togglePointerCapture(this, false);
    this.trigger('mouseup', event);
  },
  mouseout: function (event) {
    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,
    // `globalout` will be delayed to final pointer cature release.

    if (this._pointerCapturing) {
      event.zrEventControl = 'no_globalout';
    } // There might be some doms created by upper layer application
    // at the same level of painter.getViewportRoot() (e.g., tooltip
    // dom created by echarts), where 'globalout' event should not
    // be triggered when mouse enters these doms. (But 'mouseout'
    // should be triggered at the original hovered element as usual).


    var element = event.toElement || event.relatedTarget;
    event.zrIsToLocalDOM = isLocalEl(this, element);
    this.trigger('mouseout', event);
  },
  touchstart: function (event) {
    // Default mouse behaviour should not be disabled here.
    // For example, page may needs to be slided.
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this._lastTouchMoment = new Date();
    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,
    // we simulate "mouseover-->mousedown" in touch device. So we trigger
    // `mousemove` here (to trigger `mouseover` inside), and then trigger
    // `mousedown`.

    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function (event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether
    // there is gestrue event, because mouse move and pinch may
    // be used at the same time.

    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function (event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, 'end');
    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
    // we can conveniently implement "hover style" in both PC and touch device just
    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
    // to remove "hover style" on an element, without any additional code for
    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
    // style" will remain for user view)
    // click event should always be triggered no matter whether
    // there is gestrue event. System click can not be prevented.

    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function (event) {
    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
    //     this._msGesture.addPointer(event.pointerId);
    // }
  },
  pointermove: function (event) {
    // FIXME
    // pointermove is so sensitive that it always triggered when
    // tap(click) on touch screen, which affect some judgement in
    // upper application. So, we dont support mousemove on MS touch
    // device yet.
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function (event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function (event) {
    // pointerout will be triggered when tap on touch screen
    // (IE11+/Edge on MS Surface) after click event triggered,
    // which is inconsistent with the mousout behavior we defined
    // in touchend. So we unify them.
    // (check localDOMHandlers.touchend for detailed explanation)
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
/**
 * Othere DOM UI Event handlers for zr dom.
 * @this {HandlerProxy}
 */

zrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
  localDOMHandlers[name] = function (event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
/**
 * DOM UI Event handlers for global page.
 *
 * [Caution]:
 * those handlers should both support in capture phase and bubble phase!
 *
 * @this {HandlerProxy}
 */

var globalDOMHandlers = {
  pointermove: function (event) {
    // FIXME
    // pointermove is so sensitive that it always triggered when
    // tap(click) on touch screen, which affect some judgement in
    // upper application. So, we dont support mousemove on MS touch
    // device yet.
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function (event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function (event) {
    this.trigger('mousemove', event);
  },
  mouseup: function (event) {
    var pointerCaptureReleasing = this._pointerCapturing;
    togglePointerCapture(this, false);
    this.trigger('mouseup', event);

    if (pointerCaptureReleasing) {
      event.zrEventControl = 'only_globalout';
      this.trigger('mouseout', event);
    }
  }
};
/**
 * @param {HandlerProxy} instance
 * @param {DOMHandlerScope} scope
 */

function mountLocalDOMEventListeners(instance, scope) {
  var domHandlers = scope.domHandlers;

  if (env.pointerEventsSupported) {
    // Only IE11+/Edge
    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
    // at the same time.
    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
    // screen, which do not occurs in pointer event.
    // So we use pointer event to both detect touch gesture and mouse behavior.
    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function (event) {
        // markTriggeredFromLocal(event);
        domHandlers[nativeEventName].call(instance, event);
      });
    }); // FIXME
    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
    // which does not prevent defuault behavior occasionally (which may cause view port
    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
    // touch screen. And we only support click behavior on MS touch screen now.
    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
    // We dont support touch on IE on win7.
    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
    // if (typeof MSGesture === 'function') {
    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
    // }
  } else {
    if (env.touchEventsSupported) {
      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function (event) {
          // markTriggeredFromLocal(event);
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
      // addEventListener(root, 'mouseout', this._mouseoutHandler);
    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
    // mouse event can not be handle in those devices.
    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
    // mouseevent after touch event triggered, see `setTouchTimer`.


    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function (event) {
        event = getNativeEvent(event);

        if (!scope.touching) {
          // markTriggeredFromLocal(event);
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
/**
 * @param {HandlerProxy} instance
 * @param {DOMHandlerScope} scope
 */


function mountGlobalDOMEventListeners(instance, scope) {
  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.
  if (env.pointerEventsSupported) {
    zrUtil.each(globalNativeListenerNames.pointer, mount);
  } // Touch event has implemented "drag outside" so we do not mount global listener for touch event.
  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)
  // We do not consider "both-support-touch-and-mouse device" for this feature (see the comment of
  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.
  else if (!env.touchEventsSupported) {
      zrUtil.each(globalNativeListenerNames.mouse, mount);
    }

  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`
      // This checking supports both `useCapture` or not.
      // PENDING: if there is performance issue in some devices,
      // we probably can not use `useCapture` and change a easier
      // to judes whether local (mark).

      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }

    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {
      capture: true
    } // See [Drag Outside] in `Handler.js`
    );
  }
}

function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
}

function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;

  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }

  scope.mounted = {};
}
/**
 * See [Drag Outside] in `Handler.js`.
 * @implement
 * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.
 *        `true`: start to capture pointer if it is not capturing.
 *        `false`: end the capture if it is capturing.
 */


function togglePointerCapture(instance, isPointerCapturing) {
  instance._mayPointerCapture = null;

  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
    instance._pointerCapturing = isPointerCapturing;
    var globalHandlerScope = instance._globalHandlerScope;
    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
  }
}
/**
 * @inner
 * @class
 */


function DOMHandlerScope(domTarget, domHandlers) {
  this.domTarget = domTarget;
  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.
  // Used for unmount.

  this.mounted = {};
  this.listenerOpts = {};
  this.touchTimer = null;
  this.touching = false;
}
/**
 * @public
 * @class
 */


function HandlerDomProxy(dom, painterRoot) {
  Eventful.call(this);
  this.dom = dom;
  this.painterRoot = painterRoot;
  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);

  if (globalEventSupported) {
    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
  }
  /**
   * @type {boolean}
   */


  this._pointerCapturing = false;
  /**
   * @type {Array.<number>} [x, y] or null.
   */

  this._mayPointerCapture = null;
  mountLocalDOMEventListeners(this, this._localHandlerScope);
}

var handlerDomProxyProto = HandlerDomProxy.prototype;

handlerDomProxyProto.dispose = function () {
  unmountDOMEventListeners(this._localHandlerScope);

  if (globalEventSupported) {
    unmountDOMEventListeners(this._globalHandlerScope);
  }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
};

zrUtil.mixin(HandlerDomProxy, Eventful);
var _default = HandlerDomProxy;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/export.js":
/*!***********************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/export.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var zrUtil = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

exports.util = zrUtil;

var matrix = __webpack_require__(/*! ./core/matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

exports.matrix = matrix;

var vector = __webpack_require__(/*! ./core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

exports.vector = vector;

var colorTool = __webpack_require__(/*! ./tool/color */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js");

exports.color = colorTool;

var pathTool = __webpack_require__(/*! ./tool/path */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/path.js");

exports.path = pathTool;

var _parseSVG = __webpack_require__(/*! ./tool/parseSVG */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/parseSVG.js");

var parseSVG = _parseSVG.parseSVG;
exports.parseSVG = _parseSVG.parseSVG;

var _Group = __webpack_require__(/*! ./container/Group */ "./node_modules/_zrender@4.3.2@zrender/lib/container/Group.js");

exports.Group = _Group;

var _Path = __webpack_require__(/*! ./graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

exports.Path = _Path;

var _Image = __webpack_require__(/*! ./graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

exports.Image = _Image;

var _CompoundPath = __webpack_require__(/*! ./graphic/CompoundPath */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/CompoundPath.js");

exports.CompoundPath = _CompoundPath;

var _Text = __webpack_require__(/*! ./graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

exports.Text = _Text;

var _IncrementalDisplayable = __webpack_require__(/*! ./graphic/IncrementalDisplayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/IncrementalDisplayable.js");

exports.IncrementalDisplayable = _IncrementalDisplayable;

var _Arc = __webpack_require__(/*! ./graphic/shape/Arc */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Arc.js");

exports.Arc = _Arc;

var _BezierCurve = __webpack_require__(/*! ./graphic/shape/BezierCurve */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/BezierCurve.js");

exports.BezierCurve = _BezierCurve;

var _Circle = __webpack_require__(/*! ./graphic/shape/Circle */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Circle.js");

exports.Circle = _Circle;

var _Droplet = __webpack_require__(/*! ./graphic/shape/Droplet */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Droplet.js");

exports.Droplet = _Droplet;

var _Ellipse = __webpack_require__(/*! ./graphic/shape/Ellipse */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ellipse.js");

exports.Ellipse = _Ellipse;

var _Heart = __webpack_require__(/*! ./graphic/shape/Heart */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Heart.js");

exports.Heart = _Heart;

var _Isogon = __webpack_require__(/*! ./graphic/shape/Isogon */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Isogon.js");

exports.Isogon = _Isogon;

var _Line = __webpack_require__(/*! ./graphic/shape/Line */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Line.js");

exports.Line = _Line;

var _Polygon = __webpack_require__(/*! ./graphic/shape/Polygon */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polygon.js");

exports.Polygon = _Polygon;

var _Polyline = __webpack_require__(/*! ./graphic/shape/Polyline */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polyline.js");

exports.Polyline = _Polyline;

var _Rect = __webpack_require__(/*! ./graphic/shape/Rect */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rect.js");

exports.Rect = _Rect;

var _Ring = __webpack_require__(/*! ./graphic/shape/Ring */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ring.js");

exports.Ring = _Ring;

var _Rose = __webpack_require__(/*! ./graphic/shape/Rose */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rose.js");

exports.Rose = _Rose;

var _Sector = __webpack_require__(/*! ./graphic/shape/Sector */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Sector.js");

exports.Sector = _Sector;

var _Star = __webpack_require__(/*! ./graphic/shape/Star */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Star.js");

exports.Star = _Star;

var _Trochoid = __webpack_require__(/*! ./graphic/shape/Trochoid */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Trochoid.js");

exports.Trochoid = _Trochoid;

var _LinearGradient = __webpack_require__(/*! ./graphic/LinearGradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/LinearGradient.js");

exports.LinearGradient = _LinearGradient;

var _RadialGradient = __webpack_require__(/*! ./graphic/RadialGradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/RadialGradient.js");

exports.RadialGradient = _RadialGradient;

var _Pattern = __webpack_require__(/*! ./graphic/Pattern */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Pattern.js");

exports.Pattern = _Pattern;

var _BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

exports.BoundingRect = _BoundingRect;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/CompoundPath.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/CompoundPath.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ./Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

// CompoundPath to improve performance
var _default = Path.extend({
  type: 'compound',
  shape: {
    paths: null
  },
  _updatePathDirty: function () {
    var dirtyPath = this.__dirtyPath;
    var paths = this.shape.paths;

    for (var i = 0; i < paths.length; i++) {
      // Mark as dirty if any subpath is dirty
      dirtyPath = dirtyPath || paths[i].__dirtyPath;
    }

    this.__dirtyPath = dirtyPath;
    this.__dirty = this.__dirty || dirtyPath;
  },
  beforeBrush: function () {
    this._updatePathDirty();

    var paths = this.shape.paths || [];
    var scale = this.getGlobalScale(); // Update path scale

    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }

      paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
    }
  },
  buildPath: function (ctx, shape) {
    var paths = shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  },
  afterBrush: function () {
    var paths = this.shape.paths || [];

    for (var i = 0; i < paths.length; i++) {
      paths[i].__dirtyPath = false;
    }
  },
  getBoundingRect: function () {
    this._updatePathDirty();

    return Path.prototype.getBoundingRect.call(this);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Style = __webpack_require__(/*! ./Style */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Style.js");

var Element = __webpack_require__(/*! ../Element */ "./node_modules/_zrender@4.3.2@zrender/lib/Element.js");

var RectText = __webpack_require__(/*! ./mixin/RectText */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/mixin/RectText.js");

/**
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */

/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */
function Displayable(opts) {
  opts = opts || {};
  Element.call(this, opts); // Extend properties

  for (var name in opts) {
    if (opts.hasOwnProperty(name) && name !== 'style') {
      this[name] = opts[name];
    }
  }
  /**
   * @type {module:zrender/graphic/Style}
   */


  this.style = new Style(opts.style, this);
  this._rect = null; // Shapes for cascade clipping.
  // Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.
  // because it is easy to only using null to check whether clipPaths changed.

  this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted
  // Stateful.call(this, opts);
}

Displayable.prototype = {
  constructor: Displayable,
  type: 'displayable',

  /**
   * Dirty flag. From which painter will determine if this displayable object needs brush.
   * @name module:zrender/graphic/Displayable#__dirty
   * @type {boolean}
   */
  __dirty: true,

  /**
   * Whether the displayable object is visible. when it is true, the displayable object
   * is not drawn, but the mouse event can still trigger the object.
   * @name module:/zrender/graphic/Displayable#invisible
   * @type {boolean}
   * @default false
   */
  invisible: false,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z: 0,

  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z2: 0,

  /**
   * The z level determines the displayable object can be drawn in which layer canvas.
   * @name module:/zrender/graphic/Displayable#zlevel
   * @type {number}
   * @default 0
   */
  zlevel: 0,

  /**
   * Whether it can be dragged.
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  draggable: false,

  /**
   * Whether is it dragging.
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  dragging: false,

  /**
   * Whether to respond to mouse events.
   * @name module:/zrender/graphic/Displayable#silent
   * @type {boolean}
   * @default false
   */
  silent: false,

  /**
   * If enable culling
   * @type {boolean}
   * @default false
   */
  culling: false,

  /**
   * Mouse cursor when hovered
   * @name module:/zrender/graphic/Displayable#cursor
   * @type {string}
   */
  cursor: 'pointer',

  /**
   * If hover area is bounding rect
   * @name module:/zrender/graphic/Displayable#rectHover
   * @type {string}
   */
  rectHover: false,

  /**
   * Render the element progressively when the value >= 0,
   * usefull for large data.
   * @type {boolean}
   */
  progressive: false,

  /**
   * @type {boolean}
   */
  incremental: false,

  /**
   * Scale ratio for global scale.
   * @type {boolean}
   */
  globalScaleRatio: 1,
  beforeBrush: function (ctx) {},
  afterBrush: function (ctx) {},

  /**
   * Graphic drawing method.
   * @param {CanvasRenderingContext2D} ctx
   */
  // Interface
  brush: function (ctx, prevEl) {},

  /**
   * Get the minimum bounding box.
   * @return {module:zrender/core/BoundingRect}
   */
  // Interface
  getBoundingRect: function () {},

  /**
   * If displayable element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  contain: function (x, y) {
    return this.rectContain(x, y);
  },

  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function (cb, context) {
    cb.call(context, this);
  },

  /**
   * If bounding rect of element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  rectContain: function (x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },

  /**
   * Mark displayable element dirty and refresh next frame
   */
  dirty: function () {
    this.__dirty = this.__dirtyText = true;
    this._rect = null;
    this.__zr && this.__zr.refresh();
  },

  /**
   * If displayable object binded any event
   * @return {boolean}
   */
  // TODO, events bound by bind
  // isSilent: function () {
  //     return !(
  //         this.hoverable || this.draggable
  //         || this.onmousemove || this.onmouseover || this.onmouseout
  //         || this.onmousedown || this.onmouseup || this.onclick
  //         || this.ondragenter || this.ondragover || this.ondragleave
  //         || this.ondrop
  //     );
  // },

  /**
   * Alias for animate('style')
   * @param {boolean} loop
   */
  animateStyle: function (loop) {
    return this.animate('style', loop);
  },
  attrKV: function (key, value) {
    if (key !== 'style') {
      Element.prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setStyle: function (key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },

  /**
   * Use given style object
   * @param  {Object} obj
   */
  useStyle: function (obj) {
    this.style = new Style(obj, this);
    this.dirty(false);
    return this;
  },

  /**
   * The string value of `textPosition` needs to be calculated to a real postion.
   * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
   * by default. See `contain/text.js#calculateTextPosition` for more details.
   * But some coutom shapes like "pin", "flag" have center that is not exactly
   * `[width/2, height/2]`. So we provide this hook to customize the calculation
   * for those shapes. It will be called if the `style.textPosition` is a string.
   * @param {Obejct} [out] Prepared out object. If not provided, this method should
   *        be responsible for creating one.
   * @param {module:zrender/graphic/Style} style
   * @param {Object} rect {x, y, width, height}
   * @return {Obejct} out The same as the input out.
   *         {
   *             x: number. mandatory.
   *             y: number. mandatory.
   *             textAlign: string. optional. use style.textAlign by default.
   *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
   *         }
   */
  calculateTextPosition: null
};
zrUtil.inherits(Displayable, Element);
zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);

var _default = Displayable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Gradient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Gradient.js ***!
  \*********************************************************************/
/***/ ((module) => {

/**
 * @param {Array.<Object>} colorStops
 */
var Gradient = function (colorStops) {
  this.colorStops = colorStops || [];
};

Gradient.prototype = {
  constructor: Gradient,
  addColorStop: function (offset, color) {
    this.colorStops.push({
      offset: offset,
      color: color
    });
  }
};
var _default = Gradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js":
/*!******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Displayable = __webpack_require__(/*! ./Displayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js");

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var imageHelper = __webpack_require__(/*! ./helper/image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/image.js");

/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function ZImage(opts) {
  Displayable.call(this, opts);
}

ZImage.prototype = {
  constructor: ZImage,
  type: 'image',
  brush: function (ctx, prevEl) {
    var style = this.style;
    var src = style.image; // Must bind each time

    style.bind(ctx, this, prevEl);
    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);

    if (!image || !imageHelper.isImageReady(image)) {
      return;
    } // 图片已经加载完成
    // if (image.nodeName.toUpperCase() == 'IMG') {
    //     if (!image.complete) {
    //         return;
    //     }
    // }
    // Else is canvas


    var x = style.x || 0;
    var y = style.y || 0;
    var width = style.width;
    var height = style.height;
    var aspect = image.width / image.height;

    if (width == null && height != null) {
      // Keep image/height ratio
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    } // 设置transform


    this.setTransform(ctx);

    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    } // Draw rect text


    if (style.text != null) {
      // Only restore transform when needs draw text.
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  getBoundingRect: function () {
    var style = this.style;

    if (!this._rect) {
      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
    }

    return this._rect;
  }
};
zrUtil.inherits(ZImage, Displayable);
var _default = ZImage;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/IncrementalDisplayable.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/IncrementalDisplayable.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var inherits = _util.inherits;

var Displayble = __webpack_require__(/*! ./Displayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js");

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

/**
 * Displayable for incremental rendering. It will be rendered in a separate layer
 * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`
 * addDisplayables will render the added displayables incremetally.
 *
 * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
 */
// TODO Style override ?
function IncrementalDisplayble(opts) {
  Displayble.call(this, opts);
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.notClear = true;
}

IncrementalDisplayble.prototype.incremental = true;

IncrementalDisplayble.prototype.clearDisplaybles = function () {
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.dirty();
  this.notClear = false;
};

IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
  if (notPersistent) {
    this._temporaryDisplayables.push(displayable);
  } else {
    this._displayables.push(displayable);
  }

  this.dirty();
};

IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
  notPersistent = notPersistent || false;

  for (var i = 0; i < displayables.length; i++) {
    this.addDisplayable(displayables[i], notPersistent);
  }
};

IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
  for (var i = this._cursor; i < this._displayables.length; i++) {
    cb && cb(this._displayables[i]);
  }

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    cb && cb(this._temporaryDisplayables[i]);
  }
};

IncrementalDisplayble.prototype.update = function () {
  this.updateTransform();

  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i]; // PENDING

    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i]; // PENDING

    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }
};

IncrementalDisplayble.prototype.brush = function (ctx, prevEl) {
  // Render persistant displayables.
  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }

  this._cursor = i; // Render temporary displayables.

  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }

  this._temporaryDisplayables = [];
  this.notClear = true;
};

var m = [];

IncrementalDisplayble.prototype.getBoundingRect = function () {
  if (!this._rect) {
    var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);

    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      var childRect = displayable.getBoundingRect().clone();

      if (displayable.needLocalTransform()) {
        childRect.applyTransform(displayable.getLocalTransform(m));
      }

      rect.union(childRect);
    }

    this._rect = rect;
  }

  return this._rect;
};

IncrementalDisplayble.prototype.contain = function (x, y) {
  var localPos = this.transformCoordToLocal(x, y);
  var rect = this.getBoundingRect();

  if (rect.contain(localPos[0], localPos[1])) {
    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];

      if (displayable.contain(x, y)) {
        return true;
      }
    }
  }

  return false;
};

inherits(IncrementalDisplayble, Displayble);
var _default = IncrementalDisplayble;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/LinearGradient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/LinearGradient.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Gradient = __webpack_require__(/*! ./Gradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Gradient.js");

/**
 * x, y, x2, y2 are all percent from 0 to 1
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @param {number} [x2=1]
 * @param {number} [y2=0]
 * @param {Array.<Object>} colorStops
 * @param {boolean} [globalCoord=false]
 */
var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'linear', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0 : x;
  this.y = y == null ? 0 : y;
  this.x2 = x2 == null ? 1 : x2;
  this.y2 = y2 == null ? 0 : y2; // Can be cloned

  this.type = 'linear'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

LinearGradient.prototype = {
  constructor: LinearGradient
};
zrUtil.inherits(LinearGradient, Gradient);
var _default = LinearGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Displayable = __webpack_require__(/*! ./Displayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var pathContain = __webpack_require__(/*! ../contain/path */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/path.js");

var Pattern = __webpack_require__(/*! ./Pattern */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Pattern.js");

var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy(true);
/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */

function Path(opts) {
  Displayable.call(this, opts);
  /**
   * @type {module:zrender/core/PathProxy}
   * @readOnly
   */

  this.path = null;
}

Path.prototype = {
  constructor: Path,
  type: 'path',
  __dirtyPath: true,
  strokeContainThreshold: 5,
  // This item default to be false. But in map series in echarts,
  // in order to improve performance, it should be set to true,
  // so the shorty segment won't draw.
  segmentIgnoreThreshold: 0,

  /**
   * See `module:zrender/src/graphic/helper/subPixelOptimize`.
   * @type {boolean}
   */
  subPixelOptimize: false,
  brush: function (ctx, prevEl) {
    var style = this.style;
    var path = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);

    if (this.__dirty) {
      var rect; // Update gradient because bounding rect may changed

      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }

      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    } // Use the gradient or pattern


    if (hasFillGradient) {
      // PENDING If may have affect the state
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }

    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }

    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

    var scale = this.getGlobalScale();
    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context
    // Rebuild path in following 2 cases
    // 1. Path is dirty
    // 2. Path needs javascript implemented lineDash stroking.
    //    In this case, lineDash information will not be saved in PathProxy

    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
      path.beginPath(ctx); // Setting line dash before build path

      if (lineDash && !ctxLineDash) {
        path.setLineDash(lineDash);
        path.setLineDashOffset(lineDashOffset);
      }

      this.buildPath(path, this.shape, false); // Clear path dirty flag

      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      // Replay path building
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }

    if (hasFill) {
      if (style.fillOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.fillOpacity * style.opacity;
        path.fill(ctx);
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        path.fill(ctx);
      }
    }

    if (lineDash && ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }

    if (hasStroke) {
      if (style.strokeOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.strokeOpacity * style.opacity;
        path.stroke(ctx);
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        path.stroke(ctx);
      }
    }

    if (lineDash && ctxLineDash) {
      // PENDING
      // Remove lineDash
      ctx.setLineDash([]);
    } // Draw rect text


    if (style.text != null) {
      // Only restore transform when needs draw text.
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
  // Like in circle
  buildPath: function (ctx, shapeCfg, inBundle) {},
  createPathProxy: function () {
    this.path = new PathProxy();
  },
  getBoundingRect: function () {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;

    if (needsUpdateRect) {
      var path = this.path;

      if (!path) {
        // Create path on demand.
        path = this.path = new PathProxy();
      }

      if (this.__dirtyPath) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
      }

      rect = path.getBoundingRect();
    }

    this._rect = rect;

    if (style.hasStroke()) {
      // Needs update rect with stroke lineWidth when
      // 1. Element changes scale or lineWidth
      // 2. Shape is changed
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect); // FIXME Must after updateTransform

        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        } // Consider line width
        // Line scale can't be 0;


        if (lineScale > 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      } // Return rect with stroke


      return rectWithStroke;
    }

    return rect;
  },
  contain: function (x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];

    if (rect.contain(x, y)) {
      var pathData = this.path.data;

      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

        if (lineScale > 1e-10) {
          // Only add extra hover lineWidth when there are no fill
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }

          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }

      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }

    return false;
  },

  /**
   * @param  {boolean} dirtyPath
   */
  dirty: function (dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    } // Only mark dirty, not mark clean


    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }

    this.__dirty = this.__dirtyText = true;
    this.__zr && this.__zr.refresh(); // Used as a clipping path

    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },

  /**
   * Alias for animate('shape')
   * @param {boolean} loop
   */
  animateShape: function (loop) {
    return this.animate('shape', loop);
  },
  // Overwrite attrKV
  attrKV: function (key, value) {
    // FIXME
    if (key === 'shape') {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable.prototype.attrKV.call(this, key, value);
    }
  },

  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setShape: function (key, value) {
    var shape = this.shape; // Path from string may not have shape

    if (shape) {
      if (zrUtil.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            shape[name] = key[name];
          }
        }
      } else {
        shape[key] = value;
      }

      this.dirty(true);
    }

    return this;
  },
  getLineScale: function () {
    var m = this.transform; // Get the line scale.
    // Determinant of `m` means how much the area is enlarged by the
    // transformation. So its square root can be used as a scale factor
    // for width.

    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
  }
};
/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */

Path.extend = function (defaults) {
  var Sub = function (opts) {
    Path.call(this, opts);

    if (defaults.style) {
      // Extend default style
      this.style.extendFrom(defaults.style, false);
    } // Extend default shape


    var defaultShape = defaults.shape;

    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;

      for (var name in defaultShape) {
        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
          thisShape[name] = defaultShape[name];
        }
      }
    }

    defaults.init && defaults.init.call(this, opts);
  };

  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

  for (var name in defaults) {
    // Extending prototype values and methods
    if (name !== 'style' && name !== 'shape') {
      Sub.prototype[name] = defaults[name];
    }
  }

  return Sub;
};

zrUtil.inherits(Path, Displayable);
var _default = Path;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Pattern.js":
/*!********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Pattern.js ***!
  \********************************************************************/
/***/ ((module) => {

var Pattern = function (image, repeat) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {image: ...}`, where this constructor will not be called.
  this.image = image;
  this.repeat = repeat; // Can be cloned

  this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
  return ctx.createPattern(this.image, this.repeat || 'repeat');
};

var _default = Pattern;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/RadialGradient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/RadialGradient.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Gradient = __webpack_require__(/*! ./Gradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Gradient.js");

/**
 * x, y, r are all percent from 0 to 1
 * @param {number} [x=0.5]
 * @param {number} [y=0.5]
 * @param {number} [r=0.5]
 * @param {Array.<Object>} [colorStops]
 * @param {boolean} [globalCoord=false]
 */
var RadialGradient = function (x, y, r, colorStops, globalCoord) {
  // Should do nothing more in this constructor. Because gradient can be
  // declard by `color: {type: 'radial', colorStops: ...}`, where
  // this constructor will not be called.
  this.x = x == null ? 0.5 : x;
  this.y = y == null ? 0.5 : y;
  this.r = r == null ? 0.5 : r; // Can be cloned

  this.type = 'radial'; // If use global coord

  this.global = globalCoord || false;
  Gradient.call(this, colorStops);
};

RadialGradient.prototype = {
  constructor: RadialGradient
};
zrUtil.inherits(RadialGradient, Gradient);
var _default = RadialGradient;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Style.js":
/*!******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Style.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fixShadow = __webpack_require__(/*! ./helper/fixShadow */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixShadow.js");

var _constant = __webpack_require__(/*! ./constant */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js");

var ContextCachedBy = _constant.ContextCachedBy;
var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

var Style = function (opts) {
  this.extendFrom(opts, false);
};

function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;

  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  } // Fix NaN when rect is Infinity


  x = isNaN(x) ? 0 : x;
  x2 = isNaN(x2) ? 1 : x2;
  y = isNaN(y) ? 0 : y;
  y2 = isNaN(y2) ? 0 : y2;
  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;

  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min;
  }

  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}

Style.prototype = {
  constructor: Style,

  /**
   * @type {string}
   */
  fill: '#000',

  /**
   * @type {string}
   */
  stroke: null,

  /**
   * @type {number}
   */
  opacity: 1,

  /**
   * @type {number}
   */
  fillOpacity: null,

  /**
   * @type {number}
   */
  strokeOpacity: null,

  /**
   * `true` is not supported.
   * `false`/`null`/`undefined` are the same.
   * `false` is used to remove lineDash in some
   * case that `null`/`undefined` can not be set.
   * (e.g., emphasis.lineStyle in echarts)
   * @type {Array.<number>|boolean}
   */
  lineDash: null,

  /**
   * @type {number}
   */
  lineDashOffset: 0,

  /**
   * @type {number}
   */
  shadowBlur: 0,

  /**
   * @type {number}
   */
  shadowOffsetX: 0,

  /**
   * @type {number}
   */
  shadowOffsetY: 0,

  /**
   * @type {number}
   */
  lineWidth: 1,

  /**
   * If stroke ignore scale
   * @type {Boolean}
   */
  strokeNoScale: false,
  // Bounding rect text configuration
  // Not affected by element transform

  /**
   * @type {string}
   */
  text: null,

  /**
   * If `fontSize` or `fontFamily` exists, `font` will be reset by
   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
   * So do not visit it directly in upper application (like echarts),
   * but use `contain/text#makeFont` instead.
   * @type {string}
   */
  font: null,

  /**
   * The same as font. Use font please.
   * @deprecated
   * @type {string}
   */
  textFont: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontStyle: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontWeight: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * Should be 12 but not '12px'.
   * @type {number}
   */
  fontSize: null,

  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontFamily: null,

  /**
   * Reserved for special functinality, like 'hr'.
   * @type {string}
   */
  textTag: null,

  /**
   * @type {string}
   */
  textFill: '#000',

  /**
   * @type {string}
   */
  textStroke: null,

  /**
   * @type {number}
   */
  textWidth: null,

  /**
   * Only for textBackground.
   * @type {number}
   */
  textHeight: null,

  /**
   * textStroke may be set as some color as a default
   * value in upper applicaion, where the default value
   * of textStrokeWidth should be 0 to make sure that
   * user can choose to do not use text stroke.
   * @type {number}
   */
  textStrokeWidth: 0,

  /**
   * @type {number}
   */
  textLineHeight: null,

  /**
   * 'inside', 'left', 'right', 'top', 'bottom'
   * [x, y]
   * Based on x, y of rect.
   * @type {string|Array.<number>}
   * @default 'inside'
   */
  textPosition: 'inside',

  /**
   * If not specified, use the boundingRect of a `displayable`.
   * @type {Object}
   */
  textRect: null,

  /**
   * [x, y]
   * @type {Array.<number>}
   */
  textOffset: null,

  /**
   * @type {string}
   */
  textAlign: null,

  /**
   * @type {string}
   */
  textVerticalAlign: null,

  /**
   * @type {number}
   */
  textDistance: 5,

  /**
   * @type {string}
   */
  textShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textShadowBlur: 0,

  /**
   * @type {number}
   */
  textShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textShadowOffsetY: 0,

  /**
   * @type {string}
   */
  textBoxShadowColor: 'transparent',

  /**
   * @type {number}
   */
  textBoxShadowBlur: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetX: 0,

  /**
   * @type {number}
   */
  textBoxShadowOffsetY: 0,

  /**
   * Whether transform text.
   * Only available in Path and Image element,
   * where the text is called as `RectText`.
   * @type {boolean}
   */
  transformText: false,

  /**
   * Text rotate around position of Path or Image.
   * The origin of the rotation can be specified by `textOrigin`.
   * Only available in Path and Image element,
   * where the text is called as `RectText`.
   */
  textRotation: 0,

  /**
   * Text origin of text rotation.
   * Useful in the case like label rotation of circular symbol.
   * Only available in Path and Image element, where the text is called
   * as `RectText` and the element is called as "host element".
   * The value can be:
   * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`
   * base on the left-top corner of the rect of its host element.
   * + If specified as a string `center`, it is the center of the rect of
   * its host element.
   * + By default, this origin is the `textPosition`.
   * @type {string|Array.<number>}
   */
  textOrigin: null,

  /**
   * @type {string}
   */
  textBackgroundColor: null,

  /**
   * @type {string}
   */
  textBorderColor: null,

  /**
   * @type {number}
   */
  textBorderWidth: 0,

  /**
   * @type {number}
   */
  textBorderRadius: 0,

  /**
   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
   * @type {number|Array.<number>}
   */
  textPadding: null,

  /**
   * Text styles for rich text.
   * @type {Object}
   */
  rich: null,

  /**
   * {outerWidth, outerHeight, ellipsis, placeholder}
   * @type {Object}
   */
  truncate: null,

  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @type {string}
   */
  blend: null,

  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  bind: function (ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.
    // Only apply cache if the last time cachced by this function.

    var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;
    ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];

      if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
        // FIXME Invalid property value will cause style leak from previous element.
        ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);
      }
    }

    if (notCheckCache || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }

    if (notCheckCache || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }

    if (notCheckCache || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }

    if (notCheckCache || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || 'source-over';
    }

    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },
  hasFill: function () {
    var fill = this.fill;
    return fill != null && fill !== 'none';
  },
  hasStroke: function () {
    var stroke = this.stroke;
    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
  },

  /**
   * Extend from other style
   * @param {zrender/graphic/Style} otherStyle
   * @param {boolean} overwrite true: overwrirte any way.
   *                            false: overwrite only when !target.hasOwnProperty
   *                            others: overwrite when property is not null/undefined.
   */
  extendFrom: function (otherStyle, overwrite) {
    if (otherStyle) {
      for (var name in otherStyle) {
        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
          this[name] = otherStyle[name];
        }
      }
    }
  },

  /**
   * Batch setting style with a given object
   * @param {Object|string} obj
   * @param {*} [obj]
   */
  set: function (obj, value) {
    if (typeof obj === 'string') {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },

  /**
   * Clone
   * @return {zrender/graphic/Style} [description]
   */
  clone: function () {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },
  getGradient: function (ctx, obj, rect) {
    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;

    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }

    return canvasGradient;
  }
};
var styleProto = Style.prototype;

for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];

  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
} // Provide for others


Style.getGradient = styleProto.getGradient;
var _default = Style;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js":
/*!*****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Displayable = __webpack_require__(/*! ./Displayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js");

var zrUtil = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var textContain = __webpack_require__(/*! ../contain/text */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js");

var textHelper = __webpack_require__(/*! ./helper/text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js");

var _constant = __webpack_require__(/*! ./constant */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js");

var ContextCachedBy = _constant.ContextCachedBy;

/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
var Text = function (opts) {
  // jshint ignore:line
  Displayable.call(this, opts);
};

Text.prototype = {
  constructor: Text,
  type: 'text',
  brush: function (ctx, prevEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.

    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text = style.text; // Convert to string

    text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job
    // is in textHelper.renderText, and performance of text render should
    // be considered.
    // style.bind(ctx, this, prevEl);

    if (!textHelper.needDrawText(text, style)) {
      // The current el.style is not applied
      // and should not be used as cache.
      ctx.__attrCachedBy = ContextCachedBy.NONE;
      return;
    }

    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text, style, null, prevEl);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function () {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);

    if (!this._rect) {
      var text = style.text;
      text != null ? text += '' : text = '';
      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;

      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }

      this._rect = rect;
    }

    return this._rect;
  }
};
zrUtil.inherits(Text, Displayable);
var _default = Text;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var ContextCachedBy = {
  NONE: 0,
  STYLE_BIND: 1,
  PLAIN_TEXT: 2
}; // Avoid confused with 0/false.

var WILL_BE_RESTORED = 9;
exports.ContextCachedBy = ContextCachedBy;
exports.WILL_BE_RESTORED = WILL_BE_RESTORED;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixClipWithShadow.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixClipWithShadow.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var env = __webpack_require__(/*! ../../core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
// where exception "unexpected call to method or property access"
// might be thrown when calling ctx.fill or ctx.stroke after a path
// whose area size is zero is drawn and ctx.clip() is called and
// shadowBlur is set. See #4572, #3112, #5777.
// (e.g.,
//  ctx.moveTo(10, 10);
//  ctx.lineTo(20, 10);
//  ctx.closePath();
//  ctx.clip();
//  ctx.shadowBlur = 10;
//  ...
//  ctx.fill();
// )
var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

function _default(orignalBrush) {
  // version string can be: '11.0'
  return env.browser.ie && env.browser.version >= 11 ? function () {
    var clipPaths = this.__clipPaths;
    var style = this.style;
    var modified;

    if (clipPaths) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        var shape = clipPath && clipPath.shape;
        var type = clipPath && clipPath.type;

        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
          for (var j = 0; j < shadowTemp.length; j++) {
            // It is save to put shadowTemp static, because shadowTemp
            // will be all modified each item brush called.
            shadowTemp[j][2] = style[shadowTemp[j][0]];
            style[shadowTemp[j][0]] = shadowTemp[j][1];
          }

          modified = true;
          break;
        }
      }
    }

    orignalBrush.apply(this, arguments);

    if (modified) {
      for (var j = 0; j < shadowTemp.length; j++) {
        style[shadowTemp[j][0]] = shadowTemp[j][2];
      }
    }
  } : orignalBrush;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixShadow.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixShadow.js ***!
  \*****************************************************************************/
/***/ ((module) => {

var SHADOW_PROPS = {
  'shadowBlur': 1,
  'shadowOffsetX': 1,
  'shadowOffsetY': 1,
  'textShadowBlur': 1,
  'textShadowOffsetX': 1,
  'textShadowOffsetY': 1,
  'textBoxShadowBlur': 1,
  'textBoxShadowOffsetX': 1,
  'textBoxShadowOffsetY': 1
};

function _default(ctx, propName, value) {
  if (SHADOW_PROPS.hasOwnProperty(propName)) {
    return value *= ctx.dpr;
  }

  return value;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/image.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/image.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var LRU = __webpack_require__(/*! ../../core/LRU */ "./node_modules/_zrender@4.3.2@zrender/lib/core/LRU.js");

var globalImageCache = new LRU(50);
/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */

function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === 'string') {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */


function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === 'string') {
    // Image should not be loaded repeatly.
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    } // Only when there is no existent image or existent image src
    // is different, this method is responsible for load.


    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = {
      hostEl: hostEl,
      cb: cb,
      cbPayload: cbPayload
    };

    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = new Image();
      image.onload = image.onerror = imageOnLoad;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image: image,
        pending: [pendingWrap]
      });
      image.src = image.__zrImageSrc = newImageOrSrc;
    }

    return image;
  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
  else {
      return newImageOrSrc;
    }
}

function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;

  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }

  cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
  return image && image.width && image.height;
}

exports.findExistImage = findExistImage;
exports.createOrUpdateImage = createOrUpdateImage;
exports.isImageReady = isImageReady;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/poly.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/poly.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var smoothSpline = __webpack_require__(/*! ./smoothSpline */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothSpline.js");

var smoothBezier = __webpack_require__(/*! ./smoothBezier */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothBezier.js");

function buildPath(ctx, shape, closePath) {
  var points = shape.points;
  var smooth = shape.smooth;

  if (points && points.length >= 2) {
    if (smooth && smooth !== 'spline') {
      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points[0][0], points[0][1]);
      var len = points.length;

      for (var i = 0; i < (closePath ? len : len - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points[(i + 1) % len];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      if (smooth === 'spline') {
        points = smoothSpline(points, closePath);
      }

      ctx.moveTo(points[0][0], points[0][1]);

      for (var i = 1, l = points.length; i < l; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
    }

    closePath && ctx.closePath();
  }
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/roundRect.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/roundRect.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * @param {Object} ctx
 * @param {Object} shape
 * @param {number} shape.x
 * @param {number} shape.y
 * @param {number} shape.width
 * @param {number} shape.height
 * @param {number} shape.r
 */
function buildPath(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4; // Convert width and height to positive for better borderRadius

  if (width < 0) {
    x = x + width;
    width = -width;
  }

  if (height < 0) {
    y = y + height;
    height = -height;
  }

  if (typeof r === 'number') {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }

  var total;

  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }

  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }

  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }

  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }

  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

exports.buildPath = buildPath;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothBezier.js":
/*!********************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothBezier.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _vector = __webpack_require__(/*! ../../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var v2Min = _vector.min;
var v2Max = _vector.max;
var v2Scale = _vector.scale;
var v2Distance = _vector.distance;
var v2Add = _vector.add;
var v2Clone = _vector.clone;
var v2Sub = _vector.sub;

/**
 * 贝塞尔平滑曲线
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * 贝塞尔平滑曲线
 * @alias module:zrender/shape/util/smoothBezier
 * @param {Array} points 线段顶点数组
 * @param {number} smooth 平滑等级, 0-1
 * @param {boolean} isLoop
 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
 *                           整个折线的包围盒做一个并集用来约束控制点。
 * @param {Array} 计算出来的控制点数组
 */
function _default(points, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v1 = [];
  var v2 = [];
  var prevPoint;
  var nextPoint;
  var min;
  var max;

  if (constraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, len = points.length; i < len; i++) {
      v2Min(min, min, points[i]);
      v2Max(max, max, points[i]);
    } // 与指定的包围盒做并集


    v2Min(min, min, constraint[0]);
    v2Max(max, max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(v2Clone(points[i]));
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

    v2Scale(v, v, smooth);
    var d0 = v2Distance(point, prevPoint);
    var d1 = v2Distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    v2Scale(v1, v, -d0);
    v2Scale(v2, v, d1);
    var cp0 = v2Add([], point, v1);
    var cp1 = v2Add([], point, v2);

    if (constraint) {
      v2Max(cp0, cp0, min);
      v2Min(cp0, cp0, max);
      v2Max(cp1, cp1, min);
      v2Min(cp1, cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothSpline.js":
/*!********************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/smoothSpline.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _vector = __webpack_require__(/*! ../../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var v2Distance = _vector.distance;

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang)
 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 */

/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * @alias module:zrender/shape/util/smoothSpline
 * @param {Array} points 线段顶点数组
 * @param {boolean} isLoop
 * @return {Array}
 */


function _default(points, isLoop) {
  var len = points.length;
  var ret = [];
  var distance = 0;

  for (var i = 1; i < len; i++) {
    distance += v2Distance(points[i - 1], points[i]);
  }

  var segs = distance / 2;
  segs = segs < len ? len : segs;

  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points[idx % len];
    var p2;
    var p3;

    if (!isLoop) {
      p0 = points[idx === 0 ? idx : idx - 1];
      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points[(idx - 1 + len) % len];
      p2 = points[(idx + 1) % len];
      p3 = points[(idx + 2) % len];
    }

    var w2 = w * w;
    var w3 = w * w2;
    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
  }

  return ret;
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/subPixelOptimize.js":
/*!************************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/subPixelOptimize.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Sub-pixel optimize for canvas rendering, prevent from blur
 * when rendering a thin vertical/horizontal line.
 */
var round = Math.round;
/**
 * Sub pixel optimize line for canvas
 *
 * @param {Object} outputShape The modification will be performed on `outputShape`.
 *                 `outputShape` and `inputShape` can be the same object.
 *                 `outputShape` object can be used repeatly, because all of
 *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.
 * @param {Object} [inputShape]
 * @param {number} [inputShape.x1]
 * @param {number} [inputShape.y1]
 * @param {number} [inputShape.x2]
 * @param {number} [inputShape.y2]
 * @param {Object} [style]
 * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
 */

function subPixelOptimizeLine(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }

  var x1 = inputShape.x1;
  var x2 = inputShape.x2;
  var y1 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;

  if (!lineWidth) {
    return;
  }

  if (round(x1 * 2) === round(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
  }

  if (round(y1 * 2) === round(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
  }
}
/**
 * Sub pixel optimize rect for canvas
 *
 * @param {Object} outputShape The modification will be performed on `outputShape`.
 *                 `outputShape` and `inputShape` can be the same object.
 *                 `outputShape` object can be used repeatly, because all of
 *                 the `x`, `y`, `width`, `height` will be assigned in this method.
 * @param {Object} [inputShape]
 * @param {number} [inputShape.x]
 * @param {number} [inputShape.y]
 * @param {number} [inputShape.width]
 * @param {number} [inputShape.height]
 * @param {Object} [style]
 * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
 */


function subPixelOptimizeRect(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }

  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;

  if (!lineWidth) {
    return;
  }

  outputShape.x = subPixelOptimize(originX, lineWidth, true);
  outputShape.y = subPixelOptimize(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
}
/**
 * Sub pixel optimize for canvas
 *
 * @param {number} position Coordinate, such as x, y
 * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.
 * @param {boolean=} positiveOrNegative Default false (negative).
 * @return {number} Optimized position.
 */


function subPixelOptimize(position, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position;
  } // Assure that (position + lineWidth / 2) is near integer edge,
  // otherwise line will be fuzzy in canvas.


  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

exports.subPixelOptimizeLine = subPixelOptimizeLine;
exports.subPixelOptimizeRect = subPixelOptimizeRect;
exports.subPixelOptimize = subPixelOptimize;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _util = __webpack_require__(/*! ../../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var retrieve2 = _util.retrieve2;
var retrieve3 = _util.retrieve3;
var each = _util.each;
var normalizeCssArray = _util.normalizeCssArray;
var isString = _util.isString;
var isObject = _util.isObject;

var textContain = __webpack_require__(/*! ../../contain/text */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js");

var roundRectHelper = __webpack_require__(/*! ./roundRect */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/roundRect.js");

var imageHelper = __webpack_require__(/*! ./image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/image.js");

var fixShadow = __webpack_require__(/*! ./fixShadow */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixShadow.js");

var _constant = __webpack_require__(/*! ../constant */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js");

var ContextCachedBy = _constant.ContextCachedBy;
var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;
var DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.

var VALID_TEXT_ALIGN = {
  left: 1,
  right: 1,
  center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
  top: 1,
  bottom: 1,
  middle: 1
}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,
// the default value of shadowColor is `'transparent'`.

var SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];
var _tmpTextPositionResult = {};
var _tmpBoxPositionResult = {};
/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */

function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}

function normalizeStyle(style) {
  if (style) {
    style.font = textContain.makeFont(style);
    var textAlign = style.textAlign;
    textAlign === 'middle' && (textAlign = 'center');
    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
    var textPadding = style.textPadding;

    if (textPadding) {
      style.textPadding = normalizeCssArray(style.textPadding);
    }
  }
}
/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.
 */


function renderText(hostEl, ctx, text, style, rect, prevEl) {
  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
} // Avoid setting to ctx according to prevEl if possible for
// performance in scenarios of large amount text.


function renderPlainText(hostEl, ctx, text, style, rect, prevEl) {
  'use strict';

  var needDrawBg = needDrawBackground(style);
  var prevStyle;
  var checkCache = false;
  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.

  if (prevEl !== WILL_BE_RESTORED) {
    if (prevEl) {
      prevStyle = prevEl.style;
      checkCache = !needDrawBg && cachedByMe && prevStyle;
    } // Prevent from using cache in `Style::bind`, because of the case:
    // ctx property is modified by other properties than `Style::bind`
    // used, and Style::bind is called next.


    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;
  } // Since this will be restored, prevent from using these props to check cache in the next
  // entering of this method. But do not need to clear other cache like `Style::bind`.
  else if (cachedByMe) {
      ctx.__attrCachedBy = ContextCachedBy.NONE;
    }

  var styleFont = style.font || DEFAULT_FONT; // PENDING
  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically
  // we can make font cache on ctx, which can cache for text el that are discontinuous.
  // But layer save/restore needed to be considered.
  // if (styleFont !== ctx.__fontCache) {
  //     ctx.font = styleFont;
  //     if (prevEl !== WILL_BE_RESTORED) {
  //         ctx.__fontCache = styleFont;
  //     }
  // }

  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {
    ctx.font = styleFont;
  } // Use the final font from context-2d, because the final
  // font might not be the style.font when it is illegal.
  // But get `ctx.font` might be time consuming.


  var computedFont = hostEl.__computedFont;

  if (hostEl.__styleFont !== styleFont) {
    hostEl.__styleFont = styleFont;
    computedFont = hostEl.__computedFont = ctx.font;
  }

  var textPadding = style.textPadding;
  var textLineHeight = style.textLineHeight;
  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirtyText) {
    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
  }

  var outerHeight = contentBlock.outerHeight;
  var textLines = contentBlock.lines;
  var lineHeight = contentBlock.lineHeight;
  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign || 'left';
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY;

  if (needDrawBg || textPadding) {
    // Consider performance, do not call getTextWidth util necessary.
    var textWidth = textContain.getWidth(text, computedFont);
    var outerWidth = textWidth;
    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
  } // Always set textAlign and textBase line, because it is difficute to calculate
  // textAlign from prevEl, and we dont sure whether textAlign will be reset if
  // font set happened.


  ctx.textAlign = textAlign; // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  ctx.textBaseline = 'middle'; // Set text opacity

  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.

  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
    var propItem = SHADOW_STYLE_COMMON_PROPS[i];
    var styleProp = propItem[0];
    var ctxProp = propItem[1];
    var val = style[styleProp];

    if (!checkCache || val !== prevStyle[styleProp]) {
      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
    }
  } // `textBaseline` is set as 'middle'.


  textY += lineHeight / 2;
  var textStrokeWidth = style.textStrokeWidth;
  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
  var textStroke = getStroke(style.textStroke, textStrokeWidth);
  var textFill = getFill(style.textFill);

  if (textStroke) {
    if (strokeWidthChanged) {
      ctx.lineWidth = textStrokeWidth;
    }

    if (strokeChanged) {
      ctx.strokeStyle = textStroke;
    }
  }

  if (textFill) {
    if (!checkCache || style.textFill !== prevStyle.textFill) {
      ctx.fillStyle = textFill;
    }
  } // Optimize simply, in most cases only one line exists.


  if (textLines.length === 1) {
    // Fill after stroke so the outline will not cover the main part.
    textStroke && ctx.strokeText(textLines[0], textX, textY);
    textFill && ctx.fillText(textLines[0], textX, textY);
  } else {
    for (var i = 0; i < textLines.length; i++) {
      // Fill after stroke so the outline will not cover the main part.
      textStroke && ctx.strokeText(textLines[i], textX, textY);
      textFill && ctx.fillText(textLines[i], textX, textY);
      textY += lineHeight;
    }
  }
}

function renderRichText(hostEl, ctx, text, style, rect, prevEl) {
  // Do not do cache for rich text because of the complexity.
  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.
  if (prevEl !== WILL_BE_RESTORED) {
    ctx.__attrCachedBy = ContextCachedBy.NONE;
  }

  var contentBlock = hostEl.__textCotentBlock;

  if (!contentBlock || hostEl.__dirtyText) {
    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
  }

  drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
  var contentWidth = contentBlock.width;
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var textPadding = style.textPadding;
  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var xLeft = boxX;
  var lineTop = boxY;

  if (textPadding) {
    xLeft += textPadding[3];
    lineTop += textPadding[0];
  }

  var xRight = xLeft + contentWidth;
  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

  for (var i = 0; i < contentBlock.lines.length; i++) {
    var line = contentBlock.lines[i];
    var tokens = line.tokens;
    var tokenCount = tokens.length;
    var lineHeight = line.lineHeight;
    var usedWidth = line.width;
    var leftIndex = 0;
    var lineXLeft = xLeft;
    var lineXRight = xRight;
    var rightIndex = tokenCount - 1;
    var token;

    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
      usedWidth -= token.width;
      lineXLeft += token.width;
      leftIndex++;
    }

    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
      usedWidth -= token.width;
      lineXRight -= token.width;
      rightIndex--;
    } // The other tokens are placed as textAlign 'center' if there is enough space.


    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

    while (leftIndex <= rightIndex) {
      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
      lineXLeft += token.width;
      leftIndex++;
    }

    lineTop += lineHeight;
  }
}

function applyTextRotation(ctx, style, rect, x, y) {
  // textRotation only apply in RectText.
  if (rect && style.textRotation) {
    var origin = style.textOrigin;

    if (origin === 'center') {
      x = rect.width / 2 + rect.x;
      y = rect.height / 2 + rect.y;
    } else if (origin) {
      x = origin[0] + rect.x;
      y = origin[1] + rect.y;
    }

    ctx.translate(x, y); // Positive: anticlockwise

    ctx.rotate(-style.textRotation);
    ctx.translate(-x, -y);
  }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
  var tokenStyle = style.rich[token.styleName] || {};
  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of
  // the bias of "Microsoft YaHei".

  var textVerticalAlign = token.textVerticalAlign;
  var y = lineTop + lineHeight / 2;

  if (textVerticalAlign === 'top') {
    y = lineTop + token.height / 2;
  } else if (textVerticalAlign === 'bottom') {
    y = lineTop + lineHeight - token.height / 2;
  }

  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
  var textPadding = token.textPadding;

  if (textPadding) {
    x = getTextXForPadding(x, textAlign, textPadding);
    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
  }

  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
  // text will offset downward a little bit in font "Microsoft YaHei".

  setCtx(ctx, 'textBaseline', 'middle');
  setCtx(ctx, 'font', token.font || DEFAULT_FONT);
  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
  var textFill = getFill(tokenStyle.textFill || style.textFill);
  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

  if (textStroke) {
    setCtx(ctx, 'lineWidth', textStrokeWidth);
    setCtx(ctx, 'strokeStyle', textStroke);
    ctx.strokeText(token.text, x, y);
  }

  if (textFill) {
    setCtx(ctx, 'fillStyle', textFill);
    ctx.fillText(token.text, x, y);
  }
}

function needDrawBackground(style) {
  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}
// shape: {x, y, width, height}


function drawBackground(hostEl, ctx, style, x, y, width, height) {
  var textBackgroundColor = style.textBackgroundColor;
  var textBorderWidth = style.textBorderWidth;
  var textBorderColor = style.textBorderColor;
  var isPlainBg = isString(textBackgroundColor);
  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

  if (isPlainBg || textBorderWidth && textBorderColor) {
    ctx.beginPath();
    var textBorderRadius = style.textBorderRadius;

    if (!textBorderRadius) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, {
        x: x,
        y: y,
        width: width,
        height: height,
        r: textBorderRadius
      });
    }

    ctx.closePath();
  }

  if (isPlainBg) {
    setCtx(ctx, 'fillStyle', textBackgroundColor);

    if (style.fillOpacity != null) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.fillOpacity * style.opacity;
      ctx.fill();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.fill();
    }
  } else if (isObject(textBackgroundColor)) {
    var image = textBackgroundColor.image;
    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);

    if (image && imageHelper.isImageReady(image)) {
      ctx.drawImage(image, x, y, width, height);
    }
  }

  if (textBorderWidth && textBorderColor) {
    setCtx(ctx, 'lineWidth', textBorderWidth);
    setCtx(ctx, 'strokeStyle', textBorderColor);

    if (style.strokeOpacity != null) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.strokeOpacity * style.opacity;
      ctx.stroke();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.stroke();
    }
  }
}

function onBgImageLoaded(image, textBackgroundColor) {
  // Replace image, so that `contain/text.js#parseRichText`
  // will get correct result in next tick.
  textBackgroundColor.image = image;
}

function getBoxPosition(out, hostEl, style, rect) {
  var baseX = style.x || 0;
  var baseY = style.y || 0;
  var textAlign = style.textAlign;
  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

  if (rect) {
    var textPosition = style.textPosition;

    if (textPosition instanceof Array) {
      // Percent
      baseX = rect.x + parsePercent(textPosition[0], rect.width);
      baseY = rect.y + parsePercent(textPosition[1], rect.height);
    } else {
      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);
      baseX = res.x;
      baseY = res.y; // Default align and baseline when has textPosition

      textAlign = textAlign || res.textAlign;
      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
    } // textOffset is only support in RectText, otherwise
    // we have to adjust boundingRect for textOffset.


    var textOffset = style.textOffset;

    if (textOffset) {
      baseX += textOffset[0];
      baseY += textOffset[1];
    }
  }

  out = out || {};
  out.baseX = baseX;
  out.baseY = baseY;
  out.textAlign = textAlign;
  out.textVerticalAlign = textVerticalAlign;
  return out;
}

function setCtx(ctx, prop, value) {
  ctx[prop] = fixShadow(ctx, prop, value);
  return ctx[prop];
}
/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */


function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
  : stroke.image || stroke.colorStops ? '#000' : stroke;
}

function getFill(fill) {
  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
  : fill.image || fill.colorStops ? '#000' : fill;
}

function parsePercent(value, maxValue) {
  if (typeof value === 'string') {
    if (value.lastIndexOf('%') >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }

    return parseFloat(value);
  }

  return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */


function needDrawText(text, style) {
  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}

exports.normalizeTextStyle = normalizeTextStyle;
exports.renderText = renderText;
exports.getBoxPosition = getBoxPosition;
exports.getStroke = getStroke;
exports.getFill = getFill;
exports.parsePercent = parsePercent;
exports.needDrawText = needDrawText;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/mixin/RectText.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/mixin/RectText.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var textHelper = __webpack_require__(/*! ../helper/text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js");

var BoundingRect = __webpack_require__(/*! ../../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var _constant = __webpack_require__(/*! ../constant */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/constant.js");

var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;

/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */
var tmpRect = new BoundingRect();

var RectText = function () {};

RectText.prototype = {
  constructor: RectText,

  /**
   * Draw text in a rect with specified position.
   * @param  {CanvasRenderingContext2D} ctx
   * @param  {Object} rect Displayable rect
   */
  drawRectText: function (ctx, rect) {
    var style = this.style;
    rect = style.textRect || rect; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null && (text += '');

    if (!textHelper.needDrawText(text, style)) {
      return;
    } // FIXME
    // Do not provide prevEl to `textHelper.renderText` for ctx prop cache,
    // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect
    // text propably break the cache for its host elements.


    ctx.save(); // Transform rect to view space

    var transform = this.transform;

    if (!style.transformText) {
      if (transform) {
        tmpRect.copy(rect);
        tmpRect.applyTransform(transform);
        rect = tmpRect;
      }
    } else {
      this.setTransform(ctx);
    } // transformText and textRotation can not be used at the same time.


    textHelper.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED);
    ctx.restore();
  }
};
var _default = RectText;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Arc.js":
/*!**********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Arc.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 圆弧
 * @module zrender/graphic/shape/Arc
 */
var _default = Path.extend({
  type: 'arc',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/BezierCurve.js":
/*!******************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/BezierCurve.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var vec2 = __webpack_require__(/*! ../../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var _curve = __webpack_require__(/*! ../../core/curve */ "./node_modules/_zrender@4.3.2@zrender/lib/core/curve.js");

var quadraticSubdivide = _curve.quadraticSubdivide;
var cubicSubdivide = _curve.cubicSubdivide;
var quadraticAt = _curve.quadraticAt;
var cubicAt = _curve.cubicAt;
var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
var cubicDerivativeAt = _curve.cubicDerivativeAt;

/**
 * 贝塞尔曲线
 * @module zrender/shape/BezierCurve
 */
var out = [];

function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;

  if (cpx2 === null || cpy2 === null) {
    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
  } else {
    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
  }
}

var _default = Path.extend({
  type: 'bezier-curve',
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    cpx1: 0,
    cpy1: 0,
    // cpx2: 0,
    // cpy2: 0
    // Curve show percent, for animating
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }

      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }

      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  },

  /**
   * Get point at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  pointAt: function (t) {
    return someVectorAt(this.shape, t, false);
  },

  /**
   * Get tangent at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  tangentAt: function (t) {
    var p = someVectorAt(this.shape, t, true);
    return vec2.normalize(p, p);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Circle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Circle.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 圆形
 * @module zrender/shape/Circle
 */
var _default = Path.extend({
  type: 'circle',
  shape: {
    cx: 0,
    cy: 0,
    r: 0
  },
  buildPath: function (ctx, shape, inBundle) {
    // Better stroking in ShapeBundle
    // Always do it may have performence issue ( fill may be 2x more cost)
    if (inBundle) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
    } // else {
    //     if (ctx.allocate && !ctx.data.length) {
    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
    //     }
    // }
    // Better stroking in ShapeBundle
    // ctx.moveTo(shape.cx + shape.r, shape.cy);


    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Droplet.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Droplet.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 水滴形状
 * @module zrender/graphic/shape/Droplet
 */
var _default = Path.extend({
  type: 'droplet',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var a = shape.width;
    var b = shape.height;
    ctx.moveTo(x, y + a);
    ctx.bezierCurveTo(x + a, y + a, x + a * 3 / 2, y - a / 3, x, y - b);
    ctx.bezierCurveTo(x - a * 3 / 2, y - a / 3, x - a, y + a, x, y + a);
    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ellipse.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ellipse.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 椭圆形状
 * @module zrender/graphic/shape/Ellipse
 */
var _default = Path.extend({
  type: 'ellipse',
  shape: {
    cx: 0,
    cy: 0,
    rx: 0,
    ry: 0
  },
  buildPath: function (ctx, shape) {
    var k = 0.5522848;
    var x = shape.cx;
    var y = shape.cy;
    var a = shape.rx;
    var b = shape.ry;
    var ox = a * k; // 水平控制点偏移量

    var oy = b * k; // 垂直控制点偏移量
    // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线

    ctx.moveTo(x - a, y);
    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Heart.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Heart.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 心形
 * @module zrender/graphic/shape/Heart
 */
var _default = Path.extend({
  type: 'heart',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var a = shape.width;
    var b = shape.height;
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x + a / 2, y - b * 2 / 3, x + a * 2, y + b / 3, x, y + b);
    ctx.bezierCurveTo(x - a * 2, y + b / 3, x - a / 2, y - b * 2 / 3, x, y);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Isogon.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Isogon.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 正多边形
 * @module zrender/shape/Isogon
 */
var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;

var _default = Path.extend({
  type: 'isogon',
  shape: {
    x: 0,
    y: 0,
    r: 0,
    n: 0
  },
  buildPath: function (ctx, shape) {
    var n = shape.n;

    if (!n || n < 2) {
      return;
    }

    var x = shape.x;
    var y = shape.y;
    var r = shape.r;
    var dStep = 2 * PI / n;
    var deg = -PI / 2;
    ctx.moveTo(x + r * cos(deg), y + r * sin(deg));

    for (var i = 0, end = n - 1; i < end; i++) {
      deg += dStep;
      ctx.lineTo(x + r * cos(deg), y + r * sin(deg));
    }

    ctx.closePath();
    return;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Line.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Line.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var _subPixelOptimize = __webpack_require__(/*! ../helper/subPixelOptimize */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/subPixelOptimize.js");

var subPixelOptimizeLine = _subPixelOptimize.subPixelOptimizeLine;

/**
 * 直线
 * @module zrender/graphic/shape/Line
 */
// Avoid create repeatly.
var subPixelOptimizeOutputShape = {};

var _default = Path.extend({
  type: 'line',
  shape: {
    // Start point
    x1: 0,
    y1: 0,
    // End point
    x2: 0,
    y2: 0,
    percent: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;

    if (this.subPixelOptimize) {
      subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);
      x1 = subPixelOptimizeOutputShape.x1;
      y1 = subPixelOptimizeOutputShape.y1;
      x2 = subPixelOptimizeOutputShape.x2;
      y2 = subPixelOptimizeOutputShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }

    var percent = shape.percent;

    if (percent === 0) {
      return;
    }

    ctx.moveTo(x1, y1);

    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }

    ctx.lineTo(x2, y2);
  },

  /**
   * Get point at percent
   * @param  {number} percent
   * @return {Array.<number>}
   */
  pointAt: function (p) {
    var shape = this.shape;
    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polygon.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polygon.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__(/*! ../helper/poly */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/poly.js");

/**
 * 多边形
 * @module zrender/shape/Polygon
 */
var _default = Path.extend({
  type: 'polygon',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polyline.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polyline.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var polyHelper = __webpack_require__(/*! ../helper/poly */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/poly.js");

/**
 * @module zrender/graphic/shape/Polyline
 */
var _default = Path.extend({
  type: 'polyline',
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    polyHelper.buildPath(ctx, shape, false);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rect.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var roundRectHelper = __webpack_require__(/*! ../helper/roundRect */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/roundRect.js");

var _subPixelOptimize = __webpack_require__(/*! ../helper/subPixelOptimize */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/subPixelOptimize.js");

var subPixelOptimizeRect = _subPixelOptimize.subPixelOptimizeRect;

/**
 * 矩形
 * @module zrender/graphic/shape/Rect
 */
// Avoid create repeatly.
var subPixelOptimizeOutputShape = {};

var _default = Path.extend({
  type: 'rect',
  shape: {
    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
    // r缩写为1         相当于 [1, 1, 1, 1]
    // r缩写为[1]       相当于 [1, 1, 1, 1]
    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
    r: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var x;
    var y;
    var width;
    var height;

    if (this.subPixelOptimize) {
      subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
      x = subPixelOptimizeOutputShape.x;
      y = subPixelOptimizeOutputShape.y;
      width = subPixelOptimizeOutputShape.width;
      height = subPixelOptimizeOutputShape.height;
      subPixelOptimizeOutputShape.r = shape.r;
      shape = subPixelOptimizeOutputShape;
    } else {
      x = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }

    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, shape);
    }

    ctx.closePath();
    return;
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ring.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 圆环
 * @module zrender/graphic/shape/Ring
 */
var _default = Path.extend({
  type: 'ring',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0
  },
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI2 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI2, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI2, true);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rose.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rose.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 玫瑰线
 * @module zrender/graphic/shape/Rose
 */
var sin = Math.sin;
var cos = Math.cos;
var radian = Math.PI / 180;

var _default = Path.extend({
  type: 'rose',
  shape: {
    cx: 0,
    cy: 0,
    r: [],
    k: 0,
    n: 1
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x;
    var y;
    var R = shape.r;
    var r;
    var k = shape.k;
    var n = shape.n;
    var x0 = shape.cx;
    var y0 = shape.cy;
    ctx.moveTo(x0, y0);

    for (var i = 0, len = R.length; i < len; i++) {
      r = R[i];

      for (var j = 0; j <= 360 * n; j++) {
        x = r * sin(k / n * j % 360 * radian) * cos(j * radian) + x0;
        y = r * sin(k / n * j % 360 * radian) * sin(j * radian) + y0;
        ctx.lineTo(x, y);
      }
    }
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Sector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Sector.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var fixClipWithShadow = __webpack_require__(/*! ../helper/fixClipWithShadow */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/fixClipWithShadow.js");

/**
 * 扇形
 * @module zrender/graphic/shape/Sector
 */
var _default = Path.extend({
  type: 'sector',
  shape: {
    cx: 0,
    cy: 0,
    r0: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  brush: fixClipWithShadow(Path.prototype.brush),
  buildPath: function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
    ctx.lineTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
    }

    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Star.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Star.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * n角星（n>3）
 * @module zrender/graphic/shape/Star
 */
var PI = Math.PI;
var cos = Math.cos;
var sin = Math.sin;

var _default = Path.extend({
  type: 'star',
  shape: {
    cx: 0,
    cy: 0,
    n: 3,
    r0: null,
    r: 0
  },
  buildPath: function (ctx, shape) {
    var n = shape.n;

    if (!n || n < 2) {
      return;
    }

    var x = shape.cx;
    var y = shape.cy;
    var r = shape.r;
    var r0 = shape.r0; // 如果未指定内部顶点外接圆半径，则自动计算

    if (r0 == null) {
      r0 = n > 4 // 相隔的外部顶点的连线的交点，
      // 被取为内部交点，以此计算r0
      ? r * cos(2 * PI / n) / cos(PI / n) // 二三四角星的特殊处理
      : r / 3;
    }

    var dStep = PI / n;
    var deg = -PI / 2;
    var xStart = x + r * cos(deg);
    var yStart = y + r * sin(deg);
    deg += dStep; // 记录边界点，用于判断inside

    ctx.moveTo(xStart, yStart);

    for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
      ri = i % 2 === 0 ? r0 : r;
      ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
      deg += dStep;
    }

    ctx.closePath();
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Trochoid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Trochoid.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

/**
 * 内外旋轮曲线
 * @module zrender/graphic/shape/Trochold
 */
var cos = Math.cos;
var sin = Math.sin;

var _default = Path.extend({
  type: 'trochoid',
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0,
    d: 0,
    location: 'out'
  },
  style: {
    stroke: '#000',
    fill: null
  },
  buildPath: function (ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;
    var R = shape.r;
    var r = shape.r0;
    var d = shape.d;
    var offsetX = shape.cx;
    var offsetY = shape.cy;
    var delta = shape.location === 'out' ? 1 : -1;

    if (shape.location && R <= r) {
      return;
    }

    var num = 0;
    var i = 1;
    var theta;
    x1 = (R + delta * r) * cos(0) - delta * d * cos(0) + offsetX;
    y1 = (R + delta * r) * sin(0) - d * sin(0) + offsetY;
    ctx.moveTo(x1, y1); // 计算结束时的i

    do {
      num++;
    } while (r * num % (R + delta * r) !== 0);

    do {
      theta = Math.PI / 180 * i;
      x2 = (R + delta * r) * cos(theta) - delta * d * cos((R / r + delta) * theta) + offsetX;
      y2 = (R + delta * r) * sin(theta) - d * sin((R / r + delta) * theta) + offsetY;
      ctx.lineTo(x2, y2);
      i++;
    } while (i <= r * num / (R + delta * r) * 360);
  }
});

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Animatable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/mixin/Animatable.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Animator = __webpack_require__(/*! ../animation/Animator */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Animator.js");

var logError = __webpack_require__(/*! ../core/log */ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js");

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var isString = _util.isString;
var isFunction = _util.isFunction;
var isObject = _util.isObject;
var isArrayLike = _util.isArrayLike;
var indexOf = _util.indexOf;

/**
 * @alias module:zrender/mixin/Animatable
 * @constructor
 */
var Animatable = function () {
  /**
   * @type {Array.<module:zrender/animation/Animator>}
   * @readOnly
   */
  this.animators = [];
};

Animatable.prototype = {
  constructor: Animatable,

  /**
   * 动画
   *
   * @param {string} path The path to fetch value from object, like 'a.b.c'.
   * @param {boolean} [loop] Whether to loop animation.
   * @return {module:zrender/animation/Animator}
   * @example:
   *     el.animate('style', false)
   *         .when(1000, {x: 10} )
   *         .done(function(){ // Animation done })
   *         .start()
   */
  animate: function (path, loop) {
    var target;
    var animatingShape = false;
    var el = this;
    var zr = this.__zr;

    if (path) {
      var pathSplitted = path.split('.');
      var prop = el; // If animating shape

      animatingShape = pathSplitted[0] === 'shape';

      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }

        prop = prop[pathSplitted[i]];
      }

      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }

    if (!target) {
      logError('Property "' + path + '" is not existed in element ' + el.id);
      return;
    }

    var animators = el.animators;
    var animator = new Animator(target, loop);
    animator.during(function (target) {
      el.dirty(animatingShape);
    }).done(function () {
      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
      animators.splice(indexOf(animators, animator), 1);
    });
    animators.push(animator); // If animate after added to the zrender

    if (zr) {
      zr.animation.addAnimator(animator);
    }

    return animator;
  },

  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stopAnimation: function (forwardToLast) {
    var animators = this.animators;
    var len = animators.length;

    for (var i = 0; i < len; i++) {
      animators[i].stop(forwardToLast);
    }

    animators.length = 0;
    return this;
  },

  /**
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   * @param {Object} target
   * @param {number} [time=500] Time in ms
   * @param {string} [easing='linear']
   * @param {number} [delay=0]
   * @param {Function} [callback]
   * @param {Function} [forceAnimate] Prevent stop animation and callback
   *        immediently when target values are the same as current values.
   *
   * @example
   *  // Animate position
   *  el.animateTo({
   *      position: [10, 10]
   *  }, function () { // done })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
   *  el.animateTo({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100, 'cubicOut', function () { // done })
   */
  // TODO Return animation key
  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
    animateTo(this, target, time, delay, easing, callback, forceAnimate);
  },

  /**
   * Animate from the target state to current state.
   * The params and the return value are the same as `this.animateTo`.
   */
  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {
    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
  }
};

function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
  // animateTo(target, time, easing, callback);
  if (isString(delay)) {
    callback = easing;
    easing = delay;
    delay = 0;
  } // animateTo(target, time, delay, callback);
  else if (isFunction(easing)) {
      callback = easing;
      easing = 'linear';
      delay = 0;
    } // animateTo(target, time, callback);
    else if (isFunction(delay)) {
        callback = delay;
        delay = 0;
      } // animateTo(target, callback)
      else if (isFunction(time)) {
          callback = time;
          time = 500;
        } // animateTo(target)
        else if (!time) {
            time = 500;
          } // Stop all previous animations


  animatable.stopAnimation();
  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start
  // if there is nothing to animate

  var animators = animatable.animators.slice();
  var count = animators.length;

  function done() {
    count--;

    if (!count) {
      callback && callback();
    }
  } // No animators. This should be checked before animators[i].start(),
  // because 'done' may be executed immediately if no need to animate.


  if (!count) {
    callback && callback();
  } // Start after all animators created
  // Incase any animator is done immediately when all animation properties are not changed


  for (var i = 0; i < animators.length; i++) {
    animators[i].done(done).start(easing, forceAnimate);
  }
}
/**
 * @param {string} path=''
 * @param {Object} source=animatable
 * @param {Object} target
 * @param {number} [time=500]
 * @param {number} [delay=0]
 * @param {boolean} [reverse] If `true`, animate
 *        from the `target` to current state.
 *
 * @example
 *  // Animate position
 *  el._animateToShallow({
 *      position: [10, 10]
 *  })
 *
 *  // Animate shape, style and position in 100ms, delayed 100ms
 *  el._animateToShallow({
 *      shape: {
 *          width: 500
 *      },
 *      style: {
 *          fill: 'red'
 *      }
 *      position: [10, 10]
 *  }, 100, 100)
 */


function animateToShallow(animatable, path, source, target, time, delay, reverse) {
  var objShallow = {};
  var propertyCount = 0;

  for (var name in target) {
    if (!target.hasOwnProperty(name)) {
      continue;
    }

    if (source[name] != null) {
      if (isObject(target[name]) && !isArrayLike(target[name])) {
        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);
      } else {
        if (reverse) {
          objShallow[name] = source[name];
          setAttrByPath(animatable, path, name, target[name]);
        } else {
          objShallow[name] = target[name];
        }

        propertyCount++;
      }
    } else if (target[name] != null && !reverse) {
      setAttrByPath(animatable, path, name, target[name]);
    }
  }

  if (propertyCount > 0) {
    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
  }
}

function setAttrByPath(el, path, name, value) {
  // Attr directly if not has property
  // FIXME, if some property not needed for element ?
  if (!path) {
    el.attr(name, value);
  } else {
    // Only support set shape or style
    var props = {};
    props[path] = {};
    props[path][name] = value;
    el.attr(props);
  }
}

var _default = Animatable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Draggable.js":
/*!********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/mixin/Draggable.js ***!
  \********************************************************************/
/***/ ((module) => {

// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable() {
  this.on('mousedown', this._dragStart, this);
  this.on('mousemove', this._drag, this);
  this.on('mouseup', this._dragEnd, this); // `mosuemove` and `mouseup` can be continue to fire when dragging.
  // See [Drag outside] in `Handler.js`. So we do not need to trigger
  // `_dragEnd` when globalout. That would brings better user experience.
  // this.on('globalout', this._dragEnd, this);
  // this._dropTarget = null;
  // this._draggingTarget = null;
  // this._x = 0;
  // this._y = 0;
}

Draggable.prototype = {
  constructor: Draggable,
  _dragStart: function (e) {
    var draggingTarget = e.target; // Find if there is draggable in the ancestor

    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent;
    }

    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e.offsetX;
      this._y = e.offsetY;
      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
    }
  },
  _drag: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      var x = e.offsetX;
      var y = e.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e);
      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
      var dropTarget = this.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;

      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
        }

        if (dropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
        }
      }
    }
  },
  _dragEnd: function (e) {
    var draggingTarget = this._draggingTarget;

    if (draggingTarget) {
      draggingTarget.dragging = false;
    }

    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

    if (this._dropTarget) {
      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
    }

    this._draggingTarget = null;
    this._dropTarget = null;
  }
};

function param(target, e) {
  return {
    target: target,
    topTarget: e && e.topTarget
  };
}

var _default = Draggable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js":
/*!*******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/mixin/Eventful.js ***!
  \*******************************************************************/
/***/ ((module) => {

/**
 * Event Mixin
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
var arrySlice = Array.prototype.slice;
/**
 * Event dispatcher.
 *
 * @alias module:zrender/mixin/Eventful
 * @constructor
 * @param {Object} [eventProcessor] The object eventProcessor is the scope when
 *        `eventProcessor.xxx` called.
 * @param {Function} [eventProcessor.normalizeQuery]
 *        param: {string|Object} Raw query.
 *        return: {string|Object} Normalized query.
 * @param {Function} [eventProcessor.filter] Event will be dispatched only
 *        if it returns `true`.
 *        param: {string} eventType
 *        param: {string|Object} query
 *        return: {boolean}
 * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.
 *        param: {string} eventType
 */

var Eventful = function (eventProcessor) {
  this._$handlers = {};
  this._$eventProcessor = eventProcessor;
};

Eventful.prototype = {
  constructor: Eventful,

  /**
   * The handler can only be triggered once, then removed.
   *
   * @param {string} event The event name.
   * @param {string|Object} [query] Condition used on event filter.
   * @param {Function} handler The event handler.
   * @param {Object} context
   */
  one: function (event, query, handler, context) {
    return on(this, event, query, handler, context, true);
  },

  /**
   * Bind a handler.
   *
   * @param {string} event The event name.
   * @param {string|Object} [query] Condition used on event filter.
   * @param {Function} handler The event handler.
   * @param {Object} [context]
   */
  on: function (event, query, handler, context) {
    return on(this, event, query, handler, context, false);
  },

  /**
   * Whether any handler has bound.
   *
   * @param  {string}  event
   * @return {boolean}
   */
  isSilent: function (event) {
    var _h = this._$handlers;
    return !_h[event] || !_h[event].length;
  },

  /**
   * Unbind a event.
   *
   * @param {string} [event] The event name.
   *        If no `event` input, "off" all listeners.
   * @param {Function} [handler] The event handler.
   *        If no `handler` input, "off" all listeners of the `event`.
   */
  off: function (event, handler) {
    var _h = this._$handlers;

    if (!event) {
      this._$handlers = {};
      return this;
    }

    if (handler) {
      if (_h[event]) {
        var newList = [];

        for (var i = 0, l = _h[event].length; i < l; i++) {
          if (_h[event][i].h !== handler) {
            newList.push(_h[event][i]);
          }
        }

        _h[event] = newList;
      }

      if (_h[event] && _h[event].length === 0) {
        delete _h[event];
      }
    } else {
      delete _h[event];
    }

    return this;
  },

  /**
   * Dispatch a event.
   *
   * @param {string} type The event name.
   */
  trigger: function (type) {
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;

    if (_h) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 3) {
        args = arrySlice.call(args, 1);
      }

      var len = _h.length;

      for (var i = 0; i < len;) {
        var hItem = _h[i];

        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          i++;
          continue;
        } // Optimize advise from backbone


        switch (argLen) {
          case 1:
            hItem.h.call(hItem.ctx);
            break;

          case 2:
            hItem.h.call(hItem.ctx, args[1]);
            break;

          case 3:
            hItem.h.call(hItem.ctx, args[1], args[2]);
            break;

          default:
            // have more than 2 given arguments
            hItem.h.apply(hItem.ctx, args);
            break;
        }

        if (hItem.one) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  },

  /**
   * Dispatch a event with context, which is specified at the last parameter.
   *
   * @param {string} type The event name.
   */
  triggerWithContext: function (type) {
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;

    if (_h) {
      var args = arguments;
      var argLen = args.length;

      if (argLen > 4) {
        args = arrySlice.call(args, 1, args.length - 1);
      }

      var ctx = args[args.length - 1];
      var len = _h.length;

      for (var i = 0; i < len;) {
        var hItem = _h[i];

        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          i++;
          continue;
        } // Optimize advise from backbone


        switch (argLen) {
          case 1:
            hItem.h.call(ctx);
            break;

          case 2:
            hItem.h.call(ctx, args[1]);
            break;

          case 3:
            hItem.h.call(ctx, args[1], args[2]);
            break;

          default:
            // have more than 2 given arguments
            hItem.h.apply(ctx, args);
            break;
        }

        if (hItem.one) {
          _h.splice(i, 1);

          len--;
        } else {
          i++;
        }
      }
    }

    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  }
};

function normalizeQuery(host, query) {
  var eventProcessor = host._$eventProcessor;

  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
    query = eventProcessor.normalizeQuery(query);
  }

  return query;
}

function on(eventful, event, query, handler, context, isOnce) {
  var _h = eventful._$handlers;

  if (typeof query === 'function') {
    context = handler;
    handler = query;
    query = null;
  }

  if (!handler || !event) {
    return eventful;
  }

  query = normalizeQuery(eventful, query);

  if (!_h[event]) {
    _h[event] = [];
  }

  for (var i = 0; i < _h[event].length; i++) {
    if (_h[event][i].h === handler) {
      return eventful;
    }
  }

  var wrap = {
    h: handler,
    one: isOnce,
    query: query,
    ctx: context || eventful,
    // FIXME
    // Do not publish this feature util it is proved that it makes sense.
    callAtLast: handler.zrEventfulCallAtLast
  };
  var lastIndex = _h[event].length - 1;
  var lastWrap = _h[event][lastIndex];
  lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
  return eventful;
} // ----------------------
// The events in zrender
// ----------------------

/**
 * @event module:zrender/mixin/Eventful#onclick
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseout
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousemove
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousewheel
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmousedown
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#onmouseup
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrag
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragstart
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragend
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragenter
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragleave
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondragover
 * @type {Function}
 * @default null
 */

/**
 * @event module:zrender/mixin/Eventful#ondrop
 * @type {Function}
 * @default null
 */


var _default = Eventful;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/mixin/Transformable.js":
/*!************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/mixin/Transformable.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var matrix = __webpack_require__(/*! ../core/matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

var vector = __webpack_require__(/*! ../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */
var mIdentity = matrix.identity;
var EPSILON = 5e-5;

function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */


var Transformable = function (opts) {
  opts = opts || {}; // If there are no given position, rotation, scale

  if (!opts.position) {
    /**
     * 平移
     * @type {Array.<number>}
     * @default [0, 0]
     */
    this.position = [0, 0];
  }

  if (opts.rotation == null) {
    /**
     * 旋转
     * @type {Array.<number>}
     * @default 0
     */
    this.rotation = 0;
  }

  if (!opts.scale) {
    /**
     * 缩放
     * @type {Array.<number>}
     * @default [1, 1]
     */
    this.scale = [1, 1];
  }
  /**
   * 旋转和缩放的原点
   * @type {Array.<number>}
   * @default null
   */


  this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;
/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */

transformableProto.needLocalTransform = function () {
  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
};

var scaleTmp = [];

transformableProto.updateTransform = function () {
  var parent = this.parent;
  var parentHasTransform = parent && parent.transform;
  var needLocalTransform = this.needLocalTransform();
  var m = this.transform;

  if (!(needLocalTransform || parentHasTransform)) {
    m && mIdentity(m);
    return;
  }

  m = m || matrix.create();

  if (needLocalTransform) {
    this.getLocalTransform(m);
  } else {
    mIdentity(m);
  } // 应用父节点变换


  if (parentHasTransform) {
    if (needLocalTransform) {
      matrix.mul(m, parent.transform, m);
    } else {
      matrix.copy(m, parent.transform);
    }
  } // 保存这个变换矩阵


  this.transform = m;
  var globalScaleRatio = this.globalScaleRatio;

  if (globalScaleRatio != null && globalScaleRatio !== 1) {
    this.getGlobalScale(scaleTmp);
    var relX = scaleTmp[0] < 0 ? -1 : 1;
    var relY = scaleTmp[1] < 0 ? -1 : 1;
    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
    m[0] *= sx;
    m[1] *= sx;
    m[2] *= sy;
    m[3] *= sy;
  }

  this.invTransform = this.invTransform || matrix.create();
  matrix.invert(this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
  return Transformable.getLocalTransform(this, m);
};
/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */


transformableProto.setTransform = function (ctx) {
  var m = this.transform;
  var dpr = ctx.dpr || 1;

  if (m) {
    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
  } else {
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
};

transformableProto.restoreTransform = function (ctx) {
  var dpr = ctx.dpr || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];
var originTransform = matrix.create();

transformableProto.setLocalTransform = function (m) {
  if (!m) {
    // TODO return or set identity?
    return;
  }

  var sx = m[0] * m[0] + m[1] * m[1];
  var sy = m[2] * m[2] + m[3] * m[3];
  var position = this.position;
  var scale = this.scale;

  if (isNotAroundZero(sx - 1)) {
    sx = Math.sqrt(sx);
  }

  if (isNotAroundZero(sy - 1)) {
    sy = Math.sqrt(sy);
  }

  if (m[0] < 0) {
    sx = -sx;
  }

  if (m[3] < 0) {
    sy = -sy;
  }

  position[0] = m[4];
  position[1] = m[5];
  scale[0] = sx;
  scale[1] = sy;
  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};
/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */


transformableProto.decomposeTransform = function () {
  if (!this.transform) {
    return;
  }

  var parent = this.parent;
  var m = this.transform;

  if (parent && parent.transform) {
    // Get local transform and decompose them to position, scale, rotation
    matrix.mul(tmpTransform, parent.invTransform, m);
    m = tmpTransform;
  }

  var origin = this.origin;

  if (origin && (origin[0] || origin[1])) {
    originTransform[4] = origin[0];
    originTransform[5] = origin[1];
    matrix.mul(tmpTransform, m, originTransform);
    tmpTransform[4] -= origin[0];
    tmpTransform[5] -= origin[1];
    m = tmpTransform;
  }

  this.setLocalTransform(m);
};
/**
 * Get global scale
 * @return {Array.<number>}
 */


transformableProto.getGlobalScale = function (out) {
  var m = this.transform;
  out = out || [];

  if (!m) {
    out[0] = 1;
    out[1] = 1;
    return out;
  }

  out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
  out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

  if (m[0] < 0) {
    out[0] = -out[0];
  }

  if (m[3] < 0) {
    out[1] = -out[1];
  }

  return out;
};
/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToLocal = function (x, y) {
  var v2 = [x, y];
  var invTransform = this.invTransform;

  if (invTransform) {
    vector.applyTransform(v2, v2, invTransform);
  }

  return v2;
};
/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */


transformableProto.transformCoordToGlobal = function (x, y) {
  var v2 = [x, y];
  var transform = this.transform;

  if (transform) {
    vector.applyTransform(v2, v2, transform);
  }

  return v2;
};
/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */


Transformable.getLocalTransform = function (target, m) {
  m = m || [];
  mIdentity(m);
  var origin = target.origin;
  var scale = target.scale || [1, 1];
  var rotation = target.rotation || 0;
  var position = target.position || [0, 0];

  if (origin) {
    // Translate to origin
    m[4] -= origin[0];
    m[5] -= origin[1];
  }

  matrix.scale(m, m, scale);

  if (rotation) {
    matrix.rotate(m, m, rotation);
  }

  if (origin) {
    // Translate back from origin
    m[4] += origin[0];
    m[5] += origin[1];
  }

  m[4] += position[0];
  m[5] += position[1];
  return m;
};

var _default = Transformable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/Painter.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/Painter.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _core = __webpack_require__(/*! ./core */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/core.js");

var createElement = _core.createElement;

var util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var logError = __webpack_require__(/*! ../core/log */ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js");

var Path = __webpack_require__(/*! ../graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var ZImage = __webpack_require__(/*! ../graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

var ZText = __webpack_require__(/*! ../graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

var arrayDiff = __webpack_require__(/*! ../core/arrayDiff2 */ "./node_modules/_zrender@4.3.2@zrender/lib/core/arrayDiff2.js");

var GradientManager = __webpack_require__(/*! ./helper/GradientManager */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/GradientManager.js");

var ClippathManager = __webpack_require__(/*! ./helper/ClippathManager */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ClippathManager.js");

var ShadowManager = __webpack_require__(/*! ./helper/ShadowManager */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ShadowManager.js");

var _graphic = __webpack_require__(/*! ./graphic */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/graphic.js");

var svgPath = _graphic.path;
var svgImage = _graphic.image;
var svgText = _graphic.text;

/**
 * SVG Painter
 * @module zrender/svg/Painter
 */
function parseInt10(val) {
  return parseInt(val, 10);
}

function getSvgProxy(el) {
  if (el instanceof Path) {
    return svgPath;
  } else if (el instanceof ZImage) {
    return svgImage;
  } else if (el instanceof ZText) {
    return svgText;
  } else {
    return svgPath;
  }
}

function checkParentAvailable(parent, child) {
  return child && parent && child.parentNode !== parent;
}

function insertAfter(parent, child, prevSibling) {
  if (checkParentAvailable(parent, child) && prevSibling) {
    var nextSibling = prevSibling.nextSibling;
    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
  }
}

function prepend(parent, child) {
  if (checkParentAvailable(parent, child)) {
    var firstChild = parent.firstChild;
    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
  }
} // function append(parent, child) {
//     if (checkParentAvailable(parent, child)) {
//         parent.appendChild(child);
//     }
// }


function remove(parent, child) {
  if (child && parent && child.parentNode === parent) {
    parent.removeChild(child);
  }
}

function getTextSvgElement(displayable) {
  return displayable.__textSvgEl;
}

function getSvgElement(displayable) {
  return displayable.__svgEl;
}
/**
 * @alias module:zrender/svg/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */


var SVGPainter = function (root, storage, opts, zrId) {
  this.root = root;
  this.storage = storage;
  this._opts = opts = util.extend({}, opts || {});
  var svgDom = createElement('svg');
  svgDom.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  svgDom.setAttribute('version', '1.1');
  svgDom.setAttribute('baseProfile', 'full');
  svgDom.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';
  var bgRoot = createElement('g');
  svgDom.appendChild(bgRoot);
  var svgRoot = createElement('g');
  svgDom.appendChild(svgRoot);
  this.gradientManager = new GradientManager(zrId, svgRoot);
  this.clipPathManager = new ClippathManager(zrId, svgRoot);
  this.shadowManager = new ShadowManager(zrId, svgRoot);
  var viewport = document.createElement('div');
  viewport.style.cssText = 'overflow:hidden;position:relative';
  this._svgDom = svgDom;
  this._svgRoot = svgRoot;
  this._backgroundRoot = bgRoot;
  this._viewport = viewport;
  root.appendChild(viewport);
  viewport.appendChild(svgDom);
  this.resize(opts.width, opts.height);
  this._visibleList = [];
};

SVGPainter.prototype = {
  constructor: SVGPainter,
  getType: function () {
    return 'svg';
  },
  getViewportRoot: function () {
    return this._viewport;
  },
  getSvgDom: function () {
    return this._svgDom;
  },
  getSvgRoot: function () {
    return this._svgRoot;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },
  refresh: function () {
    var list = this.storage.getDisplayList(true);

    this._paintList(list);
  },
  setBackgroundColor: function (backgroundColor) {
    // TODO gradient
    // Insert a bg rect instead of setting background to viewport.
    // Otherwise, the exported SVG don't have background.
    if (this._backgroundRoot && this._backgroundNode) {
      this._backgroundRoot.removeChild(this._backgroundNode);
    }

    var bgNode = createElement('rect');
    bgNode.setAttribute('width', this.getWidth());
    bgNode.setAttribute('height', this.getHeight());
    bgNode.setAttribute('x', 0);
    bgNode.setAttribute('y', 0);
    bgNode.setAttribute('id', 0);
    bgNode.style.fill = backgroundColor;

    this._backgroundRoot.appendChild(bgNode);

    this._backgroundNode = bgNode;
  },
  _paintList: function (list) {
    this.gradientManager.markAllUnused();
    this.clipPathManager.markAllUnused();
    this.shadowManager.markAllUnused();
    var svgRoot = this._svgRoot;
    var visibleList = this._visibleList;
    var listLen = list.length;
    var newVisibleList = [];
    var i;

    for (i = 0; i < listLen; i++) {
      var displayable = list[i];
      var svgProxy = getSvgProxy(displayable);
      var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);

      if (!displayable.invisible) {
        if (displayable.__dirty) {
          svgProxy && svgProxy.brush(displayable); // Update clipPath

          this.clipPathManager.update(displayable); // Update gradient and shadow

          if (displayable.style) {
            this.gradientManager.update(displayable.style.fill);
            this.gradientManager.update(displayable.style.stroke);
            this.shadowManager.update(svgElement, displayable);
          }

          displayable.__dirty = false;
        }

        newVisibleList.push(displayable);
      }
    }

    var diff = arrayDiff(visibleList, newVisibleList);
    var prevSvgElement; // First do remove, in case element moved to the head and do remove
    // after add

    for (i = 0; i < diff.length; i++) {
      var item = diff[i];

      if (item.removed) {
        for (var k = 0; k < item.count; k++) {
          var displayable = visibleList[item.indices[k]];
          var svgElement = getSvgElement(displayable);
          var textSvgElement = getTextSvgElement(displayable);
          remove(svgRoot, svgElement);
          remove(svgRoot, textSvgElement);
        }
      }
    }

    for (i = 0; i < diff.length; i++) {
      var item = diff[i];

      if (item.added) {
        for (var k = 0; k < item.count; k++) {
          var displayable = newVisibleList[item.indices[k]];
          var svgElement = getSvgElement(displayable);
          var textSvgElement = getTextSvgElement(displayable);
          prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);

          if (svgElement) {
            insertAfter(svgRoot, textSvgElement, svgElement);
          } else if (prevSvgElement) {
            insertAfter(svgRoot, textSvgElement, prevSvgElement);
          } else {
            prepend(svgRoot, textSvgElement);
          } // Insert text


          insertAfter(svgRoot, textSvgElement, svgElement);
          prevSvgElement = textSvgElement || svgElement || prevSvgElement; // zrender.Text only create textSvgElement.

          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
          this.clipPathManager.markUsed(displayable);
        }
      } else if (!item.removed) {
        for (var k = 0; k < item.count; k++) {
          var displayable = newVisibleList[item.indices[k]];
          var svgElement = getSvgElement(displayable);
          var textSvgElement = getTextSvgElement(displayable);
          var svgElement = getSvgElement(displayable);
          var textSvgElement = getTextSvgElement(displayable);
          this.gradientManager.markUsed(displayable);
          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
          this.shadowManager.markUsed(displayable);
          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
          this.clipPathManager.markUsed(displayable);

          if (textSvgElement) {
            // Insert text.
            insertAfter(svgRoot, textSvgElement, svgElement);
          }

          prevSvgElement = svgElement || textSvgElement || prevSvgElement;
        }
      }
    }

    this.gradientManager.removeUnused();
    this.clipPathManager.removeUnused();
    this.shadowManager.removeUnused();
    this._visibleList = newVisibleList;
  },
  _getDefs: function (isForceCreating) {
    var svgRoot = this._svgDom;
    var defs = svgRoot.getElementsByTagName('defs');

    if (defs.length === 0) {
      // Not exist
      if (isForceCreating) {
        var defs = svgRoot.insertBefore(createElement('defs'), // Create new tag
        svgRoot.firstChild // Insert in the front of svg
        );

        if (!defs.contains) {
          // IE doesn't support contains method
          defs.contains = function (el) {
            var children = defs.children;

            if (!children) {
              return false;
            }

            for (var i = children.length - 1; i >= 0; --i) {
              if (children[i] === el) {
                return true;
              }
            }

            return false;
          };
        }

        return defs;
      } else {
        return null;
      }
    } else {
      return defs[0];
    }
  },
  resize: function (width, height) {
    var viewport = this._viewport; // FIXME Why ?

    viewport.style.display = 'none'; // Save input w/h

    var opts = this._opts;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    width = this._getSize(0);
    height = this._getSize(1);
    viewport.style.display = '';

    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      var viewportStyle = viewport.style;
      viewportStyle.width = width + 'px';
      viewportStyle.height = height + 'px';
      var svgRoot = this._svgDom; // Set width by 'svgRoot.width = width' is invalid

      svgRoot.setAttribute('width', width);
      svgRoot.setAttribute('height', height);
    }

    if (this._backgroundNode) {
      this._backgroundNode.setAttribute('width', width);

      this._backgroundNode.setAttribute('height', height);
    }
  },

  /**
   * 获取绘图区域宽度
   */
  getWidth: function () {
    return this._width;
  },

  /**
   * 获取绘图区域高度
   */
  getHeight: function () {
    return this._height;
  },
  _getSize: function (whIdx) {
    var opts = this._opts;
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];

    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh]);
    }

    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  dispose: function () {
    this.root.innerHTML = '';
    this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
  },
  clear: function () {
    if (this._viewport) {
      this.root.removeChild(this._viewport);
    }
  },
  toDataURL: function () {
    this.refresh();
    var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, '>\n\r<'));
    return 'data:image/svg+xml;charset=UTF-8,' + html;
  }
}; // Not supported methods

function createMethodNotSupport(method) {
  return function () {
    logError('In SVG mode painter not support method "' + method + '"');
  };
} // Unsuppoted methods


util.each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'pathToImage'], function (name) {
  SVGPainter.prototype[name] = createMethodNotSupport(name);
});
var _default = SVGPainter;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var svgURI = 'http://www.w3.org/2000/svg';

function createElement(name) {
  return document.createElementNS(svgURI, name);
}

exports.createElement = createElement;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/graphic.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/graphic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var _core = __webpack_require__(/*! ./core */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/core.js");

var createElement = _core.createElement;

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var matrix = __webpack_require__(/*! ../core/matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

var textContain = __webpack_require__(/*! ../contain/text */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js");

var textHelper = __webpack_require__(/*! ../graphic/helper/text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js");

var Text = __webpack_require__(/*! ../graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

// TODO
// 1. shadow
// 2. Image: sx, sy, sw, sh
var CMD = PathProxy.CMD;
var arrayJoin = Array.prototype.join;
var NONE = 'none';
var mathRound = Math.round;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;
var PI2 = Math.PI * 2;
var degree = 180 / PI;
var EPSILON = 1e-4;

function round4(val) {
  return mathRound(val * 1e4) / 1e4;
}

function isAroundZero(val) {
  return val < EPSILON && val > -EPSILON;
}

function pathHasFill(style, isText) {
  var fill = isText ? style.textFill : style.fill;
  return fill != null && fill !== NONE;
}

function pathHasStroke(style, isText) {
  var stroke = isText ? style.textStroke : style.stroke;
  return stroke != null && stroke !== NONE;
}

function setTransform(svgEl, m) {
  if (m) {
    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');
  }
}

function attr(el, key, val) {
  if (!val || val.type !== 'linear' && val.type !== 'radial') {
    // Don't set attribute for gradient, since it need new dom nodes
    el.setAttribute(key, val);
  }
}

function attrXLink(el, key, val) {
  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);
}

function bindStyle(svgEl, style, isText, el) {
  if (pathHasFill(style, isText)) {
    var fill = isText ? style.textFill : style.fill;
    fill = fill === 'transparent' ? NONE : fill;
    attr(svgEl, 'fill', fill);
    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);
  } else {
    attr(svgEl, 'fill', NONE);
  }

  if (pathHasStroke(style, isText)) {
    var stroke = isText ? style.textStroke : style.stroke;
    stroke = stroke === 'transparent' ? NONE : stroke;
    attr(svgEl, 'stroke', stroke);
    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;
    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;
    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others

    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');
    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);
    var lineDash = style.lineDash;

    if (lineDash) {
      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));
      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));
    } else {
      attr(svgEl, 'stroke-dasharray', '');
    } // PENDING


    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);
    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);
    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);
  } else {
    attr(svgEl, 'stroke', NONE);
  }
}
/***************************************************
 * PATH
 **************************************************/


function pathDataToString(path) {
  var str = [];
  var data = path.data;
  var dataLength = path.len();

  for (var i = 0; i < dataLength;) {
    var cmd = data[i++];
    var cmdStr = '';
    var nData = 0;

    switch (cmd) {
      case CMD.M:
        cmdStr = 'M';
        nData = 2;
        break;

      case CMD.L:
        cmdStr = 'L';
        nData = 2;
        break;

      case CMD.Q:
        cmdStr = 'Q';
        nData = 4;
        break;

      case CMD.C:
        cmdStr = 'C';
        nData = 6;
        break;

      case CMD.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        var psi = data[i++];
        var clockwise = data[i++];
        var dThetaPositive = Math.abs(dTheta);
        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI

        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
        var large = false;

        if (isCircle) {
          large = true;
        } else if (isAroundZero(dThetaPositive)) {
          large = false;
        } else {
          large = unifiedTheta >= PI === !!clockwise;
        }

        var x0 = round4(cx + rx * mathCos(theta));
        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same
        // We need to shift the end point with a small value
        // FIXME A better way to draw circle ?

        if (isCircle) {
          if (clockwise) {
            dTheta = PI2 - 1e-4;
          } else {
            dTheta = -PI2 + 1e-4;
          }

          large = true;

          if (i === 9) {
            // Move to (x0, y0) only when CMD.A comes at the
            // first position of a shape.
            // For instance, when drawing a ring, CMD.A comes
            // after CMD.M, so it's unnecessary to move to
            // (x0, y0).
            str.push('M', x0, y0);
          }
        }

        var x = round4(cx + rx * mathCos(theta + dTheta));
        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse

        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
        break;

      case CMD.Z:
        cmdStr = 'Z';
        break;

      case CMD.R:
        var x = round4(data[i++]);
        var y = round4(data[i++]);
        var w = round4(data[i++]);
        var h = round4(data[i++]);
        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);
        break;
    }

    cmdStr && str.push(cmdStr);

    for (var j = 0; j < nData; j++) {
      // PENDING With scale
      str.push(round4(data[i++]));
    }
  }

  return str.join(' ');
}

var svgPath = {};

svgPath.brush = function (el) {
  var style = el.style;
  var svgEl = el.__svgEl;

  if (!svgEl) {
    svgEl = createElement('path');
    el.__svgEl = svgEl;
  }

  if (!el.path) {
    el.createPathProxy();
  }

  var path = el.path;

  if (el.__dirtyPath) {
    path.beginPath();
    path.subPixelOptimize = false;
    el.buildPath(path, el.shape);
    el.__dirtyPath = false;
    var pathStr = pathDataToString(path);

    if (pathStr.indexOf('NaN') < 0) {
      // Ignore illegal path, which may happen such in out-of-range
      // data in Calendar series.
      attr(svgEl, 'd', pathStr);
    }
  }

  bindStyle(svgEl, style, false, el);
  setTransform(svgEl, el.transform);

  if (style.text != null) {
    svgTextDrawRectText(el, el.getBoundingRect());
  } else {
    removeOldTextNode(el);
  }
};
/***************************************************
 * IMAGE
 **************************************************/


var svgImage = {};

svgImage.brush = function (el) {
  var style = el.style;
  var image = style.image;

  if (image instanceof HTMLImageElement) {
    var src = image.src;
    image = src;
  }

  if (!image) {
    return;
  }

  var x = style.x || 0;
  var y = style.y || 0;
  var dw = style.width;
  var dh = style.height;
  var svgEl = el.__svgEl;

  if (!svgEl) {
    svgEl = createElement('image');
    el.__svgEl = svgEl;
  }

  if (image !== el.__imageSrc) {
    attrXLink(svgEl, 'href', image); // Caching image src

    el.__imageSrc = image;
  }

  attr(svgEl, 'width', dw);
  attr(svgEl, 'height', dh);
  attr(svgEl, 'x', x);
  attr(svgEl, 'y', y);
  setTransform(svgEl, el.transform);

  if (style.text != null) {
    svgTextDrawRectText(el, el.getBoundingRect());
  } else {
    removeOldTextNode(el);
  }
};
/***************************************************
 * TEXT
 **************************************************/


var svgText = {};

var _tmpTextHostRect = new BoundingRect();

var _tmpTextBoxPos = {};
var _tmpTextTransform = [];
var TEXT_ALIGN_TO_ANCHRO = {
  left: 'start',
  right: 'end',
  center: 'middle',
  middle: 'middle'
};
/**
 * @param {module:zrender/Element} el
 * @param {Object|boolean} [hostRect] {x, y, width, height}
 *        If set false, rect text is not used.
 */

var svgTextDrawRectText = function (el, hostRect) {
  var style = el.style;
  var elTransform = el.transform;
  var needTransformTextByHostEl = el instanceof Text || style.transformText;
  el.__dirty && textHelper.normalizeTextStyle(style, true);
  var text = style.text; // Convert to string

  text != null && (text += '');

  if (!textHelper.needDrawText(text, style)) {
    return;
  } // render empty text for svg if no text but need draw text.


  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the
  // text, transform the hostRect, by which the text is located.

  if (!needTransformTextByHostEl && elTransform) {
    _tmpTextHostRect.copy(hostRect);

    _tmpTextHostRect.applyTransform(elTransform);

    hostRect = _tmpTextHostRect;
  }

  var textSvgEl = el.__textSvgEl;

  if (!textSvgEl) {
    textSvgEl = createElement('text');
    el.__textSvgEl = textSvgEl;
  } // style.font has been normalized by `normalizeTextStyle`.


  var textSvgElStyle = textSvgEl.style;
  var font = style.font || textContain.DEFAULT_FONT;
  var computedFont = textSvgEl.__computedFont;

  if (font !== textSvgEl.__styleFont) {
    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.

    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;
  }

  var textPadding = style.textPadding;
  var textLineHeight = style.textLineHeight;
  var contentBlock = el.__textCotentBlock;

  if (!contentBlock || el.__dirtyText) {
    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
  }

  var outerHeight = contentBlock.outerHeight;
  var lineHeight = contentBlock.lineHeight;
  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);
  var baseX = _tmpTextBoxPos.baseX;
  var baseY = _tmpTextBoxPos.baseY;
  var textAlign = _tmpTextBoxPos.textAlign || 'left';
  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;
  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);
  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY; // TODO needDrawBg

  if (textPadding) {
    textX = getTextXForPadding(baseX, textAlign, textPadding);
    textY += textPadding[0];
  } // `textBaseline` is set as 'middle'.


  textY += lineHeight / 2;
  bindStyle(textSvgEl, style, true, el); // FIXME
  // Add a <style> to reset all of the text font as inherit?
  // otherwise the outer <style> may set the unexpected style.
  // Font may affect position of each tspan elements

  var canCacheByTextString = contentBlock.canCacheByTextString;
  var tspanList = el.__tspanList || (el.__tspanList = []);
  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.

  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {
    if (el.__dirtyText && tspanOriginLen) {
      for (var idx = 0; idx < tspanOriginLen; ++idx) {
        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);
      }
    }
  } else {
    el.__text = text;
    el.__canCacheByTextString = canCacheByTextString;
    var textLines = contentBlock.lines;
    var nTextLines = textLines.length;
    var idx = 0;

    for (; idx < nTextLines; idx++) {
      // Using cached tspan elements
      var tspan = tspanList[idx];
      var singleLineText = textLines[idx];

      if (!tspan) {
        tspan = tspanList[idx] = createElement('tspan');
        textSvgEl.appendChild(tspan);
        tspan.appendChild(document.createTextNode(singleLineText));
      } else if (tspan.__zrText !== singleLineText) {
        tspan.innerHTML = '';
        tspan.appendChild(document.createTextNode(singleLineText));
      }

      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);
    } // Remove unused tspan elements


    if (tspanOriginLen > nTextLines) {
      for (; idx < tspanOriginLen; idx++) {
        textSvgEl.removeChild(tspanList[idx]);
      }

      tspanList.length = nTextLines;
    }
  }
};

function setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {
  matrix.identity(_tmpTextTransform);

  if (needTransformTextByHostEl && elTransform) {
    matrix.copy(_tmpTextTransform, elTransform);
  } // textRotation only apply in RectText.


  var textRotation = style.textRotation;

  if (hostRect && textRotation) {
    var origin = style.textOrigin;

    if (origin === 'center') {
      baseX = hostRect.width / 2 + hostRect.x;
      baseY = hostRect.height / 2 + hostRect.y;
    } else if (origin) {
      baseX = origin[0] + hostRect.x;
      baseY = origin[1] + hostRect.y;
    }

    _tmpTextTransform[4] -= baseX;
    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise

    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);
    _tmpTextTransform[4] += baseX;
    _tmpTextTransform[5] += baseY;
  } // See the definition in `Style.js#textOrigin`, the default
  // origin is from the result of `getBoxPosition`.


  setTransform(textSvgEl, _tmpTextTransform);
} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;


function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}

function updateTextLocation(tspan, textAlign, x, y) {
  // Consider different font display differently in vertial align, we always
  // set vertialAlign as 'middle', and use 'y' to locate text vertically.
  attr(tspan, 'dominant-baseline', 'middle');
  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);
  attr(tspan, 'x', x);
  attr(tspan, 'y', y);
}

function removeOldTextNode(el) {
  if (el && el.__textSvgEl) {
    // textSvgEl may has no parentNode if el has been removed temporary.
    if (el.__textSvgEl.parentNode) {
      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);
    }

    el.__textSvgEl = null;
    el.__tspanList = [];
    el.__text = null;
  }
}

svgText.drawRectText = svgTextDrawRectText;

svgText.brush = function (el) {
  var style = el.style;

  if (style.text != null) {
    svgTextDrawRectText(el, false);
  } else {
    removeOldTextNode(el);
  }
};

exports.path = svgPath;
exports.image = svgImage;
exports.text = svgText;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ClippathManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ClippathManager.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Definable = __webpack_require__(/*! ./Definable */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/Definable.js");

var zrUtil = __webpack_require__(/*! ../../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var matrix = __webpack_require__(/*! ../../core/matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

/**
 * @file Manages SVG clipPath elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG clipPath elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */
function ClippathManager(zrId, svgRoot) {
  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');
}

zrUtil.inherits(ClippathManager, Definable);
/**
 * Update clipPath.
 *
 * @param {Displayable} displayable displayable element
 */

ClippathManager.prototype.update = function (displayable) {
  var svgEl = this.getSvgElement(displayable);

  if (svgEl) {
    this.updateDom(svgEl, displayable.__clipPaths, false);
  }

  var textEl = this.getTextSvgElement(displayable);

  if (textEl) {
    // Make another clipPath for text, since it's transform
    // matrix is not the same with svgElement
    this.updateDom(textEl, displayable.__clipPaths, true);
  }

  this.markUsed(displayable);
};
/**
 * Create an SVGElement of displayable and create a <clipPath> of its
 * clipPath
 *
 * @param {Displayable} parentEl  parent element
 * @param {ClipPath[]}  clipPaths clipPaths of parent element
 * @param {boolean}     isText    if parent element is Text
 */


ClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {
  if (clipPaths && clipPaths.length > 0) {
    // Has clipPath, create <clipPath> with the first clipPath
    var defs = this.getDefs(true);
    var clipPath = clipPaths[0];
    var clipPathEl;
    var id;
    var dom = isText ? '_textDom' : '_dom';

    if (clipPath[dom]) {
      // Use a dom that is already in <defs>
      id = clipPath[dom].getAttribute('id');
      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>

      if (!defs.contains(clipPathEl)) {
        // This happens when set old clipPath that has
        // been previously removed
        defs.appendChild(clipPathEl);
      }
    } else {
      // New <clipPath>
      id = 'zr' + this._zrId + '-clip-' + this.nextId;
      ++this.nextId;
      clipPathEl = this.createElement('clipPath');
      clipPathEl.setAttribute('id', id);
      defs.appendChild(clipPathEl);
      clipPath[dom] = clipPathEl;
    } // Build path and add to <clipPath>


    var svgProxy = this.getSvgProxy(clipPath);

    if (clipPath.transform && clipPath.parent.invTransform && !isText) {
      /**
       * If a clipPath has a parent with transform, the transform
       * of parent should not be considered when setting transform
       * of clipPath. So we need to transform back from parent's
       * transform, which is done by multiplying parent's inverse
       * transform.
       */
      // Store old transform
      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path

      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);
      svgProxy.brush(clipPath); // Set back transform of clipPath

      clipPath.transform = transform;
    } else {
      svgProxy.brush(clipPath);
    }

    var pathEl = this.getSvgElement(clipPath);
    clipPathEl.innerHTML = '';
    /**
     * Use `cloneNode()` here to appendChild to multiple parents,
     * which may happend when Text and other shapes are using the same
     * clipPath. Since Text will create an extra clipPath DOM due to
     * different transform rules.
     */

    clipPathEl.appendChild(pathEl.cloneNode());
    parentEl.setAttribute('clip-path', 'url(#' + id + ')');

    if (clipPaths.length > 1) {
      // Make the other clipPaths recursively
      this.updateDom(clipPathEl, clipPaths.slice(1), isText);
    }
  } else {
    // No clipPath
    if (parentEl) {
      parentEl.setAttribute('clip-path', 'none');
    }
  }
};
/**
 * Mark a single clipPath to be used
 *
 * @param {Displayable} displayable displayable element
 */


ClippathManager.prototype.markUsed = function (displayable) {
  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.

  if (displayable.__clipPaths) {
    zrUtil.each(displayable.__clipPaths, function (clipPath) {
      if (clipPath._dom) {
        Definable.prototype.markUsed.call(that, clipPath._dom);
      }

      if (clipPath._textDom) {
        Definable.prototype.markUsed.call(that, clipPath._textDom);
      }
    });
  }
};

var _default = ClippathManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/Definable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/Definable.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _core = __webpack_require__(/*! ../core */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/core.js");

var createElement = _core.createElement;

var zrUtil = __webpack_require__(/*! ../../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Path = __webpack_require__(/*! ../../graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var ZImage = __webpack_require__(/*! ../../graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

var ZText = __webpack_require__(/*! ../../graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

var _graphic = __webpack_require__(/*! ../graphic */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/graphic.js");

var svgPath = _graphic.path;
var svgImage = _graphic.image;
var svgText = _graphic.text;

/**
 * @file Manages elements that can be defined in <defs> in SVG,
 *       e.g., gradients, clip path, etc.
 * @author Zhang Wenli
 */
var MARK_UNUSED = '0';
var MARK_USED = '1';
/**
 * Manages elements that can be defined in <defs> in SVG,
 * e.g., gradients, clip path, etc.
 *
 * @class
 * @param {number}          zrId      zrender instance id
 * @param {SVGElement}      svgRoot   root of SVG document
 * @param {string|string[]} tagNames  possible tag names
 * @param {string}          markLabel label name to make if the element
 *                                    is used
 */

function Definable(zrId, svgRoot, tagNames, markLabel, domName) {
  this._zrId = zrId;
  this._svgRoot = svgRoot;
  this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;
  this._markLabel = markLabel;
  this._domName = domName || '_dom';
  this.nextId = 0;
}

Definable.prototype.createElement = createElement;
/**
 * Get the <defs> tag for svgRoot; optionally creates one if not exists.
 *
 * @param {boolean} isForceCreating if need to create when not exists
 * @return {SVGDefsElement} SVG <defs> element, null if it doesn't
 * exist and isForceCreating is false
 */

Definable.prototype.getDefs = function (isForceCreating) {
  var svgRoot = this._svgRoot;

  var defs = this._svgRoot.getElementsByTagName('defs');

  if (defs.length === 0) {
    // Not exist
    if (isForceCreating) {
      defs = svgRoot.insertBefore(this.createElement('defs'), // Create new tag
      svgRoot.firstChild // Insert in the front of svg
      );

      if (!defs.contains) {
        // IE doesn't support contains method
        defs.contains = function (el) {
          var children = defs.children;

          if (!children) {
            return false;
          }

          for (var i = children.length - 1; i >= 0; --i) {
            if (children[i] === el) {
              return true;
            }
          }

          return false;
        };
      }

      return defs;
    } else {
      return null;
    }
  } else {
    return defs[0];
  }
};
/**
 * Update DOM element if necessary.
 *
 * @param {Object|string} element style element. e.g., for gradient,
 *                                it may be '#ccc' or {type: 'linear', ...}
 * @param {Function|undefined} onUpdate update callback
 */


Definable.prototype.update = function (element, onUpdate) {
  if (!element) {
    return;
  }

  var defs = this.getDefs(false);

  if (element[this._domName] && defs.contains(element[this._domName])) {
    // Update DOM
    if (typeof onUpdate === 'function') {
      onUpdate(element);
    }
  } else {
    // No previous dom, create new
    var dom = this.add(element);

    if (dom) {
      element[this._domName] = dom;
    }
  }
};
/**
 * Add gradient dom to defs
 *
 * @param {SVGElement} dom DOM to be added to <defs>
 */


Definable.prototype.addDom = function (dom) {
  var defs = this.getDefs(true);
  defs.appendChild(dom);
};
/**
 * Remove DOM of a given element.
 *
 * @param {SVGElement} element element to remove dom
 */


Definable.prototype.removeDom = function (element) {
  var defs = this.getDefs(false);

  if (defs && element[this._domName]) {
    defs.removeChild(element[this._domName]);
    element[this._domName] = null;
  }
};
/**
 * Get DOMs of this element.
 *
 * @return {HTMLDomElement} doms of this defineable elements in <defs>
 */


Definable.prototype.getDoms = function () {
  var defs = this.getDefs(false);

  if (!defs) {
    // No dom when defs is not defined
    return [];
  }

  var doms = [];
  zrUtil.each(this._tagNames, function (tagName) {
    var tags = defs.getElementsByTagName(tagName); // Note that tags is HTMLCollection, which is array-like
    // rather than real array.
    // So `doms.concat(tags)` add tags as one object.

    doms = doms.concat([].slice.call(tags));
  });
  return doms;
};
/**
 * Mark DOMs to be unused before painting, and clear unused ones at the end
 * of the painting.
 */


Definable.prototype.markAllUnused = function () {
  var doms = this.getDoms();
  var that = this;
  zrUtil.each(doms, function (dom) {
    dom[that._markLabel] = MARK_UNUSED;
  });
};
/**
 * Mark a single DOM to be used.
 *
 * @param {SVGElement} dom DOM to mark
 */


Definable.prototype.markUsed = function (dom) {
  if (dom) {
    dom[this._markLabel] = MARK_USED;
  }
};
/**
 * Remove unused DOMs defined in <defs>
 */


Definable.prototype.removeUnused = function () {
  var defs = this.getDefs(false);

  if (!defs) {
    // Nothing to remove
    return;
  }

  var doms = this.getDoms();
  var that = this;
  zrUtil.each(doms, function (dom) {
    if (dom[that._markLabel] !== MARK_USED) {
      // Remove gradient
      defs.removeChild(dom);
    }
  });
};
/**
 * Get SVG proxy.
 *
 * @param {Displayable} displayable displayable element
 * @return {Path|Image|Text} svg proxy of given element
 */


Definable.prototype.getSvgProxy = function (displayable) {
  if (displayable instanceof Path) {
    return svgPath;
  } else if (displayable instanceof ZImage) {
    return svgImage;
  } else if (displayable instanceof ZText) {
    return svgText;
  } else {
    return svgPath;
  }
};
/**
 * Get text SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element of text
 */


Definable.prototype.getTextSvgElement = function (displayable) {
  return displayable.__textSvgEl;
};
/**
 * Get SVG element.
 *
 * @param {Displayable} displayable displayable element
 * @return {SVGElement} SVG element
 */


Definable.prototype.getSvgElement = function (displayable) {
  return displayable.__svgEl;
};

var _default = Definable;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/GradientManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/GradientManager.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Definable = __webpack_require__(/*! ./Definable */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/Definable.js");

var zrUtil = __webpack_require__(/*! ../../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var logError = __webpack_require__(/*! ../../core/log */ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js");

var colorTool = __webpack_require__(/*! ../../tool/color */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js");

/**
 * @file Manages SVG gradient elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG gradient elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */
function GradientManager(zrId, svgRoot) {
  Definable.call(this, zrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__');
}

zrUtil.inherits(GradientManager, Definable);
/**
 * Create new gradient DOM for fill or stroke if not exist,
 * but will not update gradient if exists.
 *
 * @param {SvgElement}  svgElement   SVG element to paint
 * @param {Displayable} displayable  zrender displayable element
 */

GradientManager.prototype.addWithoutUpdate = function (svgElement, displayable) {
  if (displayable && displayable.style) {
    var that = this;
    zrUtil.each(['fill', 'stroke'], function (fillOrStroke) {
      if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === 'linear' || displayable.style[fillOrStroke].type === 'radial')) {
        var gradient = displayable.style[fillOrStroke];
        var defs = that.getDefs(true); // Create dom in <defs> if not exists

        var dom;

        if (gradient._dom) {
          // Gradient exists
          dom = gradient._dom;

          if (!defs.contains(gradient._dom)) {
            // _dom is no longer in defs, recreate
            that.addDom(dom);
          }
        } else {
          // New dom
          dom = that.add(gradient);
        }

        that.markUsed(displayable);
        var id = dom.getAttribute('id');
        svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');
      }
    });
  }
};
/**
 * Add a new gradient tag in <defs>
 *
 * @param   {Gradient} gradient zr gradient instance
 * @return {SVGLinearGradientElement | SVGRadialGradientElement}
 *                            created DOM
 */


GradientManager.prototype.add = function (gradient) {
  var dom;

  if (gradient.type === 'linear') {
    dom = this.createElement('linearGradient');
  } else if (gradient.type === 'radial') {
    dom = this.createElement('radialGradient');
  } else {
    logError('Illegal gradient type.');
    return null;
  } // Set dom id with gradient id, since each gradient instance
  // will have no more than one dom element.
  // id may exists before for those dirty elements, in which case
  // id should remain the same, and other attributes should be
  // updated.


  gradient.id = gradient.id || this.nextId++;
  dom.setAttribute('id', 'zr' + this._zrId + '-gradient-' + gradient.id);
  this.updateDom(gradient, dom);
  this.addDom(dom);
  return dom;
};
/**
 * Update gradient.
 *
 * @param {Gradient} gradient zr gradient instance
 */


GradientManager.prototype.update = function (gradient) {
  var that = this;
  Definable.prototype.update.call(this, gradient, function () {
    var type = gradient.type;
    var tagName = gradient._dom.tagName;

    if (type === 'linear' && tagName === 'linearGradient' || type === 'radial' && tagName === 'radialGradient') {
      // Gradient type is not changed, update gradient
      that.updateDom(gradient, gradient._dom);
    } else {
      // Remove and re-create if type is changed
      that.removeDom(gradient);
      that.add(gradient);
    }
  });
};
/**
 * Update gradient dom
 *
 * @param {Gradient} gradient zr gradient instance
 * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom
 *                            DOM to update
 */


GradientManager.prototype.updateDom = function (gradient, dom) {
  if (gradient.type === 'linear') {
    dom.setAttribute('x1', gradient.x);
    dom.setAttribute('y1', gradient.y);
    dom.setAttribute('x2', gradient.x2);
    dom.setAttribute('y2', gradient.y2);
  } else if (gradient.type === 'radial') {
    dom.setAttribute('cx', gradient.x);
    dom.setAttribute('cy', gradient.y);
    dom.setAttribute('r', gradient.r);
  } else {
    logError('Illegal gradient type.');
    return;
  }

  if (gradient.global) {
    // x1, x2, y1, y2 in range of 0 to canvas width or height
    dom.setAttribute('gradientUnits', 'userSpaceOnUse');
  } else {
    // x1, x2, y1, y2 in range of 0 to 1
    dom.setAttribute('gradientUnits', 'objectBoundingBox');
  } // Remove color stops if exists


  dom.innerHTML = ''; // Add color stops

  var colors = gradient.colorStops;

  for (var i = 0, len = colors.length; i < len; ++i) {
    var stop = this.createElement('stop');
    stop.setAttribute('offset', colors[i].offset * 100 + '%');
    var color = colors[i].color;

    if (color.indexOf('rgba') > -1) {
      // Fix Safari bug that stop-color not recognizing alpha #9014
      var opacity = colorTool.parse(color)[3];
      var hex = colorTool.toHex(color); // stop-color cannot be color, since:
      // The opacity value used for the gradient calculation is the
      // *product* of the value of stop-opacity and the opacity of the
      // value of stop-color.
      // See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty

      stop.setAttribute('stop-color', '#' + hex);
      stop.setAttribute('stop-opacity', opacity);
    } else {
      stop.setAttribute('stop-color', colors[i].color);
    }

    dom.appendChild(stop);
  } // Store dom element in gradient, to avoid creating multiple
  // dom instances for the same gradient element


  gradient._dom = dom;
};
/**
 * Mark a single gradient to be used
 *
 * @param {Displayable} displayable displayable element
 */


GradientManager.prototype.markUsed = function (displayable) {
  if (displayable.style) {
    var gradient = displayable.style.fill;

    if (gradient && gradient._dom) {
      Definable.prototype.markUsed.call(this, gradient._dom);
    }

    gradient = displayable.style.stroke;

    if (gradient && gradient._dom) {
      Definable.prototype.markUsed.call(this, gradient._dom);
    }
  }
};

var _default = GradientManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ShadowManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/ShadowManager.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Definable = __webpack_require__(/*! ./Definable */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/helper/Definable.js");

var zrUtil = __webpack_require__(/*! ../../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

/**
 * @file Manages SVG shadow elements.
 * @author Zhang Wenli
 */

/**
 * Manages SVG shadow elements.
 *
 * @class
 * @extends Definable
 * @param   {number}     zrId    zrender instance id
 * @param   {SVGElement} svgRoot root of SVG document
 */
function ShadowManager(zrId, svgRoot) {
  Definable.call(this, zrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom');
}

zrUtil.inherits(ShadowManager, Definable);
/**
 * Create new shadow DOM for fill or stroke if not exist,
 * but will not update shadow if exists.
 *
 * @param {SvgElement}  svgElement   SVG element to paint
 * @param {Displayable} displayable  zrender displayable element
 */

ShadowManager.prototype.addWithoutUpdate = function (svgElement, displayable) {
  if (displayable && hasShadow(displayable.style)) {
    // Create dom in <defs> if not exists
    var dom;

    if (displayable._shadowDom) {
      // Gradient exists
      dom = displayable._shadowDom;
      var defs = this.getDefs(true);

      if (!defs.contains(displayable._shadowDom)) {
        // _shadowDom is no longer in defs, recreate
        this.addDom(dom);
      }
    } else {
      // New dom
      dom = this.add(displayable);
    }

    this.markUsed(displayable);
    var id = dom.getAttribute('id');
    svgElement.style.filter = 'url(#' + id + ')';
  }
};
/**
 * Add a new shadow tag in <defs>
 *
 * @param {Displayable} displayable  zrender displayable element
 * @return {SVGFilterElement} created DOM
 */


ShadowManager.prototype.add = function (displayable) {
  var dom = this.createElement('filter'); // Set dom id with shadow id, since each shadow instance
  // will have no more than one dom element.
  // id may exists before for those dirty elements, in which case
  // id should remain the same, and other attributes should be
  // updated.

  displayable._shadowDomId = displayable._shadowDomId || this.nextId++;
  dom.setAttribute('id', 'zr' + this._zrId + '-shadow-' + displayable._shadowDomId);
  this.updateDom(displayable, dom);
  this.addDom(dom);
  return dom;
};
/**
 * Update shadow.
 *
 * @param {Displayable} displayable  zrender displayable element
 */


ShadowManager.prototype.update = function (svgElement, displayable) {
  var style = displayable.style;

  if (hasShadow(style)) {
    var that = this;
    Definable.prototype.update.call(this, displayable, function () {
      that.updateDom(displayable, displayable._shadowDom);
    });
  } else {
    // Remove shadow
    this.remove(svgElement, displayable);
  }
};
/**
 * Remove DOM and clear parent filter
 */


ShadowManager.prototype.remove = function (svgElement, displayable) {
  if (displayable._shadowDomId != null) {
    this.removeDom(svgElement);
    svgElement.style.filter = '';
  }
};
/**
 * Update shadow dom
 *
 * @param {Displayable} displayable  zrender displayable element
 * @param {SVGFilterElement} dom DOM to update
 */


ShadowManager.prototype.updateDom = function (displayable, dom) {
  var domChild = dom.getElementsByTagName('feDropShadow');

  if (domChild.length === 0) {
    domChild = this.createElement('feDropShadow');
  } else {
    domChild = domChild[0];
  }

  var style = displayable.style;
  var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;
  var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1; // TODO: textBoxShadowBlur is not supported yet

  var offsetX;
  var offsetY;
  var blur;
  var color;

  if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {
    offsetX = style.shadowOffsetX || 0;
    offsetY = style.shadowOffsetY || 0;
    blur = style.shadowBlur;
    color = style.shadowColor;
  } else if (style.textShadowBlur) {
    offsetX = style.textShadowOffsetX || 0;
    offsetY = style.textShadowOffsetY || 0;
    blur = style.textShadowBlur;
    color = style.textShadowColor;
  } else {
    // Remove shadow
    this.removeDom(dom, style);
    return;
  }

  domChild.setAttribute('dx', offsetX / scaleX);
  domChild.setAttribute('dy', offsetY / scaleY);
  domChild.setAttribute('flood-color', color); // Divide by two here so that it looks the same as in canvas
  // See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur

  var stdDx = blur / 2 / scaleX;
  var stdDy = blur / 2 / scaleY;
  var stdDeviation = stdDx + ' ' + stdDy;
  domChild.setAttribute('stdDeviation', stdDeviation); // Fix filter clipping problem

  dom.setAttribute('x', '-100%');
  dom.setAttribute('y', '-100%');
  dom.setAttribute('width', Math.ceil(blur / 2 * 200) + '%');
  dom.setAttribute('height', Math.ceil(blur / 2 * 200) + '%');
  dom.appendChild(domChild); // Store dom element in shadow, to avoid creating multiple
  // dom instances for the same shadow element

  displayable._shadowDom = dom;
};
/**
 * Mark a single shadow to be used
 *
 * @param {Displayable} displayable displayable element
 */


ShadowManager.prototype.markUsed = function (displayable) {
  if (displayable._shadowDom) {
    Definable.prototype.markUsed.call(this, displayable._shadowDom);
  }
};

function hasShadow(style) {
  // TODO: textBoxShadowBlur is not supported yet
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);
}

var _default = ShadowManager;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/svg/svg.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/svg/svg.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./graphic */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/graphic.js");

var _zrender = __webpack_require__(/*! ../zrender */ "./node_modules/_zrender@4.3.2@zrender/lib/zrender.js");

var registerPainter = _zrender.registerPainter;

var Painter = __webpack_require__(/*! ./Painter */ "./node_modules/_zrender@4.3.2@zrender/lib/svg/Painter.js");

registerPainter('svg', Painter);

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js":
/*!***************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var LRU = __webpack_require__(/*! ../core/LRU */ "./node_modules/_zrender@4.3.2@zrender/lib/core/LRU.js");

var kCSSColorTable = {
  'transparent': [0, 0, 0, 0],
  'aliceblue': [240, 248, 255, 1],
  'antiquewhite': [250, 235, 215, 1],
  'aqua': [0, 255, 255, 1],
  'aquamarine': [127, 255, 212, 1],
  'azure': [240, 255, 255, 1],
  'beige': [245, 245, 220, 1],
  'bisque': [255, 228, 196, 1],
  'black': [0, 0, 0, 1],
  'blanchedalmond': [255, 235, 205, 1],
  'blue': [0, 0, 255, 1],
  'blueviolet': [138, 43, 226, 1],
  'brown': [165, 42, 42, 1],
  'burlywood': [222, 184, 135, 1],
  'cadetblue': [95, 158, 160, 1],
  'chartreuse': [127, 255, 0, 1],
  'chocolate': [210, 105, 30, 1],
  'coral': [255, 127, 80, 1],
  'cornflowerblue': [100, 149, 237, 1],
  'cornsilk': [255, 248, 220, 1],
  'crimson': [220, 20, 60, 1],
  'cyan': [0, 255, 255, 1],
  'darkblue': [0, 0, 139, 1],
  'darkcyan': [0, 139, 139, 1],
  'darkgoldenrod': [184, 134, 11, 1],
  'darkgray': [169, 169, 169, 1],
  'darkgreen': [0, 100, 0, 1],
  'darkgrey': [169, 169, 169, 1],
  'darkkhaki': [189, 183, 107, 1],
  'darkmagenta': [139, 0, 139, 1],
  'darkolivegreen': [85, 107, 47, 1],
  'darkorange': [255, 140, 0, 1],
  'darkorchid': [153, 50, 204, 1],
  'darkred': [139, 0, 0, 1],
  'darksalmon': [233, 150, 122, 1],
  'darkseagreen': [143, 188, 143, 1],
  'darkslateblue': [72, 61, 139, 1],
  'darkslategray': [47, 79, 79, 1],
  'darkslategrey': [47, 79, 79, 1],
  'darkturquoise': [0, 206, 209, 1],
  'darkviolet': [148, 0, 211, 1],
  'deeppink': [255, 20, 147, 1],
  'deepskyblue': [0, 191, 255, 1],
  'dimgray': [105, 105, 105, 1],
  'dimgrey': [105, 105, 105, 1],
  'dodgerblue': [30, 144, 255, 1],
  'firebrick': [178, 34, 34, 1],
  'floralwhite': [255, 250, 240, 1],
  'forestgreen': [34, 139, 34, 1],
  'fuchsia': [255, 0, 255, 1],
  'gainsboro': [220, 220, 220, 1],
  'ghostwhite': [248, 248, 255, 1],
  'gold': [255, 215, 0, 1],
  'goldenrod': [218, 165, 32, 1],
  'gray': [128, 128, 128, 1],
  'green': [0, 128, 0, 1],
  'greenyellow': [173, 255, 47, 1],
  'grey': [128, 128, 128, 1],
  'honeydew': [240, 255, 240, 1],
  'hotpink': [255, 105, 180, 1],
  'indianred': [205, 92, 92, 1],
  'indigo': [75, 0, 130, 1],
  'ivory': [255, 255, 240, 1],
  'khaki': [240, 230, 140, 1],
  'lavender': [230, 230, 250, 1],
  'lavenderblush': [255, 240, 245, 1],
  'lawngreen': [124, 252, 0, 1],
  'lemonchiffon': [255, 250, 205, 1],
  'lightblue': [173, 216, 230, 1],
  'lightcoral': [240, 128, 128, 1],
  'lightcyan': [224, 255, 255, 1],
  'lightgoldenrodyellow': [250, 250, 210, 1],
  'lightgray': [211, 211, 211, 1],
  'lightgreen': [144, 238, 144, 1],
  'lightgrey': [211, 211, 211, 1],
  'lightpink': [255, 182, 193, 1],
  'lightsalmon': [255, 160, 122, 1],
  'lightseagreen': [32, 178, 170, 1],
  'lightskyblue': [135, 206, 250, 1],
  'lightslategray': [119, 136, 153, 1],
  'lightslategrey': [119, 136, 153, 1],
  'lightsteelblue': [176, 196, 222, 1],
  'lightyellow': [255, 255, 224, 1],
  'lime': [0, 255, 0, 1],
  'limegreen': [50, 205, 50, 1],
  'linen': [250, 240, 230, 1],
  'magenta': [255, 0, 255, 1],
  'maroon': [128, 0, 0, 1],
  'mediumaquamarine': [102, 205, 170, 1],
  'mediumblue': [0, 0, 205, 1],
  'mediumorchid': [186, 85, 211, 1],
  'mediumpurple': [147, 112, 219, 1],
  'mediumseagreen': [60, 179, 113, 1],
  'mediumslateblue': [123, 104, 238, 1],
  'mediumspringgreen': [0, 250, 154, 1],
  'mediumturquoise': [72, 209, 204, 1],
  'mediumvioletred': [199, 21, 133, 1],
  'midnightblue': [25, 25, 112, 1],
  'mintcream': [245, 255, 250, 1],
  'mistyrose': [255, 228, 225, 1],
  'moccasin': [255, 228, 181, 1],
  'navajowhite': [255, 222, 173, 1],
  'navy': [0, 0, 128, 1],
  'oldlace': [253, 245, 230, 1],
  'olive': [128, 128, 0, 1],
  'olivedrab': [107, 142, 35, 1],
  'orange': [255, 165, 0, 1],
  'orangered': [255, 69, 0, 1],
  'orchid': [218, 112, 214, 1],
  'palegoldenrod': [238, 232, 170, 1],
  'palegreen': [152, 251, 152, 1],
  'paleturquoise': [175, 238, 238, 1],
  'palevioletred': [219, 112, 147, 1],
  'papayawhip': [255, 239, 213, 1],
  'peachpuff': [255, 218, 185, 1],
  'peru': [205, 133, 63, 1],
  'pink': [255, 192, 203, 1],
  'plum': [221, 160, 221, 1],
  'powderblue': [176, 224, 230, 1],
  'purple': [128, 0, 128, 1],
  'red': [255, 0, 0, 1],
  'rosybrown': [188, 143, 143, 1],
  'royalblue': [65, 105, 225, 1],
  'saddlebrown': [139, 69, 19, 1],
  'salmon': [250, 128, 114, 1],
  'sandybrown': [244, 164, 96, 1],
  'seagreen': [46, 139, 87, 1],
  'seashell': [255, 245, 238, 1],
  'sienna': [160, 82, 45, 1],
  'silver': [192, 192, 192, 1],
  'skyblue': [135, 206, 235, 1],
  'slateblue': [106, 90, 205, 1],
  'slategray': [112, 128, 144, 1],
  'slategrey': [112, 128, 144, 1],
  'snow': [255, 250, 250, 1],
  'springgreen': [0, 255, 127, 1],
  'steelblue': [70, 130, 180, 1],
  'tan': [210, 180, 140, 1],
  'teal': [0, 128, 128, 1],
  'thistle': [216, 191, 216, 1],
  'tomato': [255, 99, 71, 1],
  'turquoise': [64, 224, 208, 1],
  'violet': [238, 130, 238, 1],
  'wheat': [245, 222, 179, 1],
  'white': [255, 255, 255, 1],
  'whitesmoke': [245, 245, 245, 1],
  'yellow': [255, 255, 0, 1],
  'yellowgreen': [154, 205, 50, 1]
};

function clampCssByte(i) {
  // Clamp to integer 0 .. 255.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {
  // Clamp to integer 0 .. 360.
  i = Math.round(i); // Seems to be what Chrome does (vs truncation).

  return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {
  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {
  // int or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }

  return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {
  // float or percentage.
  if (str.length && str.charAt(str.length - 1) === '%') {
    return clampCssFloat(parseFloat(str) / 100);
  }

  return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }

  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }

  if (h * 2 < 1) {
    return m2;
  }

  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }

  return m1;
}

function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
  out[0] = r;
  out[1] = g;
  out[2] = b;
  out[3] = a;
  return out;
}

function copyRgba(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

var colorCache = new LRU(20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
  // Reuse removed array
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }

  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */


function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }

  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);

  if (cached) {
    return copyRgba(rgbaArr, cached);
  } // colorStr may be not string


  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  } // #abc and #abc123 syntax.


  if (str.charAt(0) === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xfff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

      if (!(iv >= 0 && iv <= 0xffffff)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return; // Covers NaN.
      }

      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }

    return;
  }

  var op = str.indexOf('(');
  var ep = str.indexOf(')');

  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(',');
    var alpha = 1; // To allow case fallthrough.

    switch (fname) {
      case 'rgba':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        alpha = parseCssFloat(params.pop());
      // jshint ignore:line
      // Fall through.

      case 'rgb':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsla':
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      case 'hsl':
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }

        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;

      default:
        return;
    }
  }

  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */


function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
  // NOTE(deanm): According to the CSS spec s/l should only be
  // percentages, but we don't bother and let float or percentage.

  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }

  return rgba;
}
/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */


function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  } // RGB from 0 to 255


  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B); // Min. value of RGB

  var vMax = Math.max(R, G, B); // Max. value of RGB

  var delta = vMax - vMin; // Delta RGB value

  var L = (vMax + vMin) / 2;
  var H;
  var S; // HSL results from 0 to 1

  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }

    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }

    if (H < 0) {
      H += 1;
    }

    if (H > 1) {
      H -= 1;
    }
  }

  var hsla = [H * 360, S, L];

  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }

  return hsla;
}
/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function lift(color, level) {
  var colorArr = parse(color);

  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }

      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (color[i] < 0) {
        colorArr[i] = 0;
      }
    }

    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
  }
}
/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */


function toHex(color) {
  var colorArr = parse(color);

  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */


function fastLerp(normalizedValue, colors, out) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  out = out || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out;
}
/**
 * @deprecated
 */


var fastMapToColor = fastLerp;
/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */

function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }

  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
  return fullOutput ? {
    color: color,
    leftIndex: leftIndex,
    rightIndex: rightIndex,
    value: value
  } : color;
}
/**
 * @deprecated
 */


var mapToColor = lerp;
/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */

function modifyHSL(color, h, s, l) {
  color = parse(color);

  if (color) {
    color = rgba2hsla(color);
    h != null && (color[0] = clampCssAngle(h));
    s != null && (color[1] = parseCssFloat(s));
    l != null && (color[2] = parseCssFloat(l));
    return stringify(hsla2rgba(color), 'rgba');
  }
}
/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */


function modifyAlpha(color, alpha) {
  color = parse(color);

  if (color && alpha != null) {
    color[3] = clampCssFloat(alpha);
    return stringify(color, 'rgba');
  }
}
/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */


function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }

  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
    colorStr += ',' + arrColor[3];
  }

  return type + '(' + colorStr + ')';
}

exports.parse = parse;
exports.lift = lift;
exports.toHex = toHex;
exports.fastLerp = fastLerp;
exports.fastMapToColor = fastMapToColor;
exports.lerp = lerp;
exports.mapToColor = mapToColor;
exports.modifyHSL = modifyHSL;
exports.modifyAlpha = modifyAlpha;
exports.stringify = stringify;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/tool/parseSVG.js":
/*!******************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/tool/parseSVG.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Group = __webpack_require__(/*! ../container/Group */ "./node_modules/_zrender@4.3.2@zrender/lib/container/Group.js");

var ZImage = __webpack_require__(/*! ../graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

var Text = __webpack_require__(/*! ../graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

var Circle = __webpack_require__(/*! ../graphic/shape/Circle */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Circle.js");

var Rect = __webpack_require__(/*! ../graphic/shape/Rect */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Rect.js");

var Ellipse = __webpack_require__(/*! ../graphic/shape/Ellipse */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Ellipse.js");

var Line = __webpack_require__(/*! ../graphic/shape/Line */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Line.js");

var Path = __webpack_require__(/*! ../graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var Polygon = __webpack_require__(/*! ../graphic/shape/Polygon */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polygon.js");

var Polyline = __webpack_require__(/*! ../graphic/shape/Polyline */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/shape/Polyline.js");

var LinearGradient = __webpack_require__(/*! ../graphic/LinearGradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/LinearGradient.js");

var Style = __webpack_require__(/*! ../graphic/Style */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Style.js");

var matrix = __webpack_require__(/*! ../core/matrix */ "./node_modules/_zrender@4.3.2@zrender/lib/core/matrix.js");

var _path = __webpack_require__(/*! ./path */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/path.js");

var createFromString = _path.createFromString;

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var isString = _util.isString;
var extend = _util.extend;
var defaults = _util.defaults;
var trim = _util.trim;
var each = _util.each;
// import RadialGradient from '../graphic/RadialGradient';
// import Pattern from '../graphic/Pattern';
// import * as vector from '../core/vector';
// Most of the values can be separated by comma and/or white space.
var DILIMITER_REG = /[\s,]+/;
/**
 * For big svg string, this method might be time consuming.
 *
 * @param {string} svg xml string
 * @return {Object} xml root.
 */

function parseXML(svg) {
  if (isString(svg)) {
    var parser = new DOMParser();
    svg = parser.parseFromString(svg, 'text/xml');
  } // Document node. If using $.get, doc node may be input.


  if (svg.nodeType === 9) {
    svg = svg.firstChild;
  } // nodeName of <!DOCTYPE svg> is also 'svg'.


  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {
    svg = svg.nextSibling;
  }

  return svg;
}

function SVGParser() {
  this._defs = {};
  this._root = null;
  this._isDefine = false;
  this._isText = false;
}

SVGParser.prototype.parse = function (xml, opt) {
  opt = opt || {};
  var svg = parseXML(xml);

  if (!svg) {
    throw new Error('Illegal svg');
  }

  var root = new Group();
  this._root = root; // parse view port

  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means "100%" of `opt.width/height`.
  // TODO: Other percent value not supported yet.

  var width = parseFloat(svg.getAttribute('width') || opt.width);
  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.

  isNaN(width) && (width = null);
  isNaN(height) && (height = null); // Apply inline style on svg element.

  parseAttributes(svg, root, null, true);
  var child = svg.firstChild;

  while (child) {
    this._parseNode(child, root);

    child = child.nextSibling;
  }

  var viewBoxRect;
  var viewBoxTransform;

  if (viewBox) {
    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.

    if (viewBoxArr.length >= 4) {
      viewBoxRect = {
        x: parseFloat(viewBoxArr[0] || 0),
        y: parseFloat(viewBoxArr[1] || 0),
        width: parseFloat(viewBoxArr[2]),
        height: parseFloat(viewBoxArr[3])
      };
    }
  }

  if (viewBoxRect && width != null && height != null) {
    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);

    if (!opt.ignoreViewBox) {
      // If set transform on the output group, it probably bring trouble when
      // some users only intend to show the clipped content inside the viewBox,
      // but not intend to transform the output group. So we keep the output
      // group no transform. If the user intend to use the viewBox as a
      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom
      // manually according to the viewBox info in the output of this method.
      var elRoot = root;
      root = new Group();
      root.add(elRoot);
      elRoot.scale = viewBoxTransform.scale.slice();
      elRoot.position = viewBoxTransform.position.slice();
    }
  } // Some shapes might be overflow the viewport, which should be
  // clipped despite whether the viewBox is used, as the SVG does.


  if (!opt.ignoreRootClip && width != null && height != null) {
    root.setClipPath(new Rect({
      shape: {
        x: 0,
        y: 0,
        width: width,
        height: height
      }
    }));
  } // Set width/height on group just for output the viewport size.


  return {
    root: root,
    width: width,
    height: height,
    viewBoxRect: viewBoxRect,
    viewBoxTransform: viewBoxTransform
  };
};

SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {
  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO
  // support <style>...</style> in svg, where nodeName is 'style',
  // CSS classes is defined globally wherever the style tags are declared.

  if (nodeName === 'defs') {
    // define flag
    this._isDefine = true;
  } else if (nodeName === 'text') {
    this._isText = true;
  }

  var el;

  if (this._isDefine) {
    var parser = defineParsers[nodeName];

    if (parser) {
      var def = parser.call(this, xmlNode);
      var id = xmlNode.getAttribute('id');

      if (id) {
        this._defs[id] = def;
      }
    }
  } else {
    var parser = nodeParsers[nodeName];

    if (parser) {
      el = parser.call(this, xmlNode, parentGroup);
      parentGroup.add(el);
    }
  }

  var child = xmlNode.firstChild;

  while (child) {
    if (child.nodeType === 1) {
      this._parseNode(child, el);
    } // Is text


    if (child.nodeType === 3 && this._isText) {
      this._parseText(child, el);
    }

    child = child.nextSibling;
  } // Quit define


  if (nodeName === 'defs') {
    this._isDefine = false;
  } else if (nodeName === 'text') {
    this._isText = false;
  }
};

SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
  if (xmlNode.nodeType === 1) {
    var dx = xmlNode.getAttribute('dx') || 0;
    var dy = xmlNode.getAttribute('dy') || 0;
    this._textX += parseFloat(dx);
    this._textY += parseFloat(dy);
  }

  var text = new Text({
    style: {
      text: xmlNode.textContent,
      transformText: true
    },
    position: [this._textX || 0, this._textY || 0]
  });
  inheritStyle(parentGroup, text);
  parseAttributes(xmlNode, text, this._defs);
  var fontSize = text.style.fontSize;

  if (fontSize && fontSize < 9) {
    // PENDING
    text.style.fontSize = 9;
    text.scale = text.scale || [1, 1];
    text.scale[0] *= fontSize / 9;
    text.scale[1] *= fontSize / 9;
  }

  var rect = text.getBoundingRect();
  this._textX += rect.width;
  parentGroup.add(text);
  return text;
};

var nodeParsers = {
  'g': function (xmlNode, parentGroup) {
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    return g;
  },
  'rect': function (xmlNode, parentGroup) {
    var rect = new Rect();
    inheritStyle(parentGroup, rect);
    parseAttributes(xmlNode, rect, this._defs);
    rect.setShape({
      x: parseFloat(xmlNode.getAttribute('x') || 0),
      y: parseFloat(xmlNode.getAttribute('y') || 0),
      width: parseFloat(xmlNode.getAttribute('width') || 0),
      height: parseFloat(xmlNode.getAttribute('height') || 0)
    }); // console.log(xmlNode.getAttribute('transform'));
    // console.log(rect.transform);

    return rect;
  },
  'circle': function (xmlNode, parentGroup) {
    var circle = new Circle();
    inheritStyle(parentGroup, circle);
    parseAttributes(xmlNode, circle, this._defs);
    circle.setShape({
      cx: parseFloat(xmlNode.getAttribute('cx') || 0),
      cy: parseFloat(xmlNode.getAttribute('cy') || 0),
      r: parseFloat(xmlNode.getAttribute('r') || 0)
    });
    return circle;
  },
  'line': function (xmlNode, parentGroup) {
    var line = new Line();
    inheritStyle(parentGroup, line);
    parseAttributes(xmlNode, line, this._defs);
    line.setShape({
      x1: parseFloat(xmlNode.getAttribute('x1') || 0),
      y1: parseFloat(xmlNode.getAttribute('y1') || 0),
      x2: parseFloat(xmlNode.getAttribute('x2') || 0),
      y2: parseFloat(xmlNode.getAttribute('y2') || 0)
    });
    return line;
  },
  'ellipse': function (xmlNode, parentGroup) {
    var ellipse = new Ellipse();
    inheritStyle(parentGroup, ellipse);
    parseAttributes(xmlNode, ellipse, this._defs);
    ellipse.setShape({
      cx: parseFloat(xmlNode.getAttribute('cx') || 0),
      cy: parseFloat(xmlNode.getAttribute('cy') || 0),
      rx: parseFloat(xmlNode.getAttribute('rx') || 0),
      ry: parseFloat(xmlNode.getAttribute('ry') || 0)
    });
    return ellipse;
  },
  'polygon': function (xmlNode, parentGroup) {
    var points = xmlNode.getAttribute('points');

    if (points) {
      points = parsePoints(points);
    }

    var polygon = new Polygon({
      shape: {
        points: points || []
      }
    });
    inheritStyle(parentGroup, polygon);
    parseAttributes(xmlNode, polygon, this._defs);
    return polygon;
  },
  'polyline': function (xmlNode, parentGroup) {
    var path = new Path();
    inheritStyle(parentGroup, path);
    parseAttributes(xmlNode, path, this._defs);
    var points = xmlNode.getAttribute('points');

    if (points) {
      points = parsePoints(points);
    }

    var polyline = new Polyline({
      shape: {
        points: points || []
      }
    });
    return polyline;
  },
  'image': function (xmlNode, parentGroup) {
    var img = new ZImage();
    inheritStyle(parentGroup, img);
    parseAttributes(xmlNode, img, this._defs);
    img.setStyle({
      image: xmlNode.getAttribute('xlink:href'),
      x: xmlNode.getAttribute('x'),
      y: xmlNode.getAttribute('y'),
      width: xmlNode.getAttribute('width'),
      height: xmlNode.getAttribute('height')
    });
    return img;
  },
  'text': function (xmlNode, parentGroup) {
    var x = xmlNode.getAttribute('x') || 0;
    var y = xmlNode.getAttribute('y') || 0;
    var dx = xmlNode.getAttribute('dx') || 0;
    var dy = xmlNode.getAttribute('dy') || 0;
    this._textX = parseFloat(x) + parseFloat(dx);
    this._textY = parseFloat(y) + parseFloat(dy);
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    return g;
  },
  'tspan': function (xmlNode, parentGroup) {
    var x = xmlNode.getAttribute('x');
    var y = xmlNode.getAttribute('y');

    if (x != null) {
      // new offset x
      this._textX = parseFloat(x);
    }

    if (y != null) {
      // new offset y
      this._textY = parseFloat(y);
    }

    var dx = xmlNode.getAttribute('dx') || 0;
    var dy = xmlNode.getAttribute('dy') || 0;
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    this._textX += dx;
    this._textY += dy;
    return g;
  },
  'path': function (xmlNode, parentGroup) {
    // TODO svg fill rule
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
    // path.style.globalCompositeOperation = 'xor';
    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.

    var path = createFromString(d);
    inheritStyle(parentGroup, path);
    parseAttributes(xmlNode, path, this._defs);
    return path;
  }
};
var defineParsers = {
  'lineargradient': function (xmlNode) {
    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);
    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);
    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);
    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);
    var gradient = new LinearGradient(x1, y1, x2, y2);

    _parseGradientColorStops(xmlNode, gradient);

    return gradient;
  },
  'radialgradient': function (xmlNode) {}
};

function _parseGradientColorStops(xmlNode, gradient) {
  var stop = xmlNode.firstChild;

  while (stop) {
    if (stop.nodeType === 1) {
      var offset = stop.getAttribute('offset');

      if (offset.indexOf('%') > 0) {
        // percentage
        offset = parseInt(offset, 10) / 100;
      } else if (offset) {
        // number from 0 to 1
        offset = parseFloat(offset);
      } else {
        offset = 0;
      }

      var stopColor = stop.getAttribute('stop-color') || '#000000';
      gradient.addColorStop(offset, stopColor);
    }

    stop = stop.nextSibling;
  }
}

function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }

    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}

function parsePoints(pointsString) {
  var list = trim(pointsString).split(DILIMITER_REG);
  var points = [];

  for (var i = 0; i < list.length; i += 2) {
    var x = parseFloat(list[i]);
    var y = parseFloat(list[i + 1]);
    points.push([x, y]);
  }

  return points;
}

var attributesMap = {
  'fill': 'fill',
  'stroke': 'stroke',
  'stroke-width': 'lineWidth',
  'opacity': 'opacity',
  'fill-opacity': 'fillOpacity',
  'stroke-opacity': 'strokeOpacity',
  'stroke-dasharray': 'lineDash',
  'stroke-dashoffset': 'lineDashOffset',
  'stroke-linecap': 'lineCap',
  'stroke-linejoin': 'lineJoin',
  'stroke-miterlimit': 'miterLimit',
  'font-family': 'fontFamily',
  'font-size': 'fontSize',
  'font-style': 'fontStyle',
  'font-weight': 'fontWeight',
  'text-align': 'textAlign',
  'alignment-baseline': 'textBaseline'
};

function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
  var zrStyle = el.__inheritedStyle || {};
  var isTextEl = el.type === 'text'; // TODO Shadow

  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    extend(zrStyle, parseStyleAttribute(xmlNode));

    if (!onlyInlineStyle) {
      for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName)) {
          var attrValue = xmlNode.getAttribute(svgAttrName);

          if (attrValue != null) {
            zrStyle[attributesMap[svgAttrName]] = attrValue;
          }
        }
      }
    }
  }

  var elFillProp = isTextEl ? 'textFill' : 'fill';
  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';
  el.style = el.style || new Style();
  var elStyle = el.style;
  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {
    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;
    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
  });

  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {
    zrStyle.textBaseline = 'alphabetic';
  }

  if (zrStyle.textBaseline === 'alphabetic') {
    zrStyle.textBaseline = 'bottom';
  }

  if (zrStyle.textAlign === 'start') {
    zrStyle.textAlign = 'left';
  }

  if (zrStyle.textAlign === 'end') {
    zrStyle.textAlign = 'right';
  }

  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {
    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
  });

  if (zrStyle.lineDash) {
    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);
  }

  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {
    // enable stroke
    el[elStrokeProp] = true;
  }

  el.__inheritedStyle = zrStyle;
}

var urlRegex = /url\(\s*#(.*?)\)/;

function getPaint(str, defs) {
  // if (str === 'none') {
  //     return;
  // }
  var urlMatch = defs && str && str.match(urlRegex);

  if (urlMatch) {
    var url = trim(urlMatch[1]);
    var def = defs[url];
    return def;
  }

  return str;
}

var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;

function parseTransformAttribute(xmlNode, node) {
  var transform = xmlNode.getAttribute('transform');

  if (transform) {
    transform = transform.replace(/,/g, ' ');
    var m = null;
    var transformOps = [];
    transform.replace(transformRegex, function (str, type, value) {
      transformOps.push(type, value);
    });

    for (var i = transformOps.length - 1; i > 0; i -= 2) {
      var value = transformOps[i];
      var type = transformOps[i - 1];
      m = m || matrix.create();

      switch (type) {
        case 'translate':
          value = trim(value).split(DILIMITER_REG);
          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
          break;

        case 'scale':
          value = trim(value).split(DILIMITER_REG);
          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
          break;

        case 'rotate':
          value = trim(value).split(DILIMITER_REG);
          matrix.rotate(m, m, parseFloat(value[0]));
          break;

        case 'skew':
          value = trim(value).split(DILIMITER_REG);
          console.warn('Skew transform is not supported yet');
          break;

        case 'matrix':
          var value = trim(value).split(DILIMITER_REG);
          m[0] = parseFloat(value[0]);
          m[1] = parseFloat(value[1]);
          m[2] = parseFloat(value[2]);
          m[3] = parseFloat(value[3]);
          m[4] = parseFloat(value[4]);
          m[5] = parseFloat(value[5]);
          break;
      }
    }

    node.setLocalTransform(m);
  }
} // Value may contain space.


var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;

function parseStyleAttribute(xmlNode) {
  var style = xmlNode.getAttribute('style');
  var result = {};

  if (!style) {
    return result;
  }

  var styleList = {};
  styleRegex.lastIndex = 0;
  var styleRegResult;

  while ((styleRegResult = styleRegex.exec(style)) != null) {
    styleList[styleRegResult[1]] = styleRegResult[2];
  }

  for (var svgAttrName in attributesMap) {
    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
      result[attributesMap[svgAttrName]] = styleList[svgAttrName];
    }
  }

  return result;
}
/**
 * @param {Array.<number>} viewBoxRect
 * @param {number} width
 * @param {number} height
 * @return {Object} {scale, position}
 */


function makeViewBoxTransform(viewBoxRect, width, height) {
  var scaleX = width / viewBoxRect.width;
  var scaleY = height / viewBoxRect.height;
  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'

  var viewBoxScale = [scale, scale];
  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
  return {
    scale: viewBoxScale,
    position: viewBoxPosition
  };
}
/**
 * @param {string|XMLElement} xml
 * @param {Object} [opt]
 * @param {number} [opt.width] Default width if svg width not specified or is a percent value.
 * @param {number} [opt.height] Default height if svg height not specified or is a percent value.
 * @param {boolean} [opt.ignoreViewBox]
 * @param {boolean} [opt.ignoreRootClip]
 * @return {Object} result:
 * {
 *     root: Group, The root of the the result tree of zrender shapes,
 *     width: number, the viewport width of the SVG,
 *     height: number, the viewport height of the SVG,
 *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,
 *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.
 * }
 */


function parseSVG(xml, opt) {
  var parser = new SVGParser();
  return parser.parse(xml, opt);
}

exports.parseXML = parseXML;
exports.makeViewBoxTransform = makeViewBoxTransform;
exports.parseSVG = parseSVG;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/tool/path.js":
/*!**************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/tool/path.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Path = __webpack_require__(/*! ../graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var transformPath = __webpack_require__(/*! ./transformPath */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/transformPath.js");

// command chars
// var cc = [
//     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
//     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
// ];
var mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;

var vMag = function (v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};

var vRatio = function (u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};

var vAngle = function (u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};

function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI / 180.0);
  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= mathSqrt(lambda);
    ry *= mathSqrt(lambda);
  }

  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * PI;
  }

  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * PI;
  }

  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}

var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:
// (1) delimiter can be comma or space, where continuous commas
// or spaces should be seen as one comma.
// (2) value can be like:
// '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',
// 'l-.5E1,54', '121-23-44-11' (no delimiter)

var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\s,]+/;

function createPathProxyFromString(data) {
  if (!data) {
    return new PathProxy();
  } // var data = data.replace(/-/g, ' -')
  //     .replace(/  /g, ' ')
  //     .replace(/ /g, ',')
  //     .replace(/,,/g, ',');
  // var n;
  // create pipes so that we can split the data
  // for (n = 0; n < cc.length; n++) {
  //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
  // }
  // data = data.replace(/-/g, ',-');
  // create array
  // var arr = cs.split('|');
  // init context point


  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var path = new PathProxy();
  var CMD = PathProxy.CMD; // commandReg.lastIndex = 0;
  // var cmdResult;
  // while ((cmdResult = commandReg.exec(data)) != null) {
  //     var cmdStr = cmdResult[1];
  //     var cmdContent = cmdResult[2];

  var cmdList = data.match(commandReg);

  for (var l = 0; l < cmdList.length; l++) {
    var cmdText = cmdList[l];
    var cmdStr = cmdText.charAt(0);
    var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.
    // var p = cmdContent.split(valueSplitReg);
    // var pLen = 0;
    // for (var i = 0; i < p.length; i++) {
    //     // '' and other invalid str => NaN
    //     var val = parseFloat(p[i]);
    //     !isNaN(val) && (p[pLen++] = val);
    // }

    var p = cmdText.match(numberReg) || [];
    var pLen = p.length;

    for (var i = 0; i < pLen; i++) {
      p[i] = parseFloat(p[i]);
    }

    var off = 0;

    while (off < pLen) {
      var ctlPtx;
      var ctlPty;
      var rx;
      var ry;
      var psi;
      var fa;
      var fs;
      var x1 = cpx;
      var y1 = cpy; // convert l, H, h, V, and v to L

      switch (cmdStr) {
        case 'l':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'L':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'm':
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = 'l';
          break;

        case 'M':
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = 'L';
          break;

        case 'h':
          cpx += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'H':
          cpx = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'v':
          cpy += p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'V':
          cpy = p[off++];
          cmd = CMD.L;
          path.addData(cmd, cpx, cpy);
          break;

        case 'C':
          cmd = CMD.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;

        case 'c':
          cmd = CMD.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;

        case 'S':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 's':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cmd = CMD.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;

        case 'Q':
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'q':
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;

        case 'T':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 't':
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path.len();
          var pathData = path.data;

          if (prevCmd === CMD.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }

          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;

        case 'A':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;

        case 'a':
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }

    if (cmdStr === 'z' || cmdStr === 'Z') {
      cmd = CMD.Z;
      path.addData(cmd); // z may be in the middle of the path.

      cpx = subpathX;
      cpy = subpathY;
    }

    prevCmd = cmd;
  }

  path.toStatic();
  return path;
} // TODO Optimize double memory cost problem


function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  opts = opts || {};

  opts.buildPath = function (path) {
    if (path.setData) {
      path.setData(pathProxy.data); // Svg and vml renderer don't have context

      var ctx = path.getContext();

      if (ctx) {
        path.rebuildPath(ctx);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx);
    }
  };

  opts.applyTransform = function (m) {
    transformPath(pathProxy, m);
    this.dirty(true);
  };

  return opts;
}
/**
 * Create a Path object from path string data
 * http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {Object} opts Other options
 */


function createFromString(str, opts) {
  return new Path(createPathOptions(str, opts));
}
/**
 * Create a Path class from path string data
 * @param  {string} str
 * @param  {Object} opts Other options
 */


function extendFromString(str, opts) {
  return Path.extend(createPathOptions(str, opts));
}
/**
 * Merge multiple paths
 */
// TODO Apply transform
// TODO stroke dash
// TODO Optimize double memory cost problem


function mergePath(pathEls, opts) {
  var pathList = [];
  var len = pathEls.length;

  for (var i = 0; i < len; i++) {
    var pathEl = pathEls[i];

    if (!pathEl.path) {
      pathEl.createPathProxy();
    }

    if (pathEl.__dirtyPath) {
      pathEl.buildPath(pathEl.path, pathEl.shape, true);
    }

    pathList.push(pathEl.path);
  }

  var pathBundle = new Path(opts); // Need path proxy.

  pathBundle.createPathProxy();

  pathBundle.buildPath = function (path) {
    path.appendPath(pathList); // Svg and vml renderer don't have context

    var ctx = path.getContext();

    if (ctx) {
      path.rebuildPath(ctx);
    }
  };

  return pathBundle;
}

exports.createFromString = createFromString;
exports.extendFromString = extendFromString;
exports.mergePath = mergePath;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/tool/transformPath.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/tool/transformPath.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var _vector = __webpack_require__(/*! ../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var v2ApplyTransform = _vector.applyTransform;
var CMD = PathProxy.CMD;
var points = [[], [], []];
var mathSqrt = Math.sqrt;
var mathAtan2 = Math.atan2;

function _default(path, m) {
  var data = path.data;
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD.M;
  var C = CMD.C;
  var L = CMD.L;
  var R = CMD.R;
  var A = CMD.A;
  var Q = CMD.Q;

  for (i = 0, j = 0; i < data.length;) {
    cmd = data[i++];
    j = i;
    nPoint = 0;

    switch (cmd) {
      case M:
        nPoint = 1;
        break;

      case L:
        nPoint = 1;
        break;

      case C:
        nPoint = 3;
        break;

      case Q:
        nPoint = 2;
        break;

      case A:
        var x = m[4];
        var y = m[5];
        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

        data[i] *= sx;
        data[i++] += x; // cy

        data[i] *= sy;
        data[i++] += y; // Scale rx and ry
        // FIXME Assume psi is 0 here

        data[i++] *= sx;
        data[i++] *= sy; // Start angle

        data[i++] += angle; // end angle

        data[i++] += angle; // FIXME psi

        i += 2;
        j = i;
        break;

      case R:
        // x0, y0
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1]; // x1, y1

        p[0] += data[i++];
        p[1] += data[i++];
        v2ApplyTransform(p, p, m);
        data[j++] = p[0];
        data[j++] = p[1];
    }

    for (k = 0; k < nPoint; k++) {
      var p = points[k];
      p[0] = data[i++];
      p[1] = data[i++];
      v2ApplyTransform(p, p, m); // Write back

      data[j++] = p[0];
      data[j++] = p[1];
    }
  }
}

module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/vml/Painter.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/vml/Painter.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var logError = __webpack_require__(/*! ../core/log */ "./node_modules/_zrender@4.3.2@zrender/lib/core/log.js");

var vmlCore = __webpack_require__(/*! ./core */ "./node_modules/_zrender@4.3.2@zrender/lib/vml/core.js");

var _util = __webpack_require__(/*! ../core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var each = _util.each;

/**
 * VML Painter.
 *
 * @module zrender/vml/Painter
 */
function parseInt10(val) {
  return parseInt(val, 10);
}
/**
 * @alias module:zrender/vml/Painter
 */


function VMLPainter(root, storage) {
  vmlCore.initVML();
  this.root = root;
  this.storage = storage;
  var vmlViewport = document.createElement('div');
  var vmlRoot = document.createElement('div');
  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
  root.appendChild(vmlViewport);
  this._vmlRoot = vmlRoot;
  this._vmlViewport = vmlViewport;
  this.resize(); // Modify storage

  var oldDelFromStorage = storage.delFromStorage;
  var oldAddToStorage = storage.addToStorage;

  storage.delFromStorage = function (el) {
    oldDelFromStorage.call(storage, el);

    if (el) {
      el.onRemove && el.onRemove(vmlRoot);
    }
  };

  storage.addToStorage = function (el) {
    // Displayable already has a vml node
    el.onAdd && el.onAdd(vmlRoot);
    oldAddToStorage.call(storage, el);
  };

  this._firstPaint = true;
}

VMLPainter.prototype = {
  constructor: VMLPainter,
  getType: function () {
    return 'vml';
  },

  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function () {
    return this._vmlViewport;
  },
  getViewportRootOffset: function () {
    var viewportRoot = this.getViewportRoot();

    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },

  /**
   * 刷新
   */
  refresh: function () {
    var list = this.storage.getDisplayList(true, true);

    this._paintList(list);
  },
  _paintList: function (list) {
    var vmlRoot = this._vmlRoot;

    for (var i = 0; i < list.length; i++) {
      var el = list[i];

      if (el.invisible || el.ignore) {
        if (!el.__alreadyNotVisible) {
          el.onRemove(vmlRoot);
        } // Set as already invisible


        el.__alreadyNotVisible = true;
      } else {
        if (el.__alreadyNotVisible) {
          el.onAdd(vmlRoot);
        }

        el.__alreadyNotVisible = false;

        if (el.__dirty) {
          el.beforeBrush && el.beforeBrush();
          (el.brushVML || el.brush).call(el, vmlRoot);
          el.afterBrush && el.afterBrush();
        }
      }

      el.__dirty = false;
    }

    if (this._firstPaint) {
      // Detached from document at first time
      // to avoid page refreshing too many times
      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
      this._vmlViewport.appendChild(vmlRoot);

      this._firstPaint = false;
    }
  },
  resize: function (width, height) {
    var width = width == null ? this._getWidth() : width;
    var height = height == null ? this._getHeight() : height;

    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      var vmlViewportStyle = this._vmlViewport.style;
      vmlViewportStyle.width = width + 'px';
      vmlViewportStyle.height = height + 'px';
    }
  },
  dispose: function () {
    this.root.innerHTML = '';
    this._vmlRoot = this._vmlViewport = this.storage = null;
  },
  getWidth: function () {
    return this._width;
  },
  getHeight: function () {
    return this._height;
  },
  clear: function () {
    if (this._vmlViewport) {
      this.root.removeChild(this._vmlViewport);
    }
  },
  _getWidth: function () {
    var root = this.root;
    var stl = root.currentStyle;
    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
  },
  _getHeight: function () {
    var root = this.root;
    var stl = root.currentStyle;
    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
  }
}; // Not supported methods

function createMethodNotSupport(method) {
  return function () {
    logError('In IE8.0 VML mode painter not support method "' + method + '"');
  };
} // Unsupported methods


each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
  VMLPainter.prototype[name] = createMethodNotSupport(name);
});
var _default = VMLPainter;
module.exports = _default;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/vml/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/vml/core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var env = __webpack_require__(/*! ../core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var urn = 'urn:schemas-microsoft-com:vml';
var win = typeof window === 'undefined' ? null : window;
var vmlInited = false;
var doc = win && win.document;

function createNode(tagName) {
  return doCreateNode(tagName);
} // Avoid assign to an exported variable, for transforming to cjs.


var doCreateNode;

if (doc && !env.canvasSupported) {
  try {
    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);

    doCreateNode = function (tagName) {
      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
    };
  } catch (e) {
    doCreateNode = function (tagName) {
      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
    };
  }
} // From raphael


function initVML() {
  if (vmlInited || !doc) {
    return;
  }

  vmlInited = true;
  var styleSheets = doc.styleSheets;

  if (styleSheets.length < 31) {
    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
  } else {
    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
  }
}

exports.doc = doc;
exports.createNode = createNode;
exports.initVML = initVML;

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/vml/graphic.js":
/*!****************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/vml/graphic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var env = __webpack_require__(/*! ../core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var _vector = __webpack_require__(/*! ../core/vector */ "./node_modules/_zrender@4.3.2@zrender/lib/core/vector.js");

var applyTransform = _vector.applyTransform;

var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ "./node_modules/_zrender@4.3.2@zrender/lib/core/BoundingRect.js");

var colorTool = __webpack_require__(/*! ../tool/color */ "./node_modules/_zrender@4.3.2@zrender/lib/tool/color.js");

var textContain = __webpack_require__(/*! ../contain/text */ "./node_modules/_zrender@4.3.2@zrender/lib/contain/text.js");

var textHelper = __webpack_require__(/*! ../graphic/helper/text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/helper/text.js");

var RectText = __webpack_require__(/*! ../graphic/mixin/RectText */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/mixin/RectText.js");

var Displayable = __webpack_require__(/*! ../graphic/Displayable */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Displayable.js");

var ZImage = __webpack_require__(/*! ../graphic/Image */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Image.js");

var Text = __webpack_require__(/*! ../graphic/Text */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Text.js");

var Path = __webpack_require__(/*! ../graphic/Path */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Path.js");

var PathProxy = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/core/PathProxy.js");

var Gradient = __webpack_require__(/*! ../graphic/Gradient */ "./node_modules/_zrender@4.3.2@zrender/lib/graphic/Gradient.js");

var vmlCore = __webpack_require__(/*! ./core */ "./node_modules/_zrender@4.3.2@zrender/lib/vml/core.js");

// http://www.w3.org/TR/NOTE-VML
// TODO Use proxy like svg instead of overwrite brush methods
var CMD = PathProxy.CMD;
var round = Math.round;
var sqrt = Math.sqrt;
var abs = Math.abs;
var cos = Math.cos;
var sin = Math.sin;
var mathMax = Math.max;

if (!env.canvasSupported) {
  var comma = ',';
  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
  var Z = 21600;
  var Z2 = Z / 2;
  var ZLEVEL_BASE = 100000;
  var Z_BASE = 1000;

  var initRootElStyle = function (el) {
    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
    el.coordsize = Z + ',' + Z;
    el.coordorigin = '0,0';
  };

  var encodeHtmlAttribute = function (s) {
    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
  };

  var rgb2Str = function (r, g, b) {
    return 'rgb(' + [r, g, b].join(',') + ')';
  };

  var append = function (parent, child) {
    if (child && parent && child.parentNode !== parent) {
      parent.appendChild(child);
    }
  };

  var remove = function (parent, child) {
    if (child && parent && child.parentNode === parent) {
      parent.removeChild(child);
    }
  };

  var getZIndex = function (zlevel, z, z2) {
    // z 的取值范围为 [0, 1000]
    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
  };

  var parsePercent = textHelper.parsePercent;
  /***************************************************
   * PATH
   **************************************************/

  var setColorAndOpacity = function (el, color, opacity) {
    var colorArr = colorTool.parse(color);
    opacity = +opacity;

    if (isNaN(opacity)) {
      opacity = 1;
    }

    if (colorArr) {
      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
      el.opacity = opacity * colorArr[3];
    }
  };

  var getColorAndAlpha = function (color) {
    var colorArr = colorTool.parse(color);
    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
  };

  var updateFillNode = function (el, style, zrEl) {
    // TODO pattern
    var fill = style.fill;

    if (fill != null) {
      // Modified from excanvas
      if (fill instanceof Gradient) {
        var gradientType;
        var angle = 0;
        var focus = [0, 0]; // additional offset

        var shift = 0; // scale factor for offset

        var expansion = 1;
        var rect = zrEl.getBoundingRect();
        var rectWidth = rect.width;
        var rectHeight = rect.height;

        if (fill.type === 'linear') {
          gradientType = 'gradient';
          var transform = zrEl.transform;
          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];

          if (transform) {
            applyTransform(p0, p0, transform);
            applyTransform(p1, p1, transform);
          }

          var dx = p1[0] - p0[0];
          var dy = p1[1] - p0[1];
          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.

          if (angle < 0) {
            angle += 360;
          } // Very small angles produce an unexpected result because they are
          // converted to a scientific notation string.


          if (angle < 1e-6) {
            angle = 0;
          }
        } else {
          gradientType = 'gradientradial';
          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
          var transform = zrEl.transform;
          var scale = zrEl.scale;
          var width = rectWidth;
          var height = rectHeight;
          focus = [// Percent in bounding rect
          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];

          if (transform) {
            applyTransform(p0, p0, transform);
          }

          width /= scale[0] * Z;
          height /= scale[1] * Z;
          var dimension = mathMax(width, height);
          shift = 2 * 0 / dimension;
          expansion = 2 * fill.r / dimension - shift;
        } // We need to sort the color stops in ascending order by offset,
        // otherwise IE won't interpret it correctly.


        var stops = fill.colorStops.slice();
        stops.sort(function (cs1, cs2) {
          return cs1.offset - cs2.offset;
        });
        var length = stops.length; // Color and alpha list of first and last stop

        var colorAndAlphaList = [];
        var colors = [];

        for (var i = 0; i < length; i++) {
          var stop = stops[i];
          var colorAndAlpha = getColorAndAlpha(stop.color);
          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);

          if (i === 0 || i === length - 1) {
            colorAndAlphaList.push(colorAndAlpha);
          }
        }

        if (length >= 2) {
          var color1 = colorAndAlphaList[0][0];
          var color2 = colorAndAlphaList[1][0];
          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
          el.type = gradientType;
          el.method = 'none';
          el.focus = '100%';
          el.angle = angle;
          el.color = color1;
          el.color2 = color2;
          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
          // are reversed.

          el.opacity = opacity2; // FIXME g_o_:opacity ?

          el.opacity2 = opacity1;
        }

        if (gradientType === 'radial') {
          el.focusposition = focus.join(',');
        }
      } else {
        // FIXME Change from Gradient fill to color fill
        setColorAndOpacity(el, fill, style.opacity);
      }
    }
  };

  var updateStrokeNode = function (el, style) {
    // if (style.lineJoin != null) {
    //     el.joinstyle = style.lineJoin;
    // }
    // if (style.miterLimit != null) {
    //     el.miterlimit = style.miterLimit * Z;
    // }
    // if (style.lineCap != null) {
    //     el.endcap = style.lineCap;
    // }
    if (style.lineDash) {
      el.dashstyle = style.lineDash.join(' ');
    }

    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
      setColorAndOpacity(el, style.stroke, style.opacity);
    }
  };

  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
    var isFill = type === 'fill';
    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth

    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error

      if (style[type] instanceof Gradient) {
        remove(vmlEl, el);
      }

      if (!el) {
        el = vmlCore.createNode(type);
      }

      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
      append(vmlEl, el);
    } else {
      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
      remove(vmlEl, el);
    }
  };

  var points = [[], [], []];

  var pathDataToString = function (path, m) {
    var M = CMD.M;
    var C = CMD.C;
    var L = CMD.L;
    var A = CMD.A;
    var Q = CMD.Q;
    var str = [];
    var nPoint;
    var cmdStr;
    var cmd;
    var i;
    var xi;
    var yi;
    var data = path.data;
    var dataLength = path.len();

    for (i = 0; i < dataLength;) {
      cmd = data[i++];
      cmdStr = '';
      nPoint = 0;

      switch (cmd) {
        case M:
          cmdStr = ' m ';
          nPoint = 1;
          xi = data[i++];
          yi = data[i++];
          points[0][0] = xi;
          points[0][1] = yi;
          break;

        case L:
          cmdStr = ' l ';
          nPoint = 1;
          xi = data[i++];
          yi = data[i++];
          points[0][0] = xi;
          points[0][1] = yi;
          break;

        case Q:
        case C:
          cmdStr = ' c ';
          nPoint = 3;
          var x1 = data[i++];
          var y1 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          var x3;
          var y3;

          if (cmd === Q) {
            // Convert quadratic to cubic using degree elevation
            x3 = x2;
            y3 = y2;
            x2 = (x2 + 2 * x1) / 3;
            y2 = (y2 + 2 * y1) / 3;
            x1 = (xi + 2 * x1) / 3;
            y1 = (yi + 2 * y1) / 3;
          } else {
            x3 = data[i++];
            y3 = data[i++];
          }

          points[0][0] = x1;
          points[0][1] = y1;
          points[1][0] = x2;
          points[1][1] = y2;
          points[2][0] = x3;
          points[2][1] = y3;
          xi = x3;
          yi = y3;
          break;

        case A:
          var x = 0;
          var y = 0;
          var sx = 1;
          var sy = 1;
          var angle = 0;

          if (m) {
            // Extract SRT from matrix
            x = m[4];
            y = m[5];
            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
            angle = Math.atan2(-m[1] / sy, m[0] / sx);
          }

          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++] + angle;
          var endAngle = data[i++] + startAngle + angle; // FIXME
          // var psi = data[i++];

          i++;
          var clockwise = data[i++];
          var x0 = cx + cos(startAngle) * rx;
          var y0 = cy + sin(startAngle) * ry;
          var x1 = cx + cos(endAngle) * rx;
          var y1 = cy + sin(endAngle) * ry;
          var type = clockwise ? ' wa ' : ' at ';

          if (Math.abs(x0 - x1) < 1e-4) {
            // IE won't render arches drawn counter clockwise if x0 == x1.
            if (Math.abs(endAngle - startAngle) > 1e-2) {
              // Offset x0 by 1/80 of a pixel. Use something
              // that can be represented in binary
              if (clockwise) {
                x0 += 270 / Z;
              }
            } else {
              // Avoid case draw full circle
              if (Math.abs(y0 - cy) < 1e-4) {
                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
                  y1 -= 270 / Z;
                } else {
                  y1 += 270 / Z;
                }
              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
                x1 += 270 / Z;
              } else {
                x1 -= 270 / Z;
              }
            }
          }

          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
          xi = x1;
          yi = y1;
          break;

        case CMD.R:
          var p0 = points[0];
          var p1 = points[1]; // x0, y0

          p0[0] = data[i++];
          p0[1] = data[i++]; // x1, y1

          p1[0] = p0[0] + data[i++];
          p1[1] = p0[1] + data[i++];

          if (m) {
            applyTransform(p0, p0, m);
            applyTransform(p1, p1, m);
          }

          p0[0] = round(p0[0] * Z - Z2);
          p1[0] = round(p1[0] * Z - Z2);
          p0[1] = round(p0[1] * Z - Z2);
          p1[1] = round(p1[1] * Z - Z2);
          str.push( // x0, y0
          ' m ', p0[0], comma, p0[1], // x1, y0
          ' l ', p1[0], comma, p0[1], // x1, y1
          ' l ', p1[0], comma, p1[1], // x0, y1
          ' l ', p0[0], comma, p1[1]);
          break;

        case CMD.Z:
          // FIXME Update xi, yi
          str.push(' x ');
      }

      if (nPoint > 0) {
        str.push(cmdStr);

        for (var k = 0; k < nPoint; k++) {
          var p = points[k];
          m && applyTransform(p, p, m); // 不 round 会非常慢

          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
        }
      }
    }

    return str.join('');
  }; // Rewrite the original path method


  Path.prototype.brushVML = function (vmlRoot) {
    var style = this.style;
    var vmlEl = this._vmlEl;

    if (!vmlEl) {
      vmlEl = vmlCore.createNode('shape');
      initRootElStyle(vmlEl);
      this._vmlEl = vmlEl;
    }

    updateFillAndStroke(vmlEl, 'fill', style, this);
    updateFillAndStroke(vmlEl, 'stroke', style, this);
    var m = this.transform;
    var needTransform = m != null;
    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];

    if (strokeEl) {
      var lineWidth = style.lineWidth; // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.

      if (needTransform && !style.strokeNoScale) {
        var det = m[0] * m[3] - m[1] * m[2];
        lineWidth *= sqrt(abs(det));
      }

      strokeEl.weight = lineWidth + 'px';
    }

    var path = this.path || (this.path = new PathProxy());

    if (this.__dirtyPath) {
      path.beginPath();
      path.subPixelOptimize = false;
      this.buildPath(path, this.shape);
      path.toStatic();
      this.__dirtyPath = false;
    }

    vmlEl.path = pathDataToString(path, this.transform);
    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

    append(vmlRoot, vmlEl); // Text

    if (style.text != null) {
      this.drawRectText(vmlRoot, this.getBoundingRect());
    } else {
      this.removeRectText(vmlRoot);
    }
  };

  Path.prototype.onRemove = function (vmlRoot) {
    remove(vmlRoot, this._vmlEl);
    this.removeRectText(vmlRoot);
  };

  Path.prototype.onAdd = function (vmlRoot) {
    append(vmlRoot, this._vmlEl);
    this.appendRectText(vmlRoot);
  };
  /***************************************************
   * IMAGE
   **************************************************/


  var isImage = function (img) {
    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
  }; // Rewrite the original path method


  ZImage.prototype.brushVML = function (vmlRoot) {
    var style = this.style;
    var image = style.image; // Image original width, height

    var ow;
    var oh;

    if (isImage(image)) {
      var src = image.src;

      if (src === this._imageSrc) {
        ow = this._imageWidth;
        oh = this._imageHeight;
      } else {
        var imageRuntimeStyle = image.runtimeStyle;
        var oldRuntimeWidth = imageRuntimeStyle.width;
        var oldRuntimeHeight = imageRuntimeStyle.height;
        imageRuntimeStyle.width = 'auto';
        imageRuntimeStyle.height = 'auto'; // get the original size

        ow = image.width;
        oh = image.height; // and remove overides

        imageRuntimeStyle.width = oldRuntimeWidth;
        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src

        this._imageSrc = src;
        this._imageWidth = ow;
        this._imageHeight = oh;
      }

      image = src;
    } else {
      if (image === this._imageSrc) {
        ow = this._imageWidth;
        oh = this._imageHeight;
      }
    }

    if (!image) {
      return;
    }

    var x = style.x || 0;
    var y = style.y || 0;
    var dw = style.width;
    var dh = style.height;
    var sw = style.sWidth;
    var sh = style.sHeight;
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    var hasCrop = sw && sh;
    var vmlEl = this._vmlEl;

    if (!vmlEl) {
      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
      // vmlEl = vmlCore.createNode('group');
      vmlEl = vmlCore.doc.createElement('div');
      initRootElStyle(vmlEl);
      this._vmlEl = vmlEl;
    }

    var vmlElStyle = vmlEl.style;
    var hasRotation = false;
    var m;
    var scaleX = 1;
    var scaleY = 1;

    if (this.transform) {
      m = this.transform;
      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
      hasRotation = m[1] || m[2];
    }

    if (hasRotation) {
      // If filters are necessary (rotation exists), create them
      // filters are bog-slow, so only create them if abbsolutely necessary
      // The following check doesn't account for skews (which don't exist
      // in the canvas spec (yet) anyway.
      // From excanvas
      var p0 = [x, y];
      var p1 = [x + dw, y];
      var p2 = [x, y + dh];
      var p3 = [x + dw, y + dh];
      applyTransform(p0, p0, m);
      applyTransform(p1, p1, m);
      applyTransform(p2, p2, m);
      applyTransform(p3, p3, m);
      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
      var transformFilter = [];
      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用

      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
    } else {
      if (m) {
        x = x * scaleX + m[4];
        y = y * scaleY + m[5];
      }

      vmlElStyle.filter = '';
      vmlElStyle.left = round(x) + 'px';
      vmlElStyle.top = round(y) + 'px';
    }

    var imageEl = this._imageEl;
    var cropEl = this._cropEl;

    if (!imageEl) {
      imageEl = vmlCore.doc.createElement('div');
      this._imageEl = imageEl;
    }

    var imageELStyle = imageEl.style;

    if (hasCrop) {
      // Needs know image original width and height
      if (!(ow && oh)) {
        var tmpImage = new Image();
        var self = this;

        tmpImage.onload = function () {
          tmpImage.onload = null;
          ow = tmpImage.width;
          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize

          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src

          self._imageWidth = ow;
          self._imageHeight = oh;
          self._imageSrc = image;
        };

        tmpImage.src = image;
      } else {
        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
      }

      if (!cropEl) {
        cropEl = vmlCore.doc.createElement('div');
        cropEl.style.overflow = 'hidden';
        this._cropEl = cropEl;
      }

      var cropElStyle = cropEl.style;
      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';

      if (!cropEl.parentNode) {
        vmlEl.appendChild(cropEl);
      }

      if (imageEl.parentNode !== cropEl) {
        cropEl.appendChild(imageEl);
      }
    } else {
      imageELStyle.width = round(scaleX * dw) + 'px';
      imageELStyle.height = round(scaleY * dh) + 'px';
      vmlEl.appendChild(imageEl);

      if (cropEl && cropEl.parentNode) {
        vmlEl.removeChild(cropEl);
        this._cropEl = null;
      }
    }

    var filterStr = '';
    var alpha = style.opacity;

    if (alpha < 1) {
      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
    }

    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
    imageELStyle.filter = filterStr;
    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root

    append(vmlRoot, vmlEl); // Text

    if (style.text != null) {
      this.drawRectText(vmlRoot, this.getBoundingRect());
    }
  };

  ZImage.prototype.onRemove = function (vmlRoot) {
    remove(vmlRoot, this._vmlEl);
    this._vmlEl = null;
    this._cropEl = null;
    this._imageEl = null;
    this.removeRectText(vmlRoot);
  };

  ZImage.prototype.onAdd = function (vmlRoot) {
    append(vmlRoot, this._vmlEl);
    this.appendRectText(vmlRoot);
  };
  /***************************************************
   * TEXT
   **************************************************/


  var DEFAULT_STYLE_NORMAL = 'normal';
  var fontStyleCache = {};
  var fontStyleCacheCount = 0;
  var MAX_FONT_CACHE_SIZE = 100;
  var fontEl = document.createElement('div');

  var getFontStyle = function (fontString) {
    var fontStyle = fontStyleCache[fontString];

    if (!fontStyle) {
      // Clear cache
      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
        fontStyleCacheCount = 0;
        fontStyleCache = {};
      }

      var style = fontEl.style;
      var fontFamily;

      try {
        style.font = fontString;
        fontFamily = style.fontFamily.split(',')[0];
      } catch (e) {}

      fontStyle = {
        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
        size: parseFloat(style.fontSize || 12) | 0,
        family: fontFamily || 'Microsoft YaHei'
      };
      fontStyleCache[fontString] = fontStyle;
      fontStyleCacheCount++;
    }

    return fontStyle;
  };

  var textMeasureEl; // Overwrite measure text method

  textContain.$override('measureText', function (text, textFont) {
    var doc = vmlCore.doc;

    if (!textMeasureEl) {
      textMeasureEl = doc.createElement('div');
      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
      vmlCore.doc.body.appendChild(textMeasureEl);
    }

    try {
      textMeasureEl.style.font = textFont;
    } catch (ex) {// Ignore failures to set to invalid font.
    }

    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.

    textMeasureEl.appendChild(doc.createTextNode(text));
    return {
      width: textMeasureEl.offsetWidth
    };
  });
  var tmpRect = new BoundingRect();

  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
    var style = this.style; // Optimize, avoid normalize every time.

    this.__dirty && textHelper.normalizeTextStyle(style, true);
    var text = style.text; // Convert to string

    text != null && (text += '');

    if (!text) {
      return;
    } // Convert rich text to plain text. Rich text is not supported in
    // IE8-, but tags in rich text template will be removed.


    if (style.rich) {
      var contentBlock = textContain.parseRichText(text, style);
      text = [];

      for (var i = 0; i < contentBlock.lines.length; i++) {
        var tokens = contentBlock.lines[i].tokens;
        var textLine = [];

        for (var j = 0; j < tokens.length; j++) {
          textLine.push(tokens[j].text);
        }

        text.push(textLine.join(''));
      }

      text = text.join('\n');
    }

    var x;
    var y;
    var align = style.textAlign;
    var verticalAlign = style.textVerticalAlign;
    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?

    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space

    var m = this.transform; // Ignore transform for text in other element

    if (m && !fromTextEl) {
      tmpRect.copy(rect);
      tmpRect.applyTransform(m);
      rect = tmpRect;
    }

    if (!fromTextEl) {
      var textPosition = style.textPosition; // Text position represented by coord

      if (textPosition instanceof Array) {
        x = rect.x + parsePercent(textPosition[0], rect.width);
        y = rect.y + parsePercent(textPosition[1], rect.height);
        align = align || 'left';
      } else {
        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);
        x = res.x;
        y = res.y; // Default align and baseline when has textPosition

        align = align || res.textAlign;
        verticalAlign = verticalAlign || res.textVerticalAlign;
      }
    } else {
      x = rect.x;
      y = rect.y;
    }

    x = textContain.adjustTextX(x, textRect.width, align);
    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'

    y += textRect.height / 2; // var fontSize = fontStyle.size;
    // 1.75 is an arbitrary number, as there is no info about the text baseline
    // switch (baseline) {
    // case 'hanging':
    // case 'top':
    //     y += fontSize / 1.75;
    //     break;
    //     case 'middle':
    //         break;
    //     default:
    //     // case null:
    //     // case 'alphabetic':
    //     // case 'ideographic':
    //     // case 'bottom':
    //         y -= fontSize / 2.25;
    //         break;
    // }
    // switch (align) {
    //     case 'left':
    //         break;
    //     case 'center':
    //         x -= textRect.width / 2;
    //         break;
    //     case 'right':
    //         x -= textRect.width;
    //         break;
    // case 'end':
    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
    // break;
    // case 'start':
    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
    // break;
    // default:
    //     align = 'left';
    // }

    var createNode = vmlCore.createNode;
    var textVmlEl = this._textVmlEl;
    var pathEl;
    var textPathEl;
    var skewEl;

    if (!textVmlEl) {
      textVmlEl = createNode('line');
      pathEl = createNode('path');
      textPathEl = createNode('textpath');
      skewEl = createNode('skew'); // FIXME Why here is not cammel case
      // Align 'center' seems wrong

      textPathEl.style['v-text-align'] = 'left';
      initRootElStyle(textVmlEl);
      pathEl.textpathok = true;
      textPathEl.on = true;
      textVmlEl.from = '0 0';
      textVmlEl.to = '1000 0.05';
      append(textVmlEl, skewEl);
      append(textVmlEl, pathEl);
      append(textVmlEl, textPathEl);
      this._textVmlEl = textVmlEl;
    } else {
      // 这里是在前面 appendChild 保证顺序的前提下
      skewEl = textVmlEl.firstChild;
      pathEl = skewEl.nextSibling;
      textPathEl = pathEl.nextSibling;
    }

    var coords = [x, y];
    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element

    if (m && fromTextEl) {
      applyTransform(coords, coords, m);
      skewEl.on = true;
      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position

      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin

      skewEl.origin = '0 0';
      textVmlElStyle.left = '0px';
      textVmlElStyle.top = '0px';
    } else {
      skewEl.on = false;
      textVmlElStyle.left = round(x) + 'px';
      textVmlElStyle.top = round(y) + 'px';
    }

    textPathEl.string = encodeHtmlAttribute(text); // TODO

    try {
      textPathEl.style.font = font;
    } // Error font format
    catch (e) {}

    updateFillAndStroke(textVmlEl, 'fill', {
      fill: style.textFill,
      opacity: style.opacity
    }, this);
    updateFillAndStroke(textVmlEl, 'stroke', {
      stroke: style.textStroke,
      opacity: style.opacity,
      lineDash: style.lineDash || null // style.lineDash can be `false`.

    }, this);
    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root

    append(vmlRoot, textVmlEl);
  };

  var removeRectText = function (vmlRoot) {
    remove(vmlRoot, this._textVmlEl);
    this._textVmlEl = null;
  };

  var appendRectText = function (vmlRoot) {
    append(vmlRoot, this._textVmlEl);
  };

  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText

  for (var i = 0; i < list.length; i++) {
    var proto = list[i].prototype;
    proto.drawRectText = drawRectText;
    proto.removeRectText = removeRectText;
    proto.appendRectText = appendRectText;
  }

  Text.prototype.brushVML = function (vmlRoot) {
    var style = this.style;

    if (style.text != null) {
      this.drawRectText(vmlRoot, {
        x: style.x || 0,
        y: style.y || 0,
        width: 0,
        height: 0
      }, this.getBoundingRect(), true);
    } else {
      this.removeRectText(vmlRoot);
    }
  };

  Text.prototype.onRemove = function (vmlRoot) {
    this.removeRectText(vmlRoot);
  };

  Text.prototype.onAdd = function (vmlRoot) {
    this.appendRectText(vmlRoot);
  };
}

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/vml/vml.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/vml/vml.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./graphic */ "./node_modules/_zrender@4.3.2@zrender/lib/vml/graphic.js");

var _zrender = __webpack_require__(/*! ../zrender */ "./node_modules/_zrender@4.3.2@zrender/lib/zrender.js");

var registerPainter = _zrender.registerPainter;

var Painter = __webpack_require__(/*! ./Painter */ "./node_modules/_zrender@4.3.2@zrender/lib/vml/Painter.js");

registerPainter('vml', Painter);

/***/ }),

/***/ "./node_modules/_zrender@4.3.2@zrender/lib/zrender.js":
/*!************************************************************!*\
  !*** ./node_modules/_zrender@4.3.2@zrender/lib/zrender.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var guid = __webpack_require__(/*! ./core/guid */ "./node_modules/_zrender@4.3.2@zrender/lib/core/guid.js");

var env = __webpack_require__(/*! ./core/env */ "./node_modules/_zrender@4.3.2@zrender/lib/core/env.js");

var zrUtil = __webpack_require__(/*! ./core/util */ "./node_modules/_zrender@4.3.2@zrender/lib/core/util.js");

var Handler = __webpack_require__(/*! ./Handler */ "./node_modules/_zrender@4.3.2@zrender/lib/Handler.js");

var Storage = __webpack_require__(/*! ./Storage */ "./node_modules/_zrender@4.3.2@zrender/lib/Storage.js");

var Painter = __webpack_require__(/*! ./Painter */ "./node_modules/_zrender@4.3.2@zrender/lib/Painter.js");

var Animation = __webpack_require__(/*! ./animation/Animation */ "./node_modules/_zrender@4.3.2@zrender/lib/animation/Animation.js");

var HandlerProxy = __webpack_require__(/*! ./dom/HandlerProxy */ "./node_modules/_zrender@4.3.2@zrender/lib/dom/HandlerProxy.js");

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var useVML = !env.canvasSupported;
var painterCtors = {
  canvas: Painter
};
var instances = {}; // ZRender实例map索引

/**
 * @type {string}
 */

var version = '4.3.2';
/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} [opts]
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */

function init(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */


function dispose(zr) {
  if (zr) {
    zr.dispose();
  } else {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }

    instances = {};
  }

  return this;
}
/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */


function getInstance(id) {
  return instances[id];
}

function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}

function delInstance(id) {
  delete instances[id];
}
/**
 * @module zrender/ZRender
 */

/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */


var ZRender = function (id, dom, opts) {
  opts = opts || {};
  /**
   * @type {HTMLDomElement}
   */

  this.dom = dom;
  /**
   * @type {string}
   */

  this.id = id;
  var self = this;
  var storage = new Storage();
  var rendererType = opts.renderer; // TODO WebGL

  if (useVML) {
    if (!painterCtors.vml) {
      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
    }

    rendererType = 'vml';
  } else if (!rendererType || !painterCtors[rendererType]) {
    rendererType = 'canvas';
  }

  var painter = new painterCtors[rendererType](dom, storage, opts, id);
  this.storage = storage;
  this.painter = painter;
  var handerProxy = !env.node && !env.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
  this.handler = new Handler(storage, painter, handerProxy, painter.root);
  /**
   * @type {module:zrender/animation/Animation}
   */

  this.animation = new Animation({
    stage: {
      update: zrUtil.bind(this.flush, this)
    }
  });
  this.animation.start();
  /**
   * @type {boolean}
   * @private
   */

  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
  // FIXME 有点ugly

  var oldDelFromStorage = storage.delFromStorage;
  var oldAddToStorage = storage.addToStorage;

  storage.delFromStorage = function (el) {
    oldDelFromStorage.call(storage, el);
    el && el.removeSelfFromZr(self);
  };

  storage.addToStorage = function (el) {
    oldAddToStorage.call(storage, el);
    el.addSelfToZr(self);
  };
};

ZRender.prototype = {
  constructor: ZRender,

  /**
   * 获取实例唯一标识
   * @return {string}
   */
  getId: function () {
    return this.id;
  },

  /**
   * 添加元素
   * @param  {module:zrender/Element} el
   */
  add: function (el) {
    this.storage.addRoot(el);
    this._needsRefresh = true;
  },

  /**
   * 删除元素
   * @param  {module:zrender/Element} el
   */
  remove: function (el) {
    this.storage.delRoot(el);
    this._needsRefresh = true;
  },

  /**
   * Change configuration of layer
   * @param {string} zLevel
   * @param {Object} config
   * @param {string} [config.clearColor=0] Clear color
   * @param {string} [config.motionBlur=false] If enable motion blur
   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
  */
  configLayer: function (zLevel, config) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }

    this._needsRefresh = true;
  },

  /**
   * Set background color
   * @param {string} backgroundColor
   */
  setBackgroundColor: function (backgroundColor) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor);
    }

    this._needsRefresh = true;
  },

  /**
   * Repaint the canvas immediately
   */
  refreshImmediately: function () {
    // var start = new Date();
    // Clear needsRefresh ahead to avoid something wrong happens in refresh
    // Or it will cause zrender refreshes again and again.
    this._needsRefresh = this._needsRefreshHover = false;
    this.painter.refresh(); // Avoid trigger zr.refresh in Element#beforeUpdate hook

    this._needsRefresh = this._needsRefreshHover = false; // var end = new Date();
    // var log = document.getElementById('log');
    // if (log) {
    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
    // }
  },

  /**
   * Mark and repaint the canvas in the next frame of browser
   */
  refresh: function () {
    this._needsRefresh = true;
  },

  /**
   * Perform all refresh
   */
  flush: function () {
    var triggerRendered;

    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately();
    }

    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }

    triggerRendered && this.trigger('rendered');
  },

  /**
   * Add element to hover layer
   * @param  {module:zrender/Element} el
   * @param {Object} style
   */
  addHover: function (el, style) {
    if (this.painter.addHover) {
      var elMirror = this.painter.addHover(el, style);
      this.refreshHover();
      return elMirror;
    }
  },

  /**
   * Add element from hover layer
   * @param  {module:zrender/Element} el
   */
  removeHover: function (el) {
    if (this.painter.removeHover) {
      this.painter.removeHover(el);
      this.refreshHover();
    }
  },

  /**
   * Clear all hover elements in hover layer
   * @param  {module:zrender/Element} el
   */
  clearHover: function () {
    if (this.painter.clearHover) {
      this.painter.clearHover();
      this.refreshHover();
    }
  },

  /**
   * Refresh hover in next frame
   */
  refreshHover: function () {
    this._needsRefreshHover = true;
  },

  /**
   * Refresh hover immediately
   */
  refreshHoverImmediately: function () {
    this._needsRefreshHover = false;
    this.painter.refreshHover && this.painter.refreshHover();
  },

  /**
   * Resize the canvas.
   * Should be invoked when container size is changed
   * @param {Object} [opts]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   */
  resize: function (opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  },

  /**
   * Stop and clear all animation immediately
   */
  clearAnimation: function () {
    this.animation.clear();
  },

  /**
   * Get container width
   */
  getWidth: function () {
    return this.painter.getWidth();
  },

  /**
   * Get container height
   */
  getHeight: function () {
    return this.painter.getHeight();
  },

  /**
   * Export the canvas as Base64 URL
   * @param {string} type
   * @param {string} [backgroundColor='#fff']
   * @return {string} Base64 URL
   */
  // toDataURL: function(type, backgroundColor) {
  //     return this.painter.getRenderedCanvas({
  //         backgroundColor: backgroundColor
  //     }).toDataURL(type);
  // },

  /**
   * Converting a path to image.
   * It has much better performance of drawing image rather than drawing a vector path.
   * @param {module:zrender/graphic/Path} e
   * @param {number} width
   * @param {number} height
   */
  pathToImage: function (e, dpr) {
    return this.painter.pathToImage(e, dpr);
  },

  /**
   * Set default cursor
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function (cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  },

  /**
   * Find hovered element
   * @param {number} x
   * @param {number} y
   * @return {Object} {target, topTarget}
   */
  findHover: function (x, y) {
    return this.handler.findHover(x, y);
  },

  /**
   * Bind event
   *
   * @param {string} eventName Event name
   * @param {Function} eventHandler Handler function
   * @param {Object} [context] Context object
   */
  on: function (eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
  },

  /**
   * Unbind event
   * @param {string} eventName Event name
   * @param {Function} [eventHandler] Handler function
   */
  off: function (eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  },

  /**
   * Trigger event manually
   *
   * @param {string} eventName Event name
   * @param {event=} event Event object
   */
  trigger: function (eventName, event) {
    this.handler.trigger(eventName, event);
  },

  /**
   * Clear all objects and the canvas.
   */
  clear: function () {
    this.storage.delRoot();
    this.painter.clear();
  },

  /**
   * Dispose self.
   */
  dispose: function () {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  }
};
exports.version = version;
exports.init = init;
exports.dispose = dispose;
exports.getInstance = getInstance;
exports.registerPainter = registerPainter;

/***/ }),

/***/ "./src/blockVertexData.js":
/*!********************************!*\
  !*** ./src/blockVertexData.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blockVertexData": () => (/* binding */ blockVertexData)
/* harmony export */ });
/* harmony import */ var _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeVertexData */ "./src/pipeVertexData.js");

/**
 * 各功能池的属性，包括：
 *  - id
 *  - 名称
 *  - 字体
 *  - 左上和右下点的坐标
 */
const blockVertexData = [
  // 各方块测量数据
  {
    id: "1",
    name: "提标硝化滤池",
    font: "16px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input1_1.coor.slice(0)[0], -180],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_2.coor.slice(0)[1]],
  },
  //{id: '1_attach', name: '', font: '16px Microsoft YaHei', vertex1: [pipeVertexData.output1_1.coor.slice(0)[0], -180], vertex2: [pipeVertexData.output1_1.coor.slice(0)[0] + 20, -100]},
  {
    id: "2",
    name: "提标反硝化池",
    font: "16px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input2_1.coor.slice(0)[0], -180],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_2.coor.slice(0)[1]],
  },
  //{id: '2_attach', name: '', font: '16px Microsoft YaHei', vertex1: [pipeVertexData.output2_1.coor.slice(0)[0], -180], vertex2: [pipeVertexData.output2_1.coor.slice(0)[0]+20, -80]},

  {
    id: "3",
    name: "提标\n滤布\n滤池",
    font: "10px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_1.coor.slice(0)[0], -180],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_2.coor.slice(0)[1]],
  },
  {
    id: "5",
    name: "扩建\n滤布\n滤池",
    font: "11px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 50, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1.coor.slice(0)[1]],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input5_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1]],
  },
  {
    id: "6",
    name: "提标泵房\n及臭氧",
    font: "13px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], -180],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 100, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_2.coor.slice(0)[1]],
  },
  {
    id: "7",
    name: "曝气活性炭池",
    font: "16px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] - 120],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1]],
  },
  {
    id: "13",
    name: "综合进出水池",
    font: "14px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input13_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_1.coor.slice(0)[1]],
    vertex2: [784, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input13_2.coor.slice(0)[1]],
  },
  //{id: '13_attach', name: '', font: '16px Microsoft YaHei', vertex1: [pipeVertexData.input13_1.coor.slice(0)[0], pipeVertexData.output13_1.coor.slice(0)[1]-20], vertex2: [784, pipeVertexData.output13_1.coor.slice(0)[1]]},
  {
    id: "15",
    name: "超滤车间",
    font: "16px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_2.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  },
  {
    id: "17",
    name: "综合控制室",
    font: "16px Microsoft YaHei",
    vertex1: [780, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_1.coor.slice(0)[1]],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input13_2.coor.slice(0)[1]],
  },

  { id: "4", name: "扩建工程调节池", font: "14px Microsoft YaHei", vertex1: [1300, 770], vertex2: [1600, 900] },

  { id: "8", name: "臭氧发生器", font: "12px Microsoft YaHei", vertex1: [1450, 100], vertex2: [1560, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1]] },
  { id: "9", name: "污泥浓缩池", font: "12px Microsoft YaHei", vertex1: [1450, -50], vertex2: [1560, 30] },
  { id: "10", name: "脱水机房加\n药除臭系统", font: "13px Microsoft YaHei", vertex1: [1600, -180], vertex2: [1750, -40] },
  { id: "11", name: "变电站", font: "14px Microsoft YaHei", vertex1: [1630, 52], vertex2: [1750, 182] },
  { id: "12", name: "液氧站", font: "12px Microsoft YaHei", vertex1: [1450, -180], vertex2: [1500, -110] },

  {
    id: "14",
    name: "扩建硝化车间",
    font: "16px Microsoft YaHei",
    vertex1: [960, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  },
  {
    id: "14",
    name: "扩建反硝化池",
    font: "16px Microsoft YaHei",
    vertex1: [1510, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    vertex2: [1750, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  },

  {
    id: "16",
    name: "高效\n沉淀池",
    font: "14px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    vertex2: [1400, 520],
  },

  {
    id: "undefined1",
    name: "",
    font: "14px Microsoft YaHei",
    vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] - 180, 220],
    vertex2: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], 250],
  },
  { id: "undefined2", name: "", font: "14px Microsoft YaHei", vertex1: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], 220], vertex2: [1750, 250] },

  /*
        {id: '4_attach', name: '', font: '16px Microsoft YaHei', vertex1: [587, -120], vertex2: [784, -80]},
    */
];




/***/ }),

/***/ "./src/coorMap.js":
/*!************************!*\
  !*** ./src/coorMap.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blockData_fit": () => (/* binding */ blockData_fit),
/* harmony export */   "pipes_noData_drawData": () => (/* binding */ pipes_noData_drawData),
/* harmony export */   "pipes_noData_drawData_origin": () => (/* binding */ pipes_noData_drawData_origin)
/* harmony export */ });
/* harmony import */ var _pipeData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeData */ "./src/pipeData.js");
/* harmony import */ var _blockVertexData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blockVertexData */ "./src/blockVertexData.js");
/* harmony import */ var _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pipeVertexData */ "./src/pipeVertexData.js");



//====================================================================
// ** coorMap.js
//--------------------------------------------------------------------
//    坐标映射（测量-->绘制）
//====================================================================
let title_height = 100;

let minX = Number.POSITIVE_INFINITY,
  maxX = Number.NEGATIVE_INFINITY,
  minY = Number.POSITIVE_INFINITY,
  maxY = Number.NEGATIVE_INFINITY;

for (let i = 0; i < _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin.length; i++) {
  for (let j = 0; j < _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices.length; j++) {
    if (_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[0] < minX) minX = _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[0];
    if (_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[0] > maxX) maxX = _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[0];
    if (_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[1] < minY) minY = _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[1];
    if (_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[1] > maxY) maxY = _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_origin[i].vertices[j].coor[1];
  }
}

for (let i = 0; i < _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData.length; i++) {
  if (_blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex1[0] < minX) minX = _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex1[0];
  if (_blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex2[0] > maxX) maxX = _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex2[0];
  if (_blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex1[1] < minY) minY = _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex1[1];
  if (_blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex2[1] > maxY) maxY = _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData[i].vertex2[1];
}

// 调整各管线以适应屏幕
for (let node in _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData) {
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData[node].coor[0] = ((_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData[node].coor[0] - minX) * window.innerWidth) / (maxX - minX) / 2 + window.innerWidth / 4;
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData[node].coor[1] =
    (((_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData[node].coor[1] - minY) * (window.innerHeight - title_height)) / (maxY - minY)) * 0.98 + title_height;
}
let pipeVertexData_origin = JSON.parse(JSON.stringify(_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.pipeVertexData)); // 保留原始坐标的拷贝

let pipes_noData_drawData = new Array(_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_noData.length); // 无数据坐标点
for (let i = 0; i < pipes_noData_drawData.length; i++) {
  pipes_noData_drawData[i] = new Array(_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_noData[i].length);
  for (let segment = 0; segment < _pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_noData[i].length; segment++) {
    pipes_noData_drawData[i][segment] = new Array(2);
    pipes_noData_drawData[i][segment][0] = ((_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_noData[i][segment][0] - minX) * window.innerWidth) / (maxX - minX) / 2 + window.innerWidth / 4;
    pipes_noData_drawData[i][segment][1] =
      (((_pipeData__WEBPACK_IMPORTED_MODULE_0__.pipeData_noData[i][segment][1] - minY) * (window.innerHeight - title_height)) / (maxY - minY)) * 0.98 + title_height;
  }
}
let pipes_noData_drawData_origin = new Array(pipes_noData_drawData.length);
for (let i = 0; i < pipes_noData_drawData_origin.length; i++) {
  pipes_noData_drawData_origin[i] = new Array(pipes_noData_drawData[i].length);
  for (let j = 0; j < pipes_noData_drawData_origin[i].length; j++) {
    pipes_noData_drawData_origin[i][j] = pipes_noData_drawData[i][j].slice(0);
  }
}

// 调整各水池以适应屏幕
let blockData_fit = _blockVertexData__WEBPACK_IMPORTED_MODULE_1__.blockVertexData.slice(0);
for (let i = 0; i < blockData_fit.length; i++) {
  blockData_fit[i].vertex1[0] = ((blockData_fit[i].vertex1[0] - minX) * window.innerWidth) / (maxX - minX) / 2 + window.innerWidth / 4;
  blockData_fit[i].vertex2[0] = ((blockData_fit[i].vertex2[0] - minX) * window.innerWidth) / (maxX - minX) / 2 + window.innerWidth / 4;
  blockData_fit[i].vertex1[1] = (((blockData_fit[i].vertex1[1] - minY) * (window.innerHeight - title_height)) / (maxY - minY)) * 0.98 + title_height;
  blockData_fit[i].vertex2[1] = (((blockData_fit[i].vertex2[1] - minY) * (window.innerHeight - title_height)) / (maxY - minY)) * 0.98 + title_height;
}

// 调整花里胡哨的节点
let nodes_origin = new Array(_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes.length);
for (let i = 0; i < _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes.length; i++) {
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][0] = ((_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][0] - minX) * window.innerWidth) / (maxX - minX) / 2 + window.innerWidth / 4;
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][1] = (((_pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][1] - minY) * (window.innerHeight - title_height)) / (maxY - minY)) * 0.98 + title_height;
  nodes_origin[i] = new Array(2);
  nodes_origin[i][0] = _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][0];
  nodes_origin[i][1] = _pipeVertexData__WEBPACK_IMPORTED_MODULE_2__.nodes[i][1];
}




/***/ }),

/***/ "./src/mathUtil.js":
/*!*************************!*\
  !*** ./src/mathUtil.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearInterpolation": () => (/* binding */ linearInterpolation),
/* harmony export */   "randNum": () => (/* binding */ randNum)
/* harmony export */ });
// 线性插值
const linearInterpolation = function (val1, val2, prop) {
  return val1 + prop * (val2 - val1);
};

// 生成一个(min, max]范围内的随机数
const randNum = function (min, max) {
  return min + Math.random() * (max - min);
};




/***/ }),

/***/ "./src/pipeData.js":
/*!*************************!*\
  !*** ./src/pipeData.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pipeData_origin": () => (/* binding */ pipeData_origin),
/* harmony export */   "pipeData_noData": () => (/* binding */ pipeData_noData)
/* harmony export */ });
/* harmony import */ var _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeVertexData */ "./src/pipeVertexData.js");

//====================================================================
// ** pipeData.js
//--------------------------------------------------------------------
//    整条管线数据
//====================================================================
let pipeData_origin = [
  { name: "pipe1", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j47, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j46, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input1_1] },
  { name: "pipe2", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j3, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j4, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j6] },
  { name: "pipe3", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input2_1] },
  { name: "pipe4", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j4, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j7, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j9] },
  { name: "pipe5", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_1] },
  { name: "pipe6", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1] },
  {
    name: "pipe7",
    vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output6_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j14, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j15, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j16, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j18, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j20],
  },
  { name: "pipe8", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j17, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_1] },
  { name: "pipe9", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j22, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j20] },
  {
    name: "pipe10",
    vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j13, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j12, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j11, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j10, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input3_2],
  },
  { name: "pipe11", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output6_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j23, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j24, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2] },
  { name: "pipe12", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j24, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j25_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j25_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j26, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j27] },
  { name: "pipe13", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_3, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j28, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j29, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j30] },
  { name: "pipe14", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_3, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j30, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j33] },
  { name: "pipe15", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_4, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j33, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j34, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j35, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input17_2] },
  { name: "pipe16", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_2] },
  { name: "pipe17", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j20, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1] },
  { name: "pipe18", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j21, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j37, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j36] },
  { name: "pipe19", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j36, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input17_1] },
  {
    name: "pipe20",
    vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j38, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j39, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j40, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j41, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input5_1],
  },
  { name: "pipe21", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j42, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j43, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input13_1] },
  { name: "pipe22", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j48, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j47] },
  { name: "pipe23", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_3, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j49, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j48] },
  { name: "pipe24", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_4, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j50, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j49] },
  { name: "pipe25", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output13_5, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j51, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j50] },
  { name: "pipe26", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output17_1, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j59, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j56 /*, [805, 990]*/] },
  {
    name: "pipe27",
    vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output17_2, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j52, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j53, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j55, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.j56, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData._j60],
  },
  { name: "pipe28", vertices: [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.outside, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input13_2] },
  //{name: 'pipe29', vertices: [[789, 990], [761, 990]]}
];
let pipeData_noData = [
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0], -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0] + 30, -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0] + 30, -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0] + 60, -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0] + 60, -35],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 20, -35],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 20, 200],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 70, 200],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 70, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0], -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output1_1.coor.slice(0)[0] + 30, -130],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 20, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1.coor.slice(0)[1] + 50],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 50, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1.coor.slice(0)[1] + 50],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 20, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1.coor.slice(0)[1] + 90],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0] + 50, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output5_1.coor.slice(0)[1] + 90],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0], -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0] + 30, -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0] + 30, -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0] + 60, -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0] + 60, -35],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0], -130],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output2_1.coor.slice(0)[0] + 30, -130],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0], -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0] + 20, -160],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0] + 20, -35],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0], -100],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0] + 20, -100],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0], -80],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output3_1.coor.slice(0)[0] + 20, -80],
  ],

  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], 235],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], 235],
  ],

  [
    [1700, 250],
    [1700, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
  ],

  [
    [1150, 250],
    [1150, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
  ],

  [
    [1020, 250],
    [1020, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
  ],

  [
    [1300, 250],
    [1300, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
  ],

  // 9污泥浓缩池上下
  [
    [1400, 435],
    [1420, 435],
    [1420, 60],
    [1520, 60],
    [1520, 30],
  ],
  [
    [1480, 60],
    [1480, 30],
  ],
  [
    [1480, -50],
    [1480, -80],
    [1600, -80],
  ],
  [
    [1520, -50],
    [1520, -80],
  ],

  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], 435],
    [1230, 435],
    [1230, 700],
    [1700, 700],
    [1700, 800],
    [1600, 800],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input6_1.coor.slice(0)[0], 475],
    [1230, 475],
  ],

  [
    [1670, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [1670, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
    [1480, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
    [1480, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] + 450],
  ],
  [
    [1600, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [1600, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
  ],
  [
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0], _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] - 30],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] + 30, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] - 30],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] + 30, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] + 450],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] + 550, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] + 450],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] + 550, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] + 670],
    [1600, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1] + 670],
  ],
  [
    [980, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [980, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
    [_pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input7_2.coor.slice(0)[0] + 30, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
  ],
  [
    [1080, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [1080, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 30],
  ],

  [
    [1635, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [1635, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 60],
    [1350, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 60],
    [1350, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output7_2.coor.slice(0)[1]],
  ],
  [
    [1050, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1]],
    [1050, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 60],
    [1350, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.input15_1.coor.slice(0)[1] - 60],
  ],

  [
    [1450, 900],
    [1450, 950],
    [1750, 950],
  ],

  [
    [1420, 770],
    [1420, 740],
    [1650, 740],
    [1650, 670],
    [1650, 660],
    [1000, 660],
    [1000, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1450, 770],
    [1450, 740],
  ],
  [
    [1480, 770],
    [1480, 740],
  ],
  [
    [1030, 660],
    [1030, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1100, 660],
    [1100, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1130, 660],
    [1130, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1530, 660],
    [1530, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1560, 660],
    [1560, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1600, 660],
    [1600, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
  [
    [1630, 660],
    [1630, _pipeVertexData__WEBPACK_IMPORTED_MODULE_0__.pipeVertexData.output15_5.coor.slice(0)[1]],
  ],
];




/***/ }),

/***/ "./src/pipeVertexData.js":
/*!*******************************!*\
  !*** ./src/pipeVertexData.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pipeVertexData": () => (/* binding */ pipeVertexData),
/* harmony export */   "nodes": () => (/* binding */ nodes)
/* harmony export */ });
//=====================================================
// ** pipeVertexData.js
//-----------------------------------------------------
// 这里定义了所有的数据点
//=====================================================
const pipeVertexData = {
  // Data points on pipes
  j1: { use: true, coor: [517, -105], speed: null, temperature: null, pressure: null },
  j3: { use: true, coor: [517, -10], speed: null, temperature: null, pressure: null },
  j4: { use: true, coor: [820, -10], speed: null, temperature: null, pressure: null },
  j6: { use: true, coor: [820, -104], speed: null, temperature: null, pressure: null },
  j7: { use: true, coor: [1096, -10], speed: null, temperature: null, pressure: null },
  j9: { use: true, coor: [1096, -107], speed: null, temperature: null, pressure: null },
  j10: { use: true, coor: [1157, 15], speed: null, temperature: null, pressure: null },
  j11: { use: true, coor: [582, 15], speed: null, temperature: null, pressure: null },
  j12: { use: true, coor: [582, 231], speed: null, temperature: null, pressure: null },
  j13: { use: true, coor: [833, 231], speed: null, temperature: null, pressure: null },
  j14: { use: true, coor: [1225, -100], speed: null, temperature: null, pressure: null },
  j15: { use: true, coor: [1225, 40], speed: null, temperature: null, pressure: null },
  j16: { use: true, coor: [596, 40], speed: null, temperature: null, pressure: null },
  j17: { use: true, coor: [596, 110], speed: null, temperature: null, pressure: null },
  j18: { use: true, coor: [596, 196], speed: null, temperature: null, pressure: null },
  j20: { use: true, coor: [795, 195], speed: null, temperature: null, pressure: null },
  j21: { use: true, coor: [910, 195], speed: null, temperature: null, pressure: null },
  j22: { use: true, coor: [939, 195], speed: null, temperature: null, pressure: null },
  j23: { use: true, coor: [1240, -70], speed: null, temperature: null, pressure: null },
  j24: { use: true, coor: [1240, 105], speed: null, temperature: null, pressure: null },
  j25_1: { use: true, coor: [1240, 135], speed: null, temperature: null, pressure: null },
  j25_2: { use: true, coor: [1202, 135], speed: null, temperature: null, pressure: null },
  j26: { use: true, coor: [1202, 189], speed: null, temperature: null, pressure: null },
  j27: { use: true, coor: [975, 189], speed: null, temperature: null, pressure: null },
  j28: { use: true, coor: [975, 224], speed: null, temperature: null, pressure: null },
  j29: { use: true, coor: [890, 224], speed: null, temperature: null, pressure: null },
  j30: { use: true, coor: [890, 450], speed: null, temperature: null, pressure: null },
  j33: { use: true, coor: [890, 519], speed: null, temperature: null, pressure: null },
  j34: { use: true, coor: [930, 519], speed: null, temperature: null, pressure: null },
  j35: { use: true, coor: [945, 543], speed: null, temperature: null, pressure: null },
  j36: { use: true, coor: [828, 640], speed: null, temperature: null, pressure: null },
  j37: { use: true, coor: [910, 640], speed: null, temperature: null, pressure: null },
  j38: { use: true, coor: [875, 380], speed: null, temperature: null, pressure: null },
  j39: { use: true, coor: [875, 270], speed: null, temperature: null, pressure: null },
  j40: { use: true, coor: [1380, 270], speed: null, temperature: null, pressure: null },
  j41: { use: true, coor: [1380, 111], speed: null, temperature: null, pressure: null },
  j42: { use: true, coor: [559, 129], speed: null, temperature: null, pressure: null },
  j43: { use: true, coor: [559, 741], speed: null, temperature: null, pressure: null },
  j46: { use: true, coor: [517, 638], speed: null, temperature: null, pressure: null },
  j47: { use: true, coor: [632, 638], speed: null, temperature: null, pressure: null },
  j48: { use: true, coor: [665, 638], speed: null, temperature: null, pressure: null },
  j49: { use: true, coor: [698, 638], speed: null, temperature: null, pressure: null },
  j50: { use: true, coor: [731, 638], speed: null, temperature: null, pressure: null },
  j51: { use: true, coor: [763, 638], speed: null, temperature: null, pressure: null },
  j52: { use: true, coor: [1100, 943], speed: null, temperature: null, pressure: null },
  j53: { use: true, coor: [1030, 1016], speed: null, temperature: null, pressure: null },
  j55: { use: true, coor: [866, 1016], speed: null, temperature: null, pressure: null },
  j56: { use: true, coor: [866, 990], speed: null, temperature: null, pressure: null },
  j59: { use: true, coor: [1000, 989], speed: null, temperature: null, pressure: null },

  _j60: { use: true, coor: [550, 990], speed: null, temperature: null, pressure: null },
  outside: { use: true, coor: [750, 1050], speed: null, temperature: null, pressure: null },

  // 各功能池的输入和输出节点
  input1_1: { use: true, coor: [587, -105], speed: null, temperature: null, pressure: null },
  output1_1: { use: true, coor: [784, -105], speed: null, temperature: null, pressure: null },
  input2_1: { use: true, coor: [877, -105], speed: null, temperature: null, pressure: null },
  output2_1: { use: true, coor: [1074, -105], speed: null, temperature: null, pressure: null },
  input3_1: { use: true, coor: [1147, -105], speed: null, temperature: null, pressure: null },
  input3_2: { use: true, coor: [1157, -58], speed: null, temperature: null, pressure: null },
  output3_1: { use: true, coor: [1189, -122], speed: null, temperature: null, pressure: null },
  input5_1: { use: true, coor: [1365, 111], speed: null, temperature: null, pressure: null },
  output5_1: { use: true, coor: [1330, 56], speed: null, temperature: null, pressure: null },
  input6_1: { use: true, coor: [1257, -122], speed: null, temperature: null, pressure: null },
  input6_2: { use: true, coor: [1330, -58], speed: null, temperature: null, pressure: null },
  output6_1: { use: true, coor: [1257, -101], speed: null, temperature: null, pressure: null },
  output6_2: { use: true, coor: [1257, -70], speed: null, temperature: null, pressure: null },
  input7_1: { use: true, coor: [610, 110], speed: null, temperature: null, pressure: null },
  input7_2: { use: true, coor: [1183, 105], speed: null, temperature: null, pressure: null },
  output7_1: { use: true, coor: [610, 129], speed: null, temperature: null, pressure: null },
  output7_2: { use: true, coor: [939, 178], speed: null, temperature: null, pressure: null },
  output7_3: { use: true, coor: [975, 178], speed: null, temperature: null, pressure: null },
  input13_1: { use: true, coor: [615, 741], speed: null, temperature: null, pressure: null },
  input13_2: { use: true, coor: [750, 875], speed: null, temperature: null, pressure: null },
  output13_1: { use: true, coor: [632, 676], speed: null, temperature: null, pressure: null },
  output13_2: { use: true, coor: [665, 676], speed: null, temperature: null, pressure: null },
  output13_3: { use: true, coor: [699, 676], speed: null, temperature: null, pressure: null },
  output13_4: { use: true, coor: [731, 676], speed: null, temperature: null, pressure: null },
  output13_5: { use: true, coor: [763, 676], speed: null, temperature: null, pressure: null },
  input15_1: { use: true, coor: [795, 370], speed: null, temperature: null, pressure: null },
  output15_1: { use: true, coor: [833, 370], speed: null, temperature: null, pressure: null },
  output15_2: { use: true, coor: [857, 380], speed: null, temperature: null, pressure: null },
  output15_3: { use: true, coor: [857, 450], speed: null, temperature: null, pressure: null },
  output15_4: { use: true, coor: [857, 519], speed: null, temperature: null, pressure: null },
  output15_5: { use: true, coor: [828, 600], speed: null, temperature: null, pressure: null },
  input17_1: { use: true, coor: [828, 676], speed: null, temperature: null, pressure: null },
  input17_2: { use: true, coor: [945, 676], speed: null, temperature: null, pressure: null },
  output17_1: { use: true, coor: [1000, 875], speed: null, temperature: null, pressure: null },
  output17_2: { use: true, coor: [1100, 875], speed: null, temperature: null, pressure: null },
};

const nodes = [
  [pipeVertexData.j1.coor.slice(0)[0], -50, 0],
  [pipeVertexData.j6.coor.slice(0)[0], -50, 0],
  [pipeVertexData.j9.coor.slice(0)[0], -70, 0],
  [pipeVertexData.j30.coor.slice(0)[0], 485, 0],
  [pipeVertexData.j21.coor.slice(0)[0], 425, 0],
  [pipeVertexData.j26.coor.slice(0)[0], 160, 0],

  [700, pipeVertexData.j18.coor.slice(0)[1], 1],
  [pipeVertexData.j1.coor.slice(0)[0], 450, 2],
  [pipeVertexData.j1.coor.slice(0)[0], 350, 3],
];




/***/ }),

/***/ "./src/fonts/LEXUS-Bold.ttf":
/*!**********************************!*\
  !*** ./src/fonts/LEXUS-Bold.ttf ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "afb4ea0dce0a017b0f6e.ttf";

/***/ }),

/***/ "./src/icons/magnifier.png":
/*!*********************************!*\
  !*** ./src/icons/magnifier.png ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "b0640c5595a963b22c92.png";

/***/ }),

/***/ "./src/node_pipe_map.json":
/*!********************************!*\
  !*** ./src/node_pipe_map.json ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"pipe_id":"g1","node_id":["j1","input1_1"]},{"pipe_id":"g2","node_id":["j1","j3"]},{"pipe_id":"g3","node_id":["j3","j4"]},{"pipe_id":"g4","node_id":["j4","j6"]},{"pipe_id":"g5","node_id":["j4","j6"]},{"pipe_id":"g6","node_id":["output1_1","j6"]},{"pipe_id":"g7","node_id":["j6","input2_1"]},{"pipe_id":"g8","node_id":["j4","j7"]},{"pipe_id":"g9","node_id":["j7","j9"]},{"pipe_id":"g10","node_id":["j7","j9"]},{"pipe_id":"g11","node_id":["output2_1","j9"]},{"pipe_id":"g12","node_id":["j9","input3_1"]},{"pipe_id":"g13","node_id":["output3_1","input6_1"]},{"pipe_id":"g14","node_id":["j10","input3_2"]},{"pipe_id":"g15","node_id":["j11","j10"]},{"pipe_id":"g16","node_id":["j12","j11"]},{"pipe_id":"g17","node_id":["j13","j12"]},{"pipe_id":"g18","node_id":["output15_1","j13"]},{"pipe_id":"g19","node_id":["output6_1","j14"]},{"pipe_id":"g20","node_id":["j14","j15"]},{"pipe_id":"g21","node_id":["j15","j16"]},{"pipe_id":"g22","node_id":["j16","j17"]},{"pipe_id":"g23","node_id":["j18","j17"]},{"pipe_id":"g24","node_id":["j18","j20"]},{"pipe_id":"g25","node_id":["j18","j20"]},{"pipe_id":"g26","node_id":["j21","j20"]},{"pipe_id":"g27","node_id":["j22","j21"]},{"pipe_id":"g28","node_id":["output7_2","j22"]},{"pipe_id":"g29","node_id":["j17","input7_1"]},{"pipe_id":"g30","node_id":["output6_2","j23"]},{"pipe_id":"g31","node_id":["j23","j24"]},{"pipe_id":"g32","node_id":["j24","input7_2"]},{"pipe_id":"g33","node_id":["j24","j26"]},{"pipe_id":"g34","node_id":["j24","j26"]},{"pipe_id":"g35","node_id":["j26","j27"]},{"pipe_id":"g36","node_id":["output7_3","j27"]},{"pipe_id":"g37","node_id":["j27","j28"]},{"pipe_id":"g38","node_id":["j28","j29"]},{"pipe_id":"g39","node_id":["j29","j30"]},{"pipe_id":"g40","node_id":["output15_3","j30"]},{"pipe_id":"g41","node_id":["j30","j33"]},{"pipe_id":"g42","node_id":["j30","j33"]},{"pipe_id":"g43","node_id":["output15_4","j33"]},{"pipe_id":"g44","node_id":["j33","j34"]},{"pipe_id":"g45","node_id":["j34","j35"]},{"pipe_id":"g46","node_id":["j35","input17_2"]},{"pipe_id":"g47","node_id":["output15_5","j36"]},{"pipe_id":"g48","node_id":["j36","input17_1"]},{"pipe_id":"g49","node_id":["j37","j36"]},{"pipe_id":"g50","node_id":["j21","j37"]},{"pipe_id":"g51","node_id":["output15_2","j38"]},{"pipe_id":"g52","node_id":["j38","j39"]},{"pipe_id":"g53","node_id":["j39","j40"]},{"pipe_id":"g54","node_id":["j40","j41"]},{"pipe_id":"g55","node_id":["j41","input5_1"]},{"pipe_id":"g56","node_id":["output5_1","input6_2"]},{"pipe_id":"g57","node_id":["j20","input15_1"]},{"pipe_id":"g58","node_id":["output7_1","j42"]},{"pipe_id":"g59","node_id":["j42","j43"]},{"pipe_id":"g60","node_id":["j43","input13_1"]},{"pipe_id":"g61","node_id":["j46","j3"]},{"pipe_id":"g62","node_id":["j46","j3"]},{"pipe_id":"g63","node_id":["j46","j3"]},{"pipe_id":"g64","node_id":["j47","j46"]},{"pipe_id":"g65","node_id":["j48","j47"]},{"pipe_id":"g66","node_id":["j49","j48"]},{"pipe_id":"g67","node_id":["j50","j49"]},{"pipe_id":"g68","node_id":["j51","j50"]},{"pipe_id":"g69","node_id":["output13_5","j51"]},{"pipe_id":"g70","node_id":["output13_4","j50"]},{"pipe_id":"g71","node_id":["output13_3","j49"]},{"pipe_id":"g72","node_id":["output13_2","j48"]},{"pipe_id":"g73","node_id":["output13_1","j47"]},{"pipe_id":"g74","node_id":["output17_2","j52"]},{"pipe_id":"g75","node_id":["j52","j53"]},{"pipe_id":"g76","node_id":["j53","j55"]},{"pipe_id":"g77","node_id":["j53","j55"]},{"pipe_id":"g78","node_id":["j55","j56"]},{"pipe_id":"g79","node_id":["j59","j56"]},{"pipe_id":"g80","node_id":["j59","j56"]},{"pipe_id":"g81","node_id":["j59","j56"]},{"pipe_id":"g82","node_id":["output17_1","j59"]},{"pipe_id":"g83","node_id":["j56","outside"]},{"pipe_id":"g84","node_id":["j56","outside"]},{"pipe_id":"g85","node_id":["outside","input13_2"]}]');

/***/ }),

/***/ "./src/output.json":
/*!*************************!*\
  !*** ./src/output.json ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"pipe":1,"flow":300,"speed":0.04144660175558131},{"pipe":2,"flow":300,"speed":0.04144660175558131},{"pipe":3,"flow":150,"speed":0.02072330087779065},{"pipe":4,"flow":50,"speed":0.006907766959263551},{"pipe":5,"flow":50,"speed":0.006907766959263551},{"pipe":6,"flow":300,"speed":0.04144660175558131},{"pipe":7,"flow":350,"speed":0.04835436871484486},{"pipe":8,"flow":100,"speed":0.0138155339185271},{"pipe":9,"flow":100,"speed":0.0138155339185271},{"pipe":10,"flow":100,"speed":0.0138155339185271},{"pipe":11,"flow":350,"speed":0.04835436871484486},{"pipe":12,"flow":450,"speed":0.06216990263337196},{"pipe":13,"flow":550,"speed":0.07598543655189907},{"pipe":14,"flow":100,"speed":0.141471067325718},{"pipe":15,"flow":100,"speed":0.141471067325718},{"pipe":16,"flow":100,"speed":0.141471067325718},{"pipe":17,"flow":100,"speed":0.141471067325718},{"pipe":18,"flow":100,"speed":0.141471067325718},{"pipe":19,"flow":400,"speed":0.0552621356741084},{"pipe":20,"flow":400,"speed":0.0552621356741084},{"pipe":21,"flow":400,"speed":0.0552621356741084},{"pipe":22,"flow":400,"speed":0.0552621356741084},{"pipe":23,"flow":250,"speed":0.03453883479631775},{"pipe":24,"flow":250,"speed":0.03453883479631775},{"pipe":25,"flow":250,"speed":0.03453883479631775},{"pipe":26,"flow":50,"speed":0.006907766959263551},{"pipe":27,"flow":100,"speed":0.0138155339185271},{"pipe":28,"flow":100,"speed":0.0138155339185271},{"pipe":29,"flow":150,"speed":0.02072330087779065},{"pipe":30,"flow":200,"speed":0.03608955799125448},{"pipe":31,"flow":200,"speed":0.03608955799125448},{"pipe":32,"flow":150,"speed":0.02706716849344086},{"pipe":33,"flow":50,"speed":0.00902238949781362},{"pipe":34,"flow":50,"speed":0.00902238949781362},{"pipe":35,"flow":50,"speed":0.00902238949781362},{"pipe":36,"flow":100,"speed":0.01804477899562724},{"pipe":37,"flow":150,"speed":0.02706716849344086},{"pipe":38,"flow":150,"speed":0.02706716849344086},{"pipe":39,"flow":150,"speed":0.02706716849344086},{"pipe":40,"flow":50,"speed":0.00902238949781362},{"pipe":41,"flow":200,"speed":0.03608955799125448},{"pipe":42,"flow":200,"speed":0.03608955799125448},{"pipe":43,"flow":50,"speed":0.00902238949781362},{"pipe":44,"flow":250,"speed":0.04511194748906811},{"pipe":45,"flow":250,"speed":0.04511194748906811},{"pipe":46,"flow":250,"speed":0.04511194748906811},{"pipe":47,"flow":50,"speed":0.006907766959263551},{"pipe":48,"flow":100,"speed":0.0138155339185271},{"pipe":49,"flow":50,"speed":0.006907766959263551},{"pipe":50,"flow":50,"speed":0.006907766959263551},{"pipe":51,"flow":50,"speed":0.110524271348217},{"pipe":52,"flow":50,"speed":0.110524271348217},{"pipe":53,"flow":50,"speed":0.110524271348217},{"pipe":54,"flow":50,"speed":0.110524271348217},{"pipe":55,"flow":50,"speed":0.110524271348217},{"pipe":56,"flow":50,"speed":0.00902238949781362},{"pipe":57,"flow":300,"speed":0.04144660175558131},{"pipe":58,"flow":100,"speed":0.392975187015882},{"pipe":59,"flow":100,"speed":0.392975187015882},{"pipe":60,"flow":100,"speed":0.392975187015882},{"pipe":61,"flow":450,"speed":0.06216990263337196},{"pipe":62,"flow":450,"speed":0.06216990263337196},{"pipe":63,"flow":450,"speed":0.06216990263337196},{"pipe":64,"flow":450,"speed":0.06216990263337196},{"pipe":65,"flow":360,"speed":0.04973592210669757},{"pipe":66,"flow":270,"speed":0.03730194158002317},{"pipe":67,"flow":180,"speed":0.02486796105334878},{"pipe":68,"flow":90,"speed":0.01243398052667439},{"pipe":69,"flow":90,"speed":0.01243398052667439},{"pipe":70,"flow":90,"speed":0.01243398052667439},{"pipe":71,"flow":90,"speed":0.01243398052667439},{"pipe":72,"flow":90,"speed":0.01243398052667439},{"pipe":73,"flow":90,"speed":0.01243398052667439},{"pipe":74,"flow":250,"speed":0.04511194748906811},{"pipe":75,"flow":250,"speed":0.04511194748906811},{"pipe":76,"flow":250,"speed":0.04511194748906811},{"pipe":77,"flow":250,"speed":0.04511194748906811},{"pipe":78,"flow":250,"speed":0.04511194748906811},{"pipe":79,"flow":200,"speed":0.0276310678370542},{"pipe":80,"flow":200,"speed":0.0276310678370542},{"pipe":81,"flow":200,"speed":0.0276310678370542},{"pipe":82,"flow":200,"speed":0.0276310678370542},{"pipe":83,"flow":450,"speed":0.03978873768535806},{"pipe":84,"flow":450,"speed":0.03978873768535806},{"pipe":85,"flow":450,"speed":0.06216990263337196},{"pipe":86,"flow":300,"speed":0.04144660175558131},{"pipe":87,"flow":50,"speed":0.00902238949781362},{"pipe":88,"flow":50,"speed":0.006907766959263551}]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var zrender__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender */ "./node_modules/_zrender@4.3.2@zrender/index.js");
/* harmony import */ var zrender__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zrender__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pipeVertexData */ "./src/pipeVertexData.js");
/* harmony import */ var _pipeData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pipeData */ "./src/pipeData.js");
/* harmony import */ var _coorMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coorMap */ "./src/coorMap.js");
/* harmony import */ var _mathUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mathUtil */ "./src/mathUtil.js");
/* harmony import */ var _node_pipe_map_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_pipe_map.json */ "./src/node_pipe_map.json");
/* harmony import */ var _output_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./output.json */ "./src/output.json");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./style.css */ "./src/style.css");









console.log(zrender__WEBPACK_IMPORTED_MODULE_0__);

const main = document.querySelector("#main");
const magnifier = document.querySelector("#magnifier");
const zr = zrender__WEBPACK_IMPORTED_MODULE_0__.init(main);

//=====================================================
// ** toolTip.js
//-----------------------------------------------------
//  水池提示框和管道提示框
//=====================================================
// 水池提示框
class blockInfoTooltip {
  constructor() {
    this.infoBlock = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 200,
        height: 100,
        r: [10],
      },
      style: {
        fill: "#000",
        shadowBlur: 0,
        shadowColor: "#000",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.infoBlock);

    // 标题
    this.title = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 200,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "车间信息",
        textFill: "#DDD",
        font: "16px Microsoft YaHei",
        textAlign: "center",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.title);
  }
  display(x, y, waterHeight) {
    this.infoBlock.attr({
      // 显示提示框
      shape: { x: x + 5, y: y + 5 },
      style: { opacity: 0.7 },
    });
    this.title.attr({
      // 显示提示框标题
      shape: { x: x + 5, y: y + 21 },
      style: { opacity: 1 },
    });
  }
  vanish() {
    this.infoBlock.attr({ style: { opacity: 0 } });
    this.title.attr({ style: { opacity: 0 } });
  }
}

// 管道提示框
class pipeInfoToolTip {
  constructor() {
    this.infoBlock = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 200,
        height: 200,
        r: [10],
      },
      style: {
        fill: "#000",
        shadowBlur: 0,
        shadowColor: "#000",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.infoBlock);

    // 标题
    this.title = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 200,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "管道信息",
        textFill: "#DDD",
        font: "16px Microsoft YaHei",
        textAlign: "center",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.title);

    // 流速图标
    this.velocity_icon = new zrender__WEBPACK_IMPORTED_MODULE_0__.Image({
      style: {
        x: 0,
        y: 0,
        width: 35,
        height: 35,
        image: "./icons/velocity.png",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.velocity_icon);

    // 流速标签
    this.velocity_label = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "流速：",
        textFill: "#259DDE",
        font: "14px Microsoft YaHei",
        textAlign: "center",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.velocity_label);

    // 流速数值
    this.velocity_value = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "null",
        textFill: "#DDD",
        font: "14px Microsoft YaHei",
        textAlign: "left",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.velocity_value);

    // 温度图标
    this.temperature_icon = new zrender__WEBPACK_IMPORTED_MODULE_0__.Image({
      style: {
        x: 0,
        y: 0,
        width: 35,
        height: 35,
        image: "./icons/temperature.png",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.temperature_icon);

    // 温度标签
    this.temperature_label = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "温度：",
        textFill: "#F87115",
        font: "14px Microsoft YaHei",
        textAlign: "center",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.temperature_label);

    // 温度数值
    this.temperature_value = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "null",
        textFill: "#DDD",
        font: "14px Microsoft YaHei",
        textAlign: "left",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.temperature_value);

    // 压力图标
    this.pressure_icon = new zrender__WEBPACK_IMPORTED_MODULE_0__.Image({
      style: {
        x: 0,
        y: 0,
        width: 35,
        height: 35,
        image: "./icons/pressure.png",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.pressure_icon);

    // 压力标签
    this.pressure_label = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "压力：",
        textFill: "#2EE8B6",
        font: "14px Microsoft YaHei",
        textAlign: "center",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.pressure_label);

    // 压力数值
    this.pressure_value = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
      shape: {
        x: 0,
        y: 0,
        width: 30,
        height: 20,
      },
      style: {
        fill: "transparent",
        text: "null",
        textFill: "#DDD",
        font: "14px Microsoft YaHei",
        textAlign: "left",
        opacity: 0,
      },
      zlevel: 3,
      silent: true,
    });
    zr.add(this.pressure_value);
  }
  display(x, y, velocity, temperature, pressure) {
    this.infoBlock.attr({
      // 显示提示框
      shape: { x: x + 5, y: y + 5 },
      style: { opacity: 0.7 },
    });
    this.title.attr({
      // 显示提示框标题
      shape: { x: x + 5, y: y + 21 },
      style: { opacity: 1 },
    });
    this.velocity_icon.attr({
      // 显示流速图标
      style: {
        x: x + 20,
        y: y + 55,
        opacity: 1,
      },
    });
    this.velocity_label.attr({
      // 显示流速标签
      shape: { x: x + 70, y: y + 65 },
      style: { opacity: 1 },
    });
    this.velocity_value.attr({
      // 显示流速数值
      shape: { x: x + 96, y: y + 65 },
      style: { text: velocity, opacity: 1 },
    });
    this.temperature_icon.attr({
      // 显示温度图标
      style: {
        x: x + 20,
        y: y + 105,
        opacity: 1,
      },
    });
    this.temperature_label.attr({
      // 显示温度标签
      shape: { x: x + 70, y: y + 115 },
      style: { opacity: 1 },
    });
    this.temperature_value.attr({
      // 显示温度数值
      shape: { x: x + 96, y: y + 115 },
      style: { text: temperature, opacity: 1 },
    });
    this.pressure_icon.attr({
      // 显示压力图标
      style: {
        x: x + 20,
        y: y + 155,
        opacity: 1,
      },
    });
    this.pressure_label.attr({
      // 显示压力标签
      shape: { x: x + 70, y: y + 165 },
      style: { opacity: 1 },
    });
    this.pressure_value.attr({
      // 显示压力数值
      shape: { x: x + 96, y: y + 165 },
      style: { text: pressure, opacity: 1 },
    });
  }
  vanish() {
    this.infoBlock.attr({ style: { opacity: 0 } });
    this.title.attr({ style: { opacity: 0 } });
    this.temperature_icon.attr({ style: { opacity: 0 } });
    this.temperature_label.attr({ style: { opacity: 0 } });
    this.temperature_value.attr({ style: { opacity: 0 } });
    this.velocity_icon.attr({ style: { opacity: 0 } });
    this.velocity_label.attr({ style: { opacity: 0 } });
    this.velocity_value.attr({ style: { opacity: 0 } });
    this.pressure_icon.attr({ style: { opacity: 0 } });
    this.pressure_label.attr({ style: { opacity: 0 } });
    this.pressure_value.attr({ style: { opacity: 0 } });
  }
}

//====================================================================
// ** draw.js
//--------------------------------------------------------------------
//    实际绘制（标题和管网）以及提示框的交互
//====================================================================
let pipeInfoBlock = new pipeInfoToolTip(); // 管道提示框
let blockInfoBlock = new blockInfoTooltip(); // 水池提示框

let pipe_drawData = new Array(_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin.length);
for (let i = 0; i < pipe_drawData.length; i++) {
  pipe_drawData[i] = new Array(_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length);
  for (let j = 0; j < _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length; j++) {
    pipe_drawData[i][j] = _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[j].coor.slice(0);
  }
}
// 原始数据深拷贝
let pipe_drawData_origin = new Array(pipe_drawData.length);
for (let i = 0; i < pipe_drawData_origin.length; i++) {
  pipe_drawData_origin[i] = new Array(pipe_drawData[i].length);
  for (let j = 0; j < pipe_drawData_origin[i].length; j++) {
    pipe_drawData_origin[i][j] = pipe_drawData[i][j].slice(0);
  }
}

// 标题文字
// let title = new zrender.Rect({
//   shape: {
//     x: 0,
//     y: 0,
//     width: window.innerWidth,
//     height: 100,
//   },
//   style: {
//     fill: "transparent",
//     text: "管网计算与预警系统",
//     //textFill: '#7BFFF8',
//     textFill: "#7394CF",
//     font: "36px LEXUS 简粗黑 U",
//     fontWeight: "lighter",
//     textAlign: "center",
//   },
//   silent: true,
// });
// zr.add(title);

// 绘制带数据的管道
let pipe_num = pipe_drawData.length;
let pipes = new Array(pipe_num); // 保存所有管道
let pipes_flow = new Array(pipe_num); // 保存所有管道的流动效果
for (let i = 0; i < pipe_num; i++) {
  // 管道本体
  pipes[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Polyline({
    shape: {
      points: pipe_drawData[i],
    },
    style: {
      stroke: "#FF0",
      lineWidth: 5,
    },
    zlevel: 1,
  });
  pipes[i]
    .on("mousemove", (e) => {
      // tooltip交互
      pipes[i].attr({
        style: {
          shadowBlur: 10,
          shadowColor: "#FF0",
        }, // 管线高亮（阴影）
      });
      // console.log(pipeData_origin[i].name);
      // 计算鼠标指向位置的流速、温度、压力
      let m_speed = (0,_mathUtil__WEBPACK_IMPORTED_MODULE_4__.linearInterpolation)(
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].speed,
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].speed,
        zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance([e.offsetX, e.offsetY], [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]) /
          zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance(
            [
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[0],
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[1],
            ],
            [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]
          )
      ).toFixed(2);
      let m_temperature = (0,_mathUtil__WEBPACK_IMPORTED_MODULE_4__.linearInterpolation)(
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].temperature,
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].temperature,
        zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance([e.offsetX, e.offsetY], [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]) /
          zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance(
            [
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[0],
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[1],
            ],
            [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]
          )
      ).toFixed(2);
      let m_pressure = (0,_mathUtil__WEBPACK_IMPORTED_MODULE_4__.linearInterpolation)(
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].pressure,
        _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].pressure,
        zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance([e.offsetX, e.offsetY], [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]) /
          zrender__WEBPACK_IMPORTED_MODULE_0__.vector.distance(
            [
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[0],
              _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices.length - 1].coor[1],
            ],
            [_pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[0], _pipeData__WEBPACK_IMPORTED_MODULE_2__.pipeData_origin[i].vertices[0].coor[1]]
          )
      ).toFixed(2);
      pipeInfoBlock.display(e.offsetX, e.offsetY, m_speed + " m/s", m_temperature + " °C", m_pressure + " KPa");
    })
    .on("mouseout", function () {
      pipes[i].attr({
        style: {
          shadowBlur: 0,
        },
      });
      pipeInfoBlock.vanish();
    });
  zr.add(pipes[i]);

  // 管道流动
  pipes_flow[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Polyline({
    shape: {
      points: pipe_drawData[i],
    },
    style: {
      stroke: "#282C34",
      lineWidth: 3,
      lineDash: [5, 5],
      opacity: 0.7,
    },
    zlevel: 1,
    silent: true,
  });
  pipes_flow[i]
    .animate("style", true)
    .when(1000, {
      lineDashOffset: -1 * 10,
    })
    .done(function () {})
    .start();
  zr.add(pipes_flow[i]);
}

// 绘制不带数据的管道
let pipes_noData = Array(_coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData.length);
for (let i = 0; i < pipes_noData.length; i++) {
  pipes_noData[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Polyline({
    shape: {
      points: _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData[i],
    },
    style: {
      stroke: "#FF0",
      lineWidth: 5,
      opacity: 0.3,
    },
    zlevel: 1,
  });
  zr.add(pipes_noData[i]);
}
let pipes_noData_flow = Array(_coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData.length);
for (let i = 0; i < pipes_noData_flow.length; i++) {
  pipes_noData_flow[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Polyline({
    shape: {
      points: _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData[i],
    },
    style: {
      stroke: "#282C34",
      lineWidth: 3,
      lineDash: [5, 5],
      opacity: 0.7,
    },
    zlevel: 1,
    silent: true,
  });
  pipes_noData_flow[i]
    .animate("style", true)
    .when(1000, {
      lineDashOffset: -1 * 10,
    })
    .done(function () {})
    .start();
  zr.add(pipes_noData_flow[i]);
}

// 绘制水池
let block_num = _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit.length;
let blocks_outer = new Array(block_num);
let blocks_inner = new Array(block_num);
for (let i = 0; i < block_num; i++) {
  // 外框
  blocks_outer[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
    shape: {
      x: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0],
      y: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1],
      width: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[0] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0],
      height: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[1] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1],
    },
    style: {
      fill: "#3A66B6",
    },
    zlevel: 2,
  });
  blocks_outer[i]
    .on("mousemove", function (e) {
      blockInfoBlock.display(e.offsetX, e.offsetY, "26 km/h");
    })
    .on("mouseout", function () {
      blockInfoBlock.vanish();
    });
  zr.add(blocks_outer[i]);

  // 内框
  blocks_inner[i] = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
    shape: {
      x: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0] + 4,
      y: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1] + 4,
      width: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[0] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0] - 8,
      height: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[1] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1] - 8,
    },
    style: {
      //fill: '#282c34',
      fill: "#1A2E51",
      text: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].name,
      textFill: "#7bfff8",
      font: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font,
    },
    zlevel: 2,
  });
  blocks_inner[i]
    .on("mousemove", function (e) {
      blockInfoBlock.display(e.offsetX, e.offsetY, "26 km/h");
    })
    .on("mouseout", function () {
      blockInfoBlock.vanish();
    });
  zr.add(blocks_inner[i]);
}

// 最后加上花里胡哨的节点
/*
let flowerNodes = new Array(nodes.length);
const drawNode_hourglass = function (zr, x, y, direc) {
    let hourglass = new zrender.Polyline({
        style: {stroke: '#0CC', lineWidth: 2},
        zlevel: 2, silent: true,
    });
    switch (direc) {
        case 0:
            hourglass.attr({
                shape: {
                    points: [
                        [x - 5, y - 5],
                        [x + 5, y - 5],
                        [x - 5, y + 5],
                        [x + 5, y + 5],
                        [x - 5, y - 5],
                        [x + 5, y - 5],
                    ]
                },
            });
            break;
        case 1:
            hourglass.attr({
                shape: {
                    points: [
                        [x + 5, y - 5],
                        [x - 5, y + 5],
                        [x - 5, y - 5],
                        [x + 5, y + 5],
                        [x + 5, y - 5],
                        [x - 5, y + 5],
                    ]
                },
            });
            break;
        case 2:
            hourglass.attr({
                shape: {
                    points: [
                        [x, y - 8],
                        [x + 6, y + 4],
                        [x - 6, y + 4],
                        [x, y - 8],
                    ]
                },
            });
            break;
        case 3:
            hourglass = new zrender.Group();
            let tmpRct1 = new zrender.Rect({
                shape: {x: x - 10, y: y - 28, width: 20, height: 56},
                style: {stroke: '#0CC', lineWidth: 2, fill: 'transparent'},
                zlevel: 2, silent: true
            });
            let tmpRct2 = new zrender.Rect({
                shape: {x: x - 6, y: y - 22, width: 12, height: 45},
                style: {stroke: '#0CC', lineWidth: 2, fill: 'transparent'},
                zlevel: 2, silent: true
            });
            let tmpPolyline = new zrender.Polyline({
                shape: {points: [[x - 6, y - 22], [x + 6, y - 12], [x - 6, y - 2], [x + 6, y + 6], [x - 6, y + 18], [x, y + 23], ]},
                style: {stroke: '#0CC', lineWidth: 2},
                zlevel: 2, silent: true
            });
            hourglass.add(tmpRct1);
            hourglass.add(tmpRct2);
            hourglass.add(tmpPolyline);
            break;
    }
    zr.add(hourglass);
    return hourglass;
}

for (let i = 0; i < nodes.length; i++) {
    flowerNodes[i] = drawNode_hourglass(zr, nodes[i][0], nodes[i][1], nodes[i][2]);
}
*/

//====================================================================
// ** magnify.js
//--------------------------------------------------------------------
//    框选放大、移动的视图操作
//====================================================================
let magnify = 1; // 缩放倍数
let totalMagnify = 1;
let magnifyMode = false; // 框选放大模式
let have_exec_mag = false; // 标记是否已经执行过框选放大
let magnify_max = 6,
  magnify_min = 0.5;

magnifier.onclick = function () {
  if (!magnifyMode) {
    magnifyMode = true; // 放大模式
    magnifier.style.backgroundImage = "url(./icons/reset.png)";
    have_exec_mag = false;
  } else {
    magnifyMode = false;
    magnifier.style.backgroundImage = "url(./icons/magnifier.png)";

    totalMagnify = 1;
    // 还原方块
    for (let i = 0; i < block_num; i++) {
      blocks_outer[i].attr({
        shape: {
          x: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0],
          y: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1],
          width: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[0] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0],
          height: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[1] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1],
        },
      });
      blocks_inner[i].attr({
        shape: {
          x: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0] + 4,
          y: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1] + 4,
          width: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[0] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[0] - 8,
          height: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex2[1] - _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].vertex1[1] - 8,
        },
        style: {
          font: _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font,
        },
      });
    }
    // 还原管道
    for (let i = 0; i < pipe_num; i++) {
      // 每条管道
      pipes[i].attr({
        shape: { points: pipe_drawData_origin[i] },
        style: { lineWidth: 5 },
      });
      pipes_flow[i].attr({
        shape: { points: pipe_drawData_origin[i] },
        style: {
          lineWidth: 3,
          lineDash: [5, 5],
          lineDashOffset: 0,
        },
      });
      pipes_flow[i]
        .animate("style", true)
        .when(1000, { lineDashOffset: -1 * 10 })
        .done(function () {})
        .start();
    }
    // 还原不带数据的管道
    for (let i = 0; i < pipes_noData_flow.length; i++) {
      pipes_noData[i].attr({
        shape: { points: _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData_origin[i] },
        style: { lineWidth: 5 },
      });
      pipes_noData_flow[i].attr({
        shape: { points: _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData_origin[i] },
        style: {
          lineWidth: 3,
          lineDash: [5, 5],
          lineDashOffset: 0,
        },
      });
      pipes_noData_flow[i]
        .animate("style", true)
        .when(1000, { lineDashOffset: -1 * 10 })
        .done(function () {})
        .start();
    }
  }
};

let selectFrame = new zrender__WEBPACK_IMPORTED_MODULE_0__.Rect({
  // 选框
  shape: { x: 0, y: 0, width: 0, height: 0 },
  style: { fill: "#000", opacity: 0.4, lineWidth: 1, stroke: "#FFF", lineDash: [5] },
  zlevel: 10,
});

// 开始鼠标框选
let startSelect = false;
let startX, startY, frameWidth, frameHeight; // 选框起始位置与宽高
main.onmousedown = function (e) {
  if (magnifyMode) {
    if (have_exec_mag) {
      mouseDrag = true;
    } else {
      startSelect = true;
      zr.add(selectFrame);
      startX = e.clientX;
      startY = e.clientY;
      selectFrame.attr({ shape: { x: startX, y: startY, width: 0, height: 0 } });
    }
  }
};
main.onmousemove = function (e) {
  if (!have_exec_mag && startSelect) selectFrame.attr({ shape: { width: e.clientX - startX, height: e.clientY - startY } });
  if (mouseDrag) {
    // 更新水池
    for (let i = 0; i < block_num; i++) {
      blocks_outer[i].attr({
        shape: {
          x: blocks_outer[i].shape.x + e.movementX,
          y: blocks_outer[i].shape.y + e.movementY,
        },
      });
      blocks_inner[i].attr({
        shape: {
          x: blocks_inner[i].shape.x + e.movementX,
          y: blocks_inner[i].shape.y + e.movementY,
        },
      });
    }
    // 更新管道
    for (let i = 0; i < pipe_num; i++) {
      // 每条管道
      let pipeNewCoors = new Array(pipes[i].shape.points.length); // 是一个n-by-2的数组，用于临时保存新的折线坐标
      for (let j = 0; j < pipes[i].shape.points.length; j++) {
        pipeNewCoors[j] = new Array(2);
        pipeNewCoors[j][0] = pipes[i].shape.points[j][0] + e.movementX;
        pipeNewCoors[j][1] = pipes[i].shape.points[j][1] + e.movementY;
      }
      pipes[i].attr({ shape: { points: pipeNewCoors } });
      pipes_flow[i].attr({ shape: { points: pipeNewCoors } });
    }
    // 更新无数据的管道
    for (let i = 0; i < _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData.length; i++) {
      let pipeNewCoors_noData = new Array(pipes_noData[i].shape.points.length); // 是一个n-by-2的数组，用于临时保存新的折线坐标
      for (let j = 0; j < pipes_noData[i].shape.points.length; j++) {
        pipeNewCoors_noData[j] = new Array(2);
        pipeNewCoors_noData[j][0] = pipes_noData[i].shape.points[j][0] + e.movementX;
        pipeNewCoors_noData[j][1] = pipes_noData[i].shape.points[j][1] + e.movementY;
      }
      pipes_noData[i].attr({ shape: { points: pipeNewCoors_noData } });
      pipes_noData_flow[i].attr({ shape: { points: pipeNewCoors_noData } });
    }
  }
};
main.onmouseup = function (e) {
  // 框选完毕
  if (magnifyMode)
    if (have_exec_mag) {
      mouseDrag = false;
    } else {
      have_exec_mag = true;
      startSelect = false;
      startX = selectFrame.shape.x;
      startY = selectFrame.shape.y;
      frameWidth = Math.abs(selectFrame.shape.width);
      frameHeight = (frameWidth * window.innerHeight) / window.innerWidth; // 获取选框最终宽高
      zr.remove(selectFrame); // 移除选框
      totalMagnify = window.innerWidth / frameWidth > magnify_max ? magnify_max : window.innerWidth / frameWidth;

      // 放大方块
      for (let i = 0; i < block_num; i++) {
        blocks_outer[i].attr({
          shape: {
            x: (blocks_outer[i].shape.x - startX) * totalMagnify,
            y: (blocks_outer[i].shape.y - startY) * totalMagnify,
            width: blocks_outer[i].shape.width * totalMagnify,
            height: blocks_outer[i].shape.height * totalMagnify,
          },
        });
        blocks_inner[i].attr({
          shape: {
            x: (blocks_inner[i].shape.x - startX) * totalMagnify,
            y: (blocks_inner[i].shape.y - startY) * totalMagnify,
            width: blocks_inner[i].shape.width * totalMagnify,
            height: blocks_inner[i].shape.height * totalMagnify,
          },
          style: {
            font:
              parseInt(_coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.slice(0, _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.indexOf("px"))) * totalMagnify +
              _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.substr(_coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.indexOf("px")),
          },
        });
      }
      // 放大管道
      for (let i = 0; i < pipe_num; i++) {
        // 每条管道
        let pipeNewCoors = new Array(pipes[i].shape.points.length); // 是一个n-by-2的数组，用于临时保存新的折线坐标
        for (let j = 0; j < pipes[i].shape.points.length; j++) {
          pipeNewCoors[j] = new Array(2);
          pipeNewCoors[j][0] = (pipes[i].shape.points[j][0] - startX) * totalMagnify;
          pipeNewCoors[j][1] = (pipes[i].shape.points[j][1] - startY) * totalMagnify;
        }
        pipes[i].attr({
          shape: { points: pipeNewCoors },
          style: { lineWidth: 5 * totalMagnify },
        });
        pipes_flow[i].attr({
          shape: { points: pipeNewCoors },
          style: {
            lineWidth: 3 * totalMagnify,
            lineDash: [5 * totalMagnify, 5 * totalMagnify],
            lineDashOffset: 0,
          },
        });
        pipes_flow[i]
          .animate("style", true)
          .when(1000, { lineDashOffset: -1 * (10 * totalMagnify) })
          .done(function () {})
          .start();
      }
      // 放大不带数据的管道
      for (let i = 0; i < _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData.length; i++) {
        let pipeNewCoors_noData = new Array(pipes_noData[i].shape.points.length); // 是一个n-by-2数组，临时保存
        for (let j = 0; j < pipes_noData[i].shape.points.length; j++) {
          pipeNewCoors_noData[j] = new Array(2);
          pipeNewCoors_noData[j][0] = (pipes_noData[i].shape.points[j][0] - startX) * totalMagnify;
          pipeNewCoors_noData[j][1] = (pipes_noData[i].shape.points[j][1] - startY) * totalMagnify;
        }

        pipes_noData[i].attr({
          shape: { points: pipeNewCoors_noData },
          style: { lineWidth: 5 * totalMagnify },
        });
        pipes_noData_flow[i].attr({
          shape: { points: pipeNewCoors_noData },
          style: {
            lineWidth: 3 * totalMagnify,
            lineDash: [5 * totalMagnify, 5 * totalMagnify],
            lineDashOffset: 0,
          },
        });
        pipes_noData_flow[i]
          .animate("style", true)
          .when(1000, { lineDashOffset: -1 * (10 * totalMagnify) })
          .done(function () {})
          .start();
      }
    }
};

// 缩放
main.onmousewheel = function (e) {
  if (magnifyMode) {
    magnify = 1 + Math.round(e.zrDelta) * 0.06; // 倍数更新
    if (totalMagnify * magnify >= magnify_max || totalMagnify * magnify <= magnify_min) magnify = 1; // 缩放限制
    totalMagnify *= magnify;
    // 放大方块
    for (let i = 0; i < block_num; i++) {
      blocks_outer[i].attr({
        shape: {
          x: magnify * (blocks_outer[i].shape.x - e.clientX) + e.clientX,
          y: magnify * (blocks_outer[i].shape.y - e.clientY) + e.clientY,
          width: blocks_outer[i].shape.width * magnify,
          height: blocks_outer[i].shape.height * magnify,
        },
      });
      blocks_inner[i].attr({
        shape: {
          x: magnify * (blocks_inner[i].shape.x - e.clientX) + e.clientX,
          y: magnify * (blocks_inner[i].shape.y - e.clientY) + e.clientY,
          width: blocks_inner[i].shape.width * magnify,
          height: blocks_inner[i].shape.height * magnify,
        },
        style: {
          font:
            parseInt(_coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.slice(0, _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.indexOf("px"))) * totalMagnify +
            _coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.substr(_coorMap__WEBPACK_IMPORTED_MODULE_3__.blockData_fit[i].font.indexOf("px")),
        },
      });
    }
    // 放大管道
    for (let i = 0; i < pipe_num; i++) {
      // 每条管道
      let pipeNewCoors = new Array(pipes[i].shape.points.length); // 是一个n-by-2的数组，用于临时保存新的折线坐标
      for (let j = 0; j < pipes[i].shape.points.length; j++) {
        pipeNewCoors[j] = new Array(2);
        pipeNewCoors[j][0] = magnify * (pipes[i].shape.points[j][0] - e.clientX) + e.clientX;
        pipeNewCoors[j][1] = magnify * (pipes[i].shape.points[j][1] - e.clientY) + e.clientY;
      }
      pipes[i].attr({
        shape: { points: pipeNewCoors },
        style: { lineWidth: 5 * totalMagnify },
      });
      pipes_flow[i].attr({
        shape: { points: pipeNewCoors },
        style: {
          lineWidth: 3 * totalMagnify,
          lineDash: [5 * totalMagnify, 5 * totalMagnify],
          lineDashOffset: 0,
        },
      });
      pipes_flow[i]
        .animate("style", true)
        .when(1000, { lineDashOffset: -1 * (10 * totalMagnify) })
        .done(function () {})
        .start();
    }
    // 放大无数据的管道
    for (let i = 0; i < _coorMap__WEBPACK_IMPORTED_MODULE_3__.pipes_noData_drawData.length; i++) {
      let pipeNewCoors_noData = new Array(pipes_noData[i].shape.points.length); // 是一个n-by-2的数组，用于临时保存新的折线坐标
      for (let j = 0; j < pipes_noData[i].shape.points.length; j++) {
        pipeNewCoors_noData[j] = new Array(2);
        pipeNewCoors_noData[j][0] = magnify * (pipes_noData[i].shape.points[j][0] - e.clientX) + e.clientX;
        pipeNewCoors_noData[j][1] = magnify * (pipes_noData[i].shape.points[j][1] - e.clientY) + e.clientY;
      }

      pipes_noData[i].attr({
        shape: { points: pipeNewCoors_noData },
        style: { lineWidth: 5 * totalMagnify },
      });
      pipes_noData_flow[i].attr({
        shape: { points: pipeNewCoors_noData },
        style: {
          lineWidth: 3 * totalMagnify,
          lineDash: [5 * totalMagnify, 5 * totalMagnify],
          lineDashOffset: 0,
        },
      });
      pipes_noData_flow[i]
        .animate("style", true)
        .when(1000, { lineDashOffset: -1 * (10 * totalMagnify) })
        .done(function () {})
        .start();
    }
  }
};

// 拖动
let mouseDrag = false;
//=====================================================
// ** dataInitialize.js
//-----------------------------------------------------
// 初始化数据点的相关属性（流速、温度、压力）
//=====================================================
for (let node in _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData) {
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData[node].speed = Math.random() * 100;
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData[node].temperature = Math.random() * 100;
  _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData[node].pressure = Math.random() * 100;
}
for (let p of _output_json__WEBPACK_IMPORTED_MODULE_6__) {
  let speed = p.speed.toFixed(4);
  let pipe_id = "g" + p.pipe;
  for (let map of _node_pipe_map_json__WEBPACK_IMPORTED_MODULE_5__) {
    if (map["pipe_id"] == pipe_id) {
      // console.log("speed =", speed);
      _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData[map["node_id"][0]].speed = parseFloat(speed);
      _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData[map["node_id"][1]].speed = parseFloat(speed);
    }
  }
}
//=====================================================
// ** dataUpdate.js
//-----------------------------------------------------
//  Update speed, temperature, pressure of data points
//=====================================================
setInterval(function () {
  for (let node in _pipeVertexData__WEBPACK_IMPORTED_MODULE_1__.pipeVertexData) {
    // pipeVertexData[node].speed += randNum(-1, 1);
    // pipeVertexData[node].temperature += randNum(-1, 1);
    // pipeVertexData[node].pressure += randNum(-1, 1);
  }
}, 1000);

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxhQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxTQUFTOztBQUVoQjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3pYQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7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QTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7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R1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEUsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxhQUFhLE9BQU8sZUFBZSxTQUFTLFlBQVksZ0JBQWdCO0FBQy9IO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sWUFBWTtBQUNsQjs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBLG1JQUFtSTs7QUFFbkksNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0RUFBNEUscURBQXFEO0FBQ2pJO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FOztBQUVwRSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7O0FBRTlILCtFQUErRTs7QUFFL0U7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMLHNFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRCxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMxK0JBLG1CQUFPLENBQUMsMkVBQVc7O0FBRW5CLGVBQWUsbUJBQU8sQ0FBQyx3RUFBWTs7QUFFbkM7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDJFQUFXOztBQUVqQzs7Ozs7Ozs7OztBQ1JBLFdBQVcsbUJBQU8sQ0FBQywyRUFBYTs7QUFFaEMsVUFBVSxtQkFBTyxDQUFDLHlFQUFZOztBQUU5QixhQUFhLG1CQUFPLENBQUMsMkVBQWE7O0FBRWxDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBVzs7QUFFakMsY0FBYyxtQkFBTyxDQUFDLHVFQUFXOztBQUVqQyxjQUFjLG1CQUFPLENBQUMsdUVBQVc7O0FBRWpDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUF1Qjs7QUFFL0MsbUJBQW1CLG1CQUFPLENBQUMseUZBQW9COztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFB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QUMzUDVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4RUFBOEU7QUFDdEYsUUFBUSw2RUFBNkU7QUFDckYsUUFBUSw2RUFBNkU7QUFDckYsUUFBUSw4RUFBOEU7QUFDdEYsUUFBUSw4RUFBOEU7QUFDdEYsUUFBUSwrRUFBK0U7QUFDdkYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw0RUFBNEU7QUFDckYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUywrRUFBK0U7QUFDeEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw0RUFBNEU7QUFDckYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUyw4RUFBOEU7QUFDdkYsV0FBVyw4RUFBOEU7QUFDekYsV0FBVyw4RUFBOEU7QUFDekYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw2RUFBNkU7QUFDdEYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUywrRUFBK0U7QUFDeEYsU0FBUyw4RUFBOEU7QUFDdkYsU0FBUyw2RUFBNkU7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QUNsRSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQiw2QkFBNkI7QUFDOUMsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEUsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLGtFQUE0QixFQUFFO0FBQ3RELGdGQUFnRjtBQUNoRixzQkFBc0IseUNBQXlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUMsaUJBQWlCLDZCQUE2QjtBQUM5QyxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFjO0FBQy9CLEVBQUUsMkRBQWM7QUFDaEIsRUFBRSwyREFBYztBQUNoQixFQUFFLDJEQUFjO0FBQ2hCO0FBQ0EsY0FBYyx5Q0FBTTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFhO0FBQy9CO0FBQ0E7QUFDQSxNQUFNLDJEQUFjO0FBQ3BCLE1BQU0sMkRBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BpcGUvLi9zcmMvc3R5bGUuY3NzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJANi41LjFAY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJANi41LjFAY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJANi41LjFAY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vc3JjL3N0eWxlLmNzcz83ZDFiIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAzLjMuMUBzdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMy4zLjFAc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAzLjMuMUBzdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL19zdHlsZS1sb2FkZXJAMy4zLjFAc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2luZGV4LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9MYXllci5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb250YWluL3BhdGguanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvcmUvTFJVLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2FycmF5RGlmZjIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvY29yZS9kb20uanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2ZvdXJQb2ludHNUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2d1aWQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvY29yZS91dGlsLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZXhwb3J0LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0luY3JlbWVudGFsRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2NvbnN0YW50LmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zdWJQaXhlbE9wdGltaXplLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvRHJvcGxldC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvSGVhcnQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0lzb2dvbi5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1Jvc2UuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU3Rhci5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvVHJvY2hvaWQuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvc3ZnL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9zdmcvY29yZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL3N2Zy9ncmFwaGljLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvc3ZnL2hlbHBlci9DbGlwcGF0aE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi9zdmcvaGVscGVyL0RlZmluYWJsZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL3N2Zy9oZWxwZXIvR3JhZGllbnRNYW5hZ2VyLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvc3ZnL2hlbHBlci9TaGFkb3dNYW5hZ2VyLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvc3ZnL3N2Zy5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi90b29sL3BhcnNlU1ZHLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL25vZGVfbW9kdWxlcy9fenJlbmRlckA0LjMuMkB6cmVuZGVyL2xpYi92bWwvY29yZS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzIiwid2VicGFjazovL3BpcGUvLi9ub2RlX21vZHVsZXMvX3pyZW5kZXJANC4zLjJAenJlbmRlci9saWIvdm1sL3ZtbC5qcyIsIndlYnBhY2s6Ly9waXBlLy4vbm9kZV9tb2R1bGVzL196cmVuZGVyQDQuMy4yQHpyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL3NyYy9ibG9ja1ZlcnRleERhdGEuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL3NyYy9jb29yTWFwLmpzIiwid2VicGFjazovL3BpcGUvLi9zcmMvbWF0aFV0aWwuanMiLCJ3ZWJwYWNrOi8vcGlwZS8uL3NyYy9waXBlRGF0YS5qcyIsIndlYnBhY2s6Ly9waXBlLy4vc3JjL3BpcGVWZXJ0ZXhEYXRhLmpzIiwid2VicGFjazovL3BpcGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcGlwZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9waXBlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9waXBlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcGlwZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3BpcGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9waXBlL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3BpcGUvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vcGlwZS8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDYuNS4xQGNzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckA2LjUuMUBjc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJANi41LjFAY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiLi9mb250cy9MRVhVUy1Cb2xkLnR0ZlwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fID0gbmV3IFVSTChcIi4vaWNvbnMvbWFnbmlmaWVyLnBuZ1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAZm9udC1mYWNlIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiBcXFwibGV4dXNcXFwiO1xcclxcbiAgc3JjOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcclxcbn1cXHJcXG4qIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcbmh0bWwsXFxyXFxuYm9keSxcXHJcXG4jbWFpbiB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuYm9keSB7XFxyXFxuICBvdmVyZmxvdzogYXV0byBoaWRkZW47XFxyXFxuICBiYWNrZ3JvdW5kOiAjMWEyZTUxO1xcclxcbn1cXHJcXG5oMSB7XFxyXFxuICBmb250LXNpemU6IDM2cHg7XFxyXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbiAgZm9udC1mYW1pbHk6IFxcXCJsZXh1c1xcXCI7XFxyXFxuICBjb2xvcjogIzczOTRjZjtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogMzBweDtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXHJcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG4jbWFnbmlmaWVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICM2NjYgdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKSBuby1yZXBlYXQgY2VudGVyO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiA3MCUgNzAlO1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgd2lkdGg6IDM2cHg7XFxyXFxuICBoZWlnaHQ6IDM2cHg7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDM2cHg7XFxyXFxuICBsZWZ0OiA2Ni42dnc7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxvQkFBb0I7RUFDcEIsNENBQWtDO0FBQ3BDO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsVUFBVTtBQUNaO0FBQ0E7OztFQUdFLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7QUFDQTtFQUNFLHFCQUFxQjtFQUNyQixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGVBQWU7RUFDZixtQkFBbUI7RUFDbkIsb0JBQW9CO0VBQ3BCLGNBQWM7RUFDZCxrQkFBa0I7RUFDbEIsU0FBUztFQUNULFNBQVM7RUFDVCwyQkFBMkI7RUFDM0IsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSx5RUFBNEQ7RUFDNUQsd0JBQXdCO0VBQ3hCLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsV0FBVztFQUNYLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsU0FBUztFQUNULFlBQVk7RUFDWixlQUFlO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkBmb250LWZhY2Uge1xcclxcbiAgZm9udC1mYW1pbHk6IFxcXCJsZXh1c1xcXCI7XFxyXFxuICBzcmM6IHVybChcXFwiLi9mb250cy9MRVhVUy1Cb2xkLnR0ZlxcXCIpO1xcclxcbn1cXHJcXG4qIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcbmh0bWwsXFxyXFxuYm9keSxcXHJcXG4jbWFpbiB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuYm9keSB7XFxyXFxuICBvdmVyZmxvdzogYXV0byBoaWRkZW47XFxyXFxuICBiYWNrZ3JvdW5kOiAjMWEyZTUxO1xcclxcbn1cXHJcXG5oMSB7XFxyXFxuICBmb250LXNpemU6IDM2cHg7XFxyXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbiAgZm9udC1mYW1pbHk6IFxcXCJsZXh1c1xcXCI7XFxyXFxuICBjb2xvcjogIzczOTRjZjtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogMzBweDtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXHJcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG4jbWFnbmlmaWVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICM2NjYgdXJsKC4vaWNvbnMvbWFnbmlmaWVyLnBuZykgbm8tcmVwZWF0IGNlbnRlcjtcXHJcXG4gIGJhY2tncm91bmQtc2l6ZTogNzAlIDcwJTtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG4gIHdpZHRoOiAzNnB4O1xcclxcbiAgaGVpZ2h0OiAzNnB4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAzNnB4O1xcclxcbiAgbGVmdDogNjYuNnZ3O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpOyAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAzLjMuMUBzdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvX3N0eWxlLWxvYWRlckAzLjMuMUBzdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9fc3R5bGUtbG9hZGVyQDMuMy4xQHN0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckA2LjUuMUBjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDYuNS4xQGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwidmFyIF96cmVuZGVyID0gcmVxdWlyZShcIi4vbGliL3pyZW5kZXJcIik7XG5cbihmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGtleSBpbiBfenJlbmRlcikge1xuICAgIGlmIChfenJlbmRlciA9PSBudWxsIHx8ICFfenJlbmRlci5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGtleSA9PT0gJ2RlZmF1bHQnIHx8IGtleSA9PT0gJ19fZXNNb2R1bGUnKSByZXR1cm47XG4gICAgZXhwb3J0c1trZXldID0gX3pyZW5kZXJba2V5XTtcbiAgfVxufSkoKTtcblxudmFyIF9leHBvcnQgPSByZXF1aXJlKFwiLi9saWIvZXhwb3J0XCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBrZXkgaW4gX2V4cG9ydCkge1xuICAgIGlmIChfZXhwb3J0ID09IG51bGwgfHwgIV9leHBvcnQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBrZXkgPT09ICdkZWZhdWx0JyB8fCBrZXkgPT09ICdfX2VzTW9kdWxlJykgcmV0dXJuO1xuICAgIGV4cG9ydHNba2V5XSA9IF9leHBvcnRba2V5XTtcbiAgfVxufSkoKTtcblxucmVxdWlyZShcIi4vbGliL3N2Zy9zdmdcIik7XG5cbnJlcXVpcmUoXCIuL2xpYi92bWwvdm1sXCIpOyIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9UcmFuc2Zvcm1hYmxlXCIpO1xuXG52YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0FuaW1hdGFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqL1xudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiDnlLvluIPlhYPntKBJRFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOWFg+e0oOexu+Wei1xuICAgKiBFbGVtZW50IHR5cGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdlbGVtZW50JyxcblxuICAvKipcbiAgICog5YWD57Sg5ZCN5a2XXG4gICAqIEVsZW1lbnQgbmFtZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbmFtZTogJycsXG5cbiAgLyoqXG4gICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICovXG4gIF9fenI6IG51bGwsXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlOiBmYWxzZSxcblxuICAvKipcbiAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBjbGlwUGF0aDogbnVsbCxcblxuICAvKipcbiAgICog5piv5ZCm5pivIEdyb3VwXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgaXNHcm91cDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERyaWZ0IGVsZW1lbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKi9cbiAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgZHkgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBkeCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9XG5cbiAgICBtWzRdICs9IGR4O1xuICAgIG1bNV0gKz0gZHk7XG4gICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAqL1xuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgKi9cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAqL1xuICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHpyKSB7XG4gICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfSAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG5cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKi9cbiAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgfVxuXG4gICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcbiAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSB6cjsgLy8g5re75Yqg5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0gbnVsbDsgLy8g56e76Zmk5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICB9XG4gIH1cbn07XG56clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBEcmFnZ2FibGUgPSByZXF1aXJlKFwiLi9taXhpbi9EcmFnZ2FibGVcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZXZlbnRUb29sID0gcmVxdWlyZShcIi4vY29yZS9ldmVudFwiKTtcblxudmFyIEdlc3R1cmVNZ3IgPSByZXF1aXJlKFwiLi9jb3JlL0dlc3R1cmVNZ3JcIik7XG5cbi8qKlxuICogW1RoZSBpbnRlcmZhY2UgYmV0d2VlbiBgSGFuZGxlcmAgYW5kIGBIYW5kbGVyUHJveHlgXTpcbiAqXG4gKiBUaGUgZGVmYXVsdCBgSGFuZGxlclByb3h5YCBvbmx5IHN1cHBvcnQgdGhlIGNvbW1vbiBzdGFuZGFyZCB3ZWIgZW52aXJvbm1lbnRcbiAqIChlLmcuLCBzdGFuZGFsb25lIGJyb3dzZXIsIGhlYWRsZXNzIGJyb3dzZXIsIGVtYmVkIGJyb3dzZXIgaW4gbW9iaWxkIEFQUCwgLi4uKS5cbiAqIEJ1dCBgSGFuZGxlclByb3h5YCBjYW4gYmUgcmVwbGFjZWQgdG8gc3VwcG9ydCBtb3JlIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudFxuICogKGUuZy4sIG1pbmkgYXBwKSwgb3IgdG8gc3VwcG9ydCBtb3JlIGZlYXR1cmUgdGhhdCB0aGUgZGVmYXVsdCBgSGFuZGxlclByb3h5YFxuICogbm90IHByb3ZpZGVkIChsaWtlIGVjaGFydHMtZ2wgZGlkKS5cbiAqIFNvIHRoZSBpbnRlcmZhY2UgYmV0d2VlbiBgSGFuZGxlcmAgYW5kIGBIYW5kbGVyUHJveHlgIHNob3VsZCBiZSBzdGFibGUuIERvIG5vdFxuICogbWFrZSBicmVhayBjaGFuZ2VzIHV0aWwgaW5ldml0YWJsZS4gVGhlIGludGVyZmFjZSBpbmNsdWRlIHRoZSBwdWJsaWMgbWV0aG9kc1xuICogb2YgYEhhbmRsZXJgIGFuZCB0aGUgZXZlbnRzIGxpc3RlZCBpbiBgaGFuZGxlck5hbWVzYCBiZWxvdywgYnkgd2hpY2ggYEhhbmRsZXJQcm94eWBcbiAqIGRyaXZlcyBgSGFuZGxlcmAuXG4gKi9cblxuLyoqXG4gKiBbRHJhZyBvdXRzaWRlXTpcbiAqXG4gKiBUaGF0IGlzLCB0cmlnZ2VyaW5nIGBtb3VzZW1vdmVgIGFuZCBgbW91c2V1cGAgZXZlbnQgd2hlbiB0aGUgcG9pbnRlciBpcyBvdXQgb2YgdGhlXG4gKiB6cmVuZGVyIGFyZWEgd2hlbiBkcmFnZ2luZy4gVGhhdCBpcyBpbXBvcnRhbnQgZm9yIHRoZSBpbXByb3ZlbWVudCBvZiB0aGUgdXNlciBleHBlcmllbmNlXG4gKiB3aGVuIGRyYWdnaW5nIHNvbWV0aGluZyBuZWFyIHRoZSBib3VuZGFyeSB3aXRob3V0IGJlaW5nIHRlcm1pbmF0ZWQgdW5leHBlY3RlZGx5LlxuICpcbiAqIFdlIG9yaWdpbmFsbHkgY29uc2lkZXIgdG8gaW50cm9kdWNlIG5ldyBldmVudHMgbGlrZSBgcGFnZW1vdmVtb3ZlYCBhbmQgYHBhZ2Vtb3VzZXVwYFxuICogdG8gcmVzb2x2ZSB0aGlzIGlzc3VlLiBCdXQgc29tZSBkcmF3YmFja3Mgb2YgaXQgaXMgZGVzY3JpYmVkIGluXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvcHVsbC81MzYjaXNzdWVjb21tZW50LTU2MDI4Njg5OVxuICpcbiAqIEluc3RlYWQsIHdlIHJlZmVyZW5jZWQgdGhlIHNwZWNpZmljYXRpb25zOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy8jdGhlLXRvdWNobW92ZS1ldmVudFxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTQvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTQwOTI1LyNldmVudC10eXBlLW1vdXNlbW92ZVxuICogd2hlcmUgdGhlIHRoZSBtb3VzZW1vdmUvdG91Y2htb3ZlIGNhbiBiZSBjb250aW51ZSB0byBmaXJlIGlmIHRoZSB1c2VyIGJlZ2FuIGEgZHJhZ1xuICogb3BlcmF0aW9uIGFuZCB0aGUgcG9pbnRlciBoYXMgbGVmdCB0aGUgYm91bmRhcnkuIChmb3IgdGhlIG1vdXNlIGV2ZW50LCBicm93c2Vyc1xuICogb25seSBkbyBpdCBvbiBgZG9jdW1lbnRgIGFuZCB3aGVuIHRoZSBwb2ludGVyIGhhcyBsZWZ0IHRoZSBib3VuZGFyeSBvZiB0aGUgYnJvd3Nlci4pXG4gKlxuICogU28gdGhlIGRlZmF1bHQgYEhhbmRsZXJQcm94eWAgc3VwcG9ydHMgdGhpcyBmZWF0dXJlIHNpbWlsYXJseTogaWYgaXQgaXMgaW4gdGhlIGRyYWdnaW5nXG4gKiBzdGF0ZSAoc2VlIGBwb2ludGVyQ2FwdHVyZWAgaW4gYEhhbmRsZXJQcm94eWApLCB0aGUgYG1vdXNlbW92ZWAgYW5kIGBtb3VzZXVwYCBjb250aW51ZVxuICogdG8gZmlyZSB1bnRpbCByZWxlYXNlIHRoZSBwb2ludGVyLiBUaGF0IGlzIGltcGxlbWVudGVkIGJ5IGxpc3RlbiB0byB0aG9zZSBldmVudCBvblxuICogYGRvY3VtZW50YC5cbiAqIElmIHdlIGltcGxlbWVudCBzb21lIG90aGVyIGBIYW5kbGVyUHJveHlgIG9ubHkgZm9yIHRvdWNoIGRldmljZSwgdGhhdCB3b3VsZCBiZSBlYXNpZXIuXG4gKiBUaGUgdG91Y2ggZXZlbnQgc3VwcG9ydCB0aGlzIGZlYXR1cmUgYnkgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOlxuICogVGhlcmUgbWlnaHQgYmUgc29tZSBjYXNlcyB0aGF0IHRoZSBtb3VzZSBldmVudCBjYW4gbm90IGJlXG4gKiByZWNlaXZlZCBvbiBgZG9jdW1lbnRgLiBGb3IgZXhhbXBsZSxcbiAqIChBKSBgdXNlQ2FwdHVyZWAgaXMgbm90IHN1cHBvcnRlZCBhbmQgc29tZSB1c2VyIGRlZmluZWQgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBhbmNlc3RvclxuICogb2YgenIgZG9tIHRocm93IEVycm9yIC5cbiAqIChCKSBgdXNlQ2FwdHVyZWAgaXMgbm90IHN1cHBvcnRlZCBTb21lIHVzZXIgZGVmaW5lZCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFuY2VzdG9yIG9mXG4gKiB6ciBkb20gY2FsbCBgc3RvcFByb3BhZ2F0aW9uYC5cbiAqIEluIHRoZXNlIGNhc2VzLCB0aGUgYG1vdXNlbW92ZWAgZXZlbnQgbWlnaHQgYmUga2VlcCB0cmlnZ2VyZWQgZXZlbnRcbiAqIGlmIHRoZSBtb3VzZSBpcyByZWxlYXNlZC4gV2UgdHJ5IHRvIHJlZHVjZSB0aGUgc2lkZS1lZmZlY3QgaW4gdGhvc2UgY2FzZXMuXG4gKiBUaGF0IGlzLCBkbyBub3RoaW5nIChlc3BlY2lhbGx5LCBgZmluZEhvdmVyYCkgaW4gdGhvc2UgY2FzZXMuIFNlZSBgaXNPdXRzaWRlQm91bmRhcnlgLlxuICpcbiAqIE5vdGU6XG4gKiBJZiBgSGFuZGxlclByb3h5YCBsaXN0ZW5zIHRvIGBkb2N1bWVudGAgd2l0aCBgdXNlQ2FwdHVyZWAsIGBIYW5kbGVyUHJveHlgIG5lZWRzIHRvXG4gKiBtYWtlIHN1cmUgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgZG9pbmcgbm90aGluZyBpZiBhbmQgb25seSBpZiB0aGUgZXZlbnRcbiAqIHRhcmdldCBpcyBub3QgenJlbmRlciBkb20uIEJlY3Vhc2UgaXQgaXMgZGFuZ2Vyb3VzIHRvIGVuYWJsZSB1c2VycyB0byBjYWxsIHRoZW0gaW5cbiAqIGBkb2N1bWVudGAgY2FwdHVyZSBwaGFzZSB0byBwcmV2ZW50IHRoZSBwcm9wYWdhdGlvbiB0byBhbnkgbGlzdGVuZXIgb2YgdGhlIHdlYnBhZ2UuXG4gKiBCdXQgdGhleSBhcmUgbmVlZGVkIHRvIHdvcmsgd2hlbiB0aGUgcG9pbnRlciBpbnNpZGUgdGhlIHpyZW5kZXIgZG9tLlxuICovXG52YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgd2hpY2g6IGV2ZW50LndoaWNoLFxuICAgIHN0b3A6IHN0b3BFdmVudFxuICB9O1xufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnQoKSB7XG4gIGV2ZW50VG9vbC5zdG9wKHRoaXMuZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBFbXB0eVByb3h5KCkge31cblxuRW1wdHlQcm94eS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eX0gcHJveHkgSGFuZGxlclByb3h5IGluc3RhbmNlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gKi9cblxudmFyIEhhbmRsZXIgPSBmdW5jdGlvbiAoc3RvcmFnZSwgcGFpbnRlciwgcHJveHksIHBhaW50ZXJSb290KSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMucGFpbnRlclJvb3QgPSBwYWludGVyUm9vdDtcbiAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuICAvKipcbiAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgKi9cblxuICB0aGlzLnByb3h5ID0gbnVsbDtcbiAgLyoqXG4gICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RYO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFk7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgKi9cblxuICB0aGlzLl9nZXN0dXJlTWdyO1xuICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRIYW5kbGVyUHJveHkocHJveHkpO1xufTtcblxuSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuICBzZXRIYW5kbGVyUHJveHk6IGZ1bmN0aW9uIChwcm94eSkge1xuICAgIGlmICh0aGlzLnByb3h5KSB7XG4gICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBpZiAocHJveHkpIHtcbiAgICAgIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgfSwgdGhpcyk7IC8vIEF0dGFjaCBoYW5kbGVyXG5cbiAgICAgIHByb3h5LmhhbmRsZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMucHJveHkgPSBwcm94eTtcbiAgfSxcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICB2YXIgeSA9IGV2ZW50LnpyWTtcbiAgICB2YXIgaXNPdXRzaWRlID0gaXNPdXRzaWRlQm91bmRhcnkodGhpcywgeCwgeSk7XG4gICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7IC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgLy8gKGxpa2UgJ3NldE9wdGlvbicgb3IgJ2Rpc3BhdGNoQWN0aW9uJykgaW4gZXZlbnQgaGFuZGxlcnMsIHdlIHNob3VsZCBmaW5kXG4gICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgLy8gU2VlICM2MTk4LlxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gaXNPdXRzaWRlID8ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9IDogdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTsgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcblxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpOyAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcblxuICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGV2ZW50Q29udHJvbCA9IGV2ZW50LnpyRXZlbnRDb250cm9sO1xuICAgIHZhciB6cklzVG9Mb2NhbERPTSA9IGV2ZW50LnpySXNUb0xvY2FsRE9NO1xuXG4gICAgaWYgKGV2ZW50Q29udHJvbCAhPT0gJ29ubHlfZ2xvYmFsb3V0Jykge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Q29udHJvbCAhPT0gJ25vX2dsb2JhbG91dCcpIHtcbiAgICAgIC8vIEZJWE1FOiBpZiB0aGUgcG9pbnRlciBtb3ZpbmcgZnJvbSB0aGUgZXh0cmEgZG9tcyB0byByZWFseSBcIm91dHNpZGVcIixcbiAgICAgIC8vIHRoZSBgZ2xvYmFsb3V0YCBzaG91bGQgaGF2ZSBiZWVuIHRyaWdnZXJlZC4gQnV0IGN1cnJlbnRseSBub3QuXG4gICAgICAhenJJc1RvTG9jYWxET00gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7XG4gICAgICAgIHR5cGU6ICdnbG9iYWxvdXQnLFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAqL1xuICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMucHJveHkgPSB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEluZm8ge3RhcmdldCwgdG9wVGFyZ2V0fSDnm67moIflm77lvaLlhYPntKBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgKi9cbiAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm8gfHwge307XG4gICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG5cbiAgICBpZiAoZWwgJiYgZWwuc2lsZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbFtldmVudEhhbmRsZXJdICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG4gICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpOyAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuXG4gICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAodHlwZW9mIGxheWVyW2V2ZW50SGFuZGxlcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5LCBleGNsdWRlKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuXG4gICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZSAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICYmICFsaXN0W2ldLmlnbm9yZSAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpKSB7XG4gICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfSxcbiAgcHJvY2Vzc0dlc3R1cmU6IGZ1bmN0aW9uIChldmVudCwgc3RhZ2UpIHtcbiAgICBpZiAoIXRoaXMuX2dlc3R1cmVNZ3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuICAgIH1cblxuICAgIHZhciBnZXN0dXJlTWdyID0gdGhpcy5fZ2VzdHVyZU1ncjtcbiAgICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gICAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoZXZlbnQsIHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKS50YXJnZXQsIHRoaXMucHJveHkuZG9tKTtcbiAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpOyAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuXG4gICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh7XG4gICAgICAgIHRhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0XG4gICAgICB9LCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gICAgfVxuICB9XG59OyAvLyBDb21tb24gaGFuZGxlcnNcblxudXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgIHZhciB5ID0gZXZlbnQuenJZO1xuICAgIHZhciBpc091dHNpZGUgPSBpc091dHNpZGVCb3VuZGFyeSh0aGlzLCB4LCB5KTtcbiAgICB2YXIgaG92ZXJlZDtcbiAgICB2YXIgaG92ZXJlZFRhcmdldDtcblxuICAgIGlmIChuYW1lICE9PSAnbW91c2V1cCcgfHwgIWlzT3V0c2lkZSkge1xuICAgICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICAgIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICAgIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBbZXZlbnQuenJYLCBldmVudC56clldOyAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuXG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb3VzZXVwJykge1xuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5fZG93bkVsICE9PSB0aGlzLl91cEVsIC8vIE9yaWdpbmFsIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgd2hvbGUgY2FudmFzIGVsZW1lbnQsXG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAvLyBwYW4gYW5kIHpvb20uXG4gICAgICB8fCAhdGhpcy5fZG93blBvaW50IC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgIHZhciBpc1NpbGVudDtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBTZWUgW0RyYWcgb3V0c2lkZV0uXG4gKi9cblxuXG5mdW5jdGlvbiBpc091dHNpZGVCb3VuZGFyeShoYW5kbGVySW5zdGFuY2UsIHgsIHkpIHtcbiAgdmFyIHBhaW50ZXIgPSBoYW5kbGVySW5zdGFuY2UucGFpbnRlcjtcbiAgcmV0dXJuIHggPCAwIHx8IHggPiBwYWludGVyLmdldFdpZHRoKCkgfHwgeSA8IDAgfHwgeSA+IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG59XG5cbnV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xudXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTtcblxuICBpZiAobmV3RG9tU3R5bGUpIHtcbiAgICAvLyBJbiBub2RlIG9yIHNvbWUgb3RoZXIgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICB9XG5cbiAgbmV3RG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gIHJldHVybiBuZXdEb207XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlclxuICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gKi9cblxuXG52YXIgTGF5ZXIgPSBmdW5jdGlvbiAoaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgZG9tO1xuICBkcHIgPSBkcHIgfHwgZGV2aWNlUGl4ZWxSYXRpbztcblxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKTtcbiAgfSAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoaWQpKSB7XG4gICAgICBkb20gPSBpZDtcbiAgICAgIGlkID0gZG9tLmlkO1xuICAgIH1cblxuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG5cbiAgaWYgKGRvbVN0eWxlKSB7XG4gICAgLy8gTm90IGluIG5vZGVcbiAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBkb21TdHlsZVsncGFkZGluZyddID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cblxuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG5cbiAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICB9XG5cbiAgdGhpcy5kb21CYWNrID0gbnVsbDtcbiAgdGhpcy5jdHhCYWNrID0gbnVsbDtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5jb25maWcgPSBudWxsOyAvLyBDb25maWdzXG5cbiAgLyoqXG4gICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuXG4gIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gIC8qKlxuICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAvKipcbiAgICog5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMC43XG4gICAqL1xuXG4gIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG4gIC8qKlxuICAgKiBMYXllciBkcHJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBkcHI7XG59O1xuXG5MYXllci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMYXllcixcbiAgX19kaXJ0eTogdHJ1ZSxcbiAgX191c2VkOiBmYWxzZSxcbiAgX19kcmF3SW5kZXg6IDAsXG4gIF9fc3RhcnRJbmRleDogMCxcbiAgX19lbmRJbmRleDogMCxcbiAgaW5jcmVtZW50YWw6IGZhbHNlLFxuICBnZXRFbGVtZW50Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2VuZEluZGV4IC0gdGhpcy5fX3N0YXJ0SW5kZXg7XG4gIH0sXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgaWYgKGRwciAhPT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcblxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT09IDEpIHtcbiAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhckFsbF09ZmFsc2UgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqIEBwYXJhbSB7Q29sb3J9IFtjbGVhckNvbG9yXVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCwgY2xlYXJDb2xvcikge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuICAgIHZhciBjbGVhckNvbG9yID0gY2xlYXJDb2xvciB8fCB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yICYmIGNsZWFyQ29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47IC8vIEdyYWRpZW50XG5cbiAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICB9IC8vIFBhdHRlcm5cbiAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2dFcnJvciA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG52YXIgTGF5ZXIgPSByZXF1aXJlKFwiLi9MYXllclwiKTtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBJbWFnZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIEhPVkVSX0xBWUVSX1pMRVZFTCA9IDFlNTtcbnZhciBDQU5WQVNfWkxFVkVMID0gMzE0MTU5O1xudmFyIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyA9IDAuMDE7XG52YXIgSU5DUkVNRU5UQUxfSU5DID0gMC4wMDE7XG5cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gIGlmICghbGF5ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGF5ZXIucmVzaXplICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBsYXllci5yZWZyZXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbnZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG5cbmZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcblxuICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICB9XG5cbiAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gIC8vIGRpc3BsYXlhYmxlLl9fY2xpcFBhdGhzIGNhbiBvbmx5IGJlIGBudWxsYC9gdW5kZWZpbmVkYCBvciBhbiBub24tZW1wdHkgYXJyYXkuXG4gIGlmIChjbGlwUGF0aHMgPT09IHByZXZDbGlwUGF0aHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNsaXBQYXRocyB8fCAhcHJldkNsaXBQYXRocyB8fCBjbGlwUGF0aHMubGVuZ3RoICE9PSBwcmV2Q2xpcFBhdGhzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2xpcFBhdGhzW2ldICE9PSBwcmV2Q2xpcFBhdGhzW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjbGlwUGF0aCA9IGNsaXBQYXRoc1tpXTtcbiAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY2xpcFBhdGguYnVpbGRQYXRoKGN0eCwgY2xpcFBhdGguc2hhcGUpO1xuICAgIGN0eC5jbGlwKCk7IC8vIFRyYW5zZm9ybSBiYWNrXG5cbiAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGRvbVJvb3Qub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyBBdm9pZCBwYWdlIHNlbGVjdGVkXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsIC8vIElPUzEzIHNhZmFyaSBwcm9iYWJseSBoYXMgYSBjb21wb3NpdGluZyBidWcgKHogb3JkZXIgb2YgdGhlIGNhbnZhcyBhbmQgdGhlIGNvbnNlcXVlbnRcbiAgLy8gZG9tIGRvZXMgbm90IGFjdCBhcyBleHBlY3RlZCkgd2hlbiBzb21lIG9mIHRoZSBwYXJlbnQgZG9tIGhhc1xuICAvLyBgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO2AgYW5kIHRoZSB3ZWJwYWdlIGlzIGxvbmdlciB0aGFuIG9uZSBzY3JlZW4gYW5kXG4gIC8vIHRoZSBjYW52YXMgaXMgbm90IGF0IHRoZSB0b3AgcGFydCBvZiB0aGUgcGFnZS5cbiAgLy8gQ2hlY2sgYGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDM2ODFgIGZvciBtb3JlIGRldGFpbHMuIFdlIHJlbW92ZVxuICAvLyB0aGlzIGBvdmVyZmxvdzpoaWRkZW5gIHRvIGF2b2lkIHRoZSBidWcuXG4gIC8vICdvdmVyZmxvdzpoaWRkZW4nLFxuICAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG4gIC8qKlxuICAgKiB6cmVuZGVyIHdpbGwgZG8gY29tcG9zaXRpbmcgd2hlbiByb290IGlzIGEgY2FudmFzIGFuZCBoYXZlIG11bHRpcGxlIHpsZXZlbHMuXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZyA9IGZhbHNlO1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuXG4gICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSBvcHRzLmhlaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxOyAvLyBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZGlyZWN0bHlcblxuICAgIHJvb3Qud2lkdGggPSB3aWR0aCAqIHRoaXMuZHByO1xuICAgIHJvb3QuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7IC8vIENyZWF0ZSBsYXllciBpZiBvbmx5IG9uZSBnaXZlbiBjYW52YXNcbiAgICAvLyBEZXZpY2UgY2FuIGJlIHNwZWNpZmllZCB0byBjcmVhdGUgYSBoaWdoIGRwaSBpbWFnZS5cblxuICAgIHZhciBtYWluTGF5ZXIgPSBuZXcgTGF5ZXIocm9vdCwgdGhpcywgdGhpcy5kcHIpO1xuICAgIG1haW5MYXllci5fX2J1aWx0aW5fXyA9IHRydWU7XG4gICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7IC8vIEZJWE1FIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodFxuICAgIC8vIG1haW5MYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICBsYXllcnNbQ0FOVkFTX1pMRVZFTF0gPSBtYWluTGF5ZXI7XG4gICAgbWFpbkxheWVyLnpsZXZlbCA9IENBTlZBU19aTEVWRUw7IC8vIE5vdCB1c2UgY29tbW9uIHpsZXZlbC5cblxuICAgIHpsZXZlbExpc3QucHVzaChDQU5WQVNfWkxFVkVMKTtcbiAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIHRoaXMuX2hvdmVybGF5ZXIgPSBudWxsO1xuICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG59O1xuXG5QYWludGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhaW50ZXIsXG4gIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ2NhbnZhcyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIHBhaW50ZXIgdXNlIGEgc2luZ2xlIGNhbnZhc1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21Sb290O1xuICB9LFxuICBnZXRWaWV3cG9ydFJvb3RPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcblxuICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldExlZnQ6IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDAsXG4gICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yi35pawXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHRoaXMuX3JlZHJhd0lkID0gTWF0aC5yYW5kb20oKTtcblxuICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCwgdGhpcy5fcmVkcmF3SWQpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSBpID09PSAwID8gdGhpcy5fYmFja2dyb3VuZENvbG9yIDogbnVsbDtcbiAgICAgICAgbGF5ZXIucmVmcmVzaChjbGVhckNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XG4gICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgc3R5bGU6IGVsLnN0eWxlLFxuICAgICAgc2hhcGU6IGVsLnNoYXBlLFxuICAgICAgejogZWwueixcbiAgICAgIHoyOiBlbC56MixcbiAgICAgIHNpbGVudDogZWwuc2lsZW50XG4gICAgfSk7XG4gICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgIGhvdmVyU3R5bGUgJiYgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG5cbiAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuXG4gICAgcmV0dXJuIGVsTWlycm9yO1xuICB9LFxuICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZihob3ZlckVsZW1lbnRzLCBlbE1pcnJvcik7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuXG4gICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gIH0sXG4gIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcblxuICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTsgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAvLyBGSVhNRT9cblxuICAgIGlmICghaG92ZXJMYXllcikge1xuICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKEhPVkVSX0xBWUVSX1pMRVZFTCk7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0ge307XG4gICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207IC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgIC8vIFBFTkRJTkdcblxuICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICBsZW4tLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGkrKzsgLy8gVXNlIHRyYW5zZm9ybVxuICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cblxuICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICBlbC50cmFuc2Zvcm0gPSBvcmlnaW5hbEVsLnRyYW5zZm9ybTtcbiAgICAgICAgZWwuaW52VHJhbnNmb3JtID0gb3JpZ2luYWxFbC5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRoczsgLy8gZWwuXG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICB9LFxuICBnZXRIb3ZlckxheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoSE9WRVJfTEFZRVJfWkxFVkVMKTtcbiAgfSxcbiAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsLCByZWRyYXdJZCkge1xuICAgIGlmICh0aGlzLl9yZWRyYXdJZCAhPT0gcmVkcmF3SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYWludEFsbCA9IHBhaW50QWxsIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICB2YXIgZmluaXNoZWQgPSB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICBpZiAodGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKSB7XG4gICAgICB0aGlzLl9jb21wb3NpdGVNYW51YWxseSgpO1xuICAgIH1cblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCwgcmVkcmF3SWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBfY29tcG9zaXRlTWFudWFsbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5nZXRMYXllcihDQU5WQVNfWkxFVkVMKS5jdHg7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fZG9tUm9vdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fZG9tUm9vdC5oZWlnaHQ7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgLy8gUEVORElORywgSWYgb25seSBidWlsdGluIGxheWVyP1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgaWYgKGxheWVyLnZpcnR1YWwpIHtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIHZhciBsYXllckxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIHppID0gMDsgemkgPCB0aGlzLl96bGV2ZWxMaXN0Lmxlbmd0aDsgemkrKykge1xuICAgICAgdmFyIHpsZXZlbCA9IHRoaXMuX3psZXZlbExpc3RbemldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllciAhPT0gdGhpcy5faG92ZXJsYXllciAmJiAobGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkpIHtcbiAgICAgICAgbGF5ZXJMaXN0LnB1c2gobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxheWVyTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJMaXN0W2tdO1xuICAgICAgdmFyIGN0eCA9IGxheWVyLmN0eDtcbiAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBzdGFydCA9IHBhaW50QWxsID8gbGF5ZXIuX19zdGFydEluZGV4IDogbGF5ZXIuX19kcmF3SW5kZXg7XG4gICAgICB2YXIgdXNlVGltZXIgPSAhcGFpbnRBbGwgJiYgbGF5ZXIuaW5jcmVtZW50YWwgJiYgRGF0ZS5ub3c7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdXNlVGltZXIgJiYgRGF0ZS5ub3coKTtcbiAgICAgIHZhciBjbGVhckNvbG9yID0gbGF5ZXIuemxldmVsID09PSB0aGlzLl96bGV2ZWxMaXN0WzBdID8gdGhpcy5fYmFja2dyb3VuZENvbG9yIDogbnVsbDsgLy8gQWxsIGVsZW1lbnRzIGluIHRoaXMgbGF5ZXIgYXJlIGNsZWFyZWQuXG5cbiAgICAgIGlmIChsYXllci5fX3N0YXJ0SW5kZXggPT09IGxheWVyLl9fZW5kSW5kZXgpIHtcbiAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCA9PT0gbGF5ZXIuX19zdGFydEluZGV4KSB7XG4gICAgICAgIHZhciBmaXJzdEVsID0gbGlzdFtzdGFydF07XG5cbiAgICAgICAgaWYgKCFmaXJzdEVsLmluY3JlbWVudGFsIHx8ICFmaXJzdEVsLm5vdENsZWFyIHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRm9yIHNvbWUgdW5rbm93biByZWFzb24uIGRyYXdJbmRleCBpcyAtMScpO1xuICAgICAgICBzdGFydCA9IGxheWVyLl9fc3RhcnRJbmRleDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGF5ZXIuX19lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBsYXllciwgcGFpbnRBbGwsIHNjb3BlKTtcblxuICAgICAgICBlbC5fX2RpcnR5ID0gZWwuX19kaXJ0eVRleHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodXNlVGltZXIpIHtcbiAgICAgICAgICAvLyBEYXRlLm5vdyBjYW4gYmUgZXhlY3V0ZWQgaW4gMTMsMDI1LDMwNSBvcHMvc2Vjb25kLlxuICAgICAgICAgIHZhciBkVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7IC8vIEdpdmUgMTUgbWlsbGlzZWNvbmQgdG8gZHJhdy5cbiAgICAgICAgICAvLyBUaGUgcmVzdCBlbGVtZW50cyB3aWxsIGJlIGRyYXduIGluIHRoZSBuZXh0IGZyYW1lLlxuXG4gICAgICAgICAgaWYgKGRUaW1lID4gMTUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXllci5fX2RyYXdJbmRleCA9IGk7XG5cbiAgICAgIGlmIChsYXllci5fX2RyYXdJbmRleCA8IGxheWVyLl9fZW5kSW5kZXgpIHtcbiAgICAgICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAvLyBOZWVkcyByZXN0b3JlIHRoZSBzdGF0ZS4gSWYgbGFzdCBkcmF3biBlbGVtZW50IGlzIGluIHRoZSBjbGlwcGluZyBhcmVhLlxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmIChlbnYud3hhKSB7XG4gICAgICAvLyBGbHVzaCBmb3Igd2VpeGluIGFwcGxpY2F0aW9uXG4gICAgICB1dGlsLmVhY2godGhpcy5fbGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLmN0eCAmJiBsYXllci5jdHguZHJhdykge1xuICAgICAgICAgIGxheWVyLmN0eC5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2hlZDtcbiAgfSxcbiAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgdmFyIG0gPSBlbC50cmFuc2Zvcm07XG5cbiAgICBpZiAoKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IGZvcmNlUGFpbnQpICYmIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICFlbC5pbnZpc2libGUgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwIC8vIElnbm9yZSBzY2FsZSAwIGVsZW1lbnQsIGluIHNvbWUgZW52aXJvbm1lbnQgbGlrZSBub2RlLWNhbnZhc1xuICAgIC8vIERyYXcgYSBzY2FsZSAwIGVsZW1lbnQgY2FuIGNhdXNlIGFsbCBmb2xsb3dpbmcgZHJhdyB3cm9uZ1xuICAgIC8vIEFuZCBzZXRUcmFuc2Zvcm0gd2l0aCBzY2FsZSAwIHdpbGwgY2F1c2Ugc2V0IGJhY2sgdHJhbnNmb3JtIGZhaWxlZC5cbiAgICAmJiAhKG0gJiYgIW1bMF0gJiYgIW1bM10pIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSkpIHtcbiAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcbiAgICAgIHZhciBwcmV2RWxDbGlwUGF0aHMgPSBzY29wZS5wcmV2RWxDbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghcHJldkVsQ2xpcFBhdGhzIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkVsQ2xpcFBhdGhzKSkge1xuICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICBpZiAocHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBudWxsOyAvLyBSZXNldCBwcmV2RWwgc2luY2UgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZFxuXG4gICAgICAgICAgc2NvcGUucHJldkVsID0gbnVsbDtcbiAgICAgICAgfSAvLyBOZXcgY2xpcHBpbmcgc3RhdGVcblxuXG4gICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCk7XG4gICAgICAgICAgc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKGN0eCk7XG4gICAgICBlbC5icnVzaChjdHgsIHNjb3BlLnByZXZFbCB8fCBudWxsKTtcbiAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5YgemxldmVsIOaJgOWcqOWxgu+8jOWmguaenOS4jeWtmOWcqOWImeS8muWIm+W7uuS4gOS4quaWsOeahOWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlydHVhbCBWaXJ0dWFsIGxheWVyIHdpbGwgbm90IGJlIGluc2VydGVkIGludG8gZG9tLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsLCB2aXJ0dWFsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcyAmJiAhdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKSB7XG4gICAgICB6bGV2ZWwgPSBDQU5WQVNfWkxFVkVMO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICBsYXllciA9IG5ldyBMYXllcignenJfJyArIHpsZXZlbCwgdGhpcywgdGhpcy5kcHIpO1xuICAgICAgbGF5ZXIuemxldmVsID0gemxldmVsO1xuICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgIH0gLy8gVE9ETyBSZW1vdmUgRUxfQUZURVJfSU5DUkVNRU5UQUxfSU5DIG1hZ2ljIG51bWJlclxuICAgICAgZWxzZSBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsIC0gRUxfQUZURVJfSU5DUkVNRU5UQUxfSU5DXSkge1xuICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbCAtIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQ10sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgIGxheWVyLnZpcnR1YWwgPSB2aXJ0dWFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpOyAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYWZ0ZXIgZG9tIGluc2VydGVkIHRvIGRvY3VtZW50XG4gICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuXG4gICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfSxcbiAgaW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGxheWVyKSB7XG4gICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICBsb2dFcnJvcignWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZ0Vycm9yKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbiA+IDAgJiYgemxldmVsID4gemxldmVsTGlzdFswXSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICBpZiAoemxldmVsTGlzdFtpXSA8IHpsZXZlbCAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICB9XG5cbiAgICB6bGV2ZWxMaXN0LnNwbGljZShpICsgMSwgMCwgemxldmVsKTtcbiAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyOyAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgIC8vIChJdCBjYW4gYmUgYSBXZWJHTCBsYXllciBhbmQgYXNzaWduZWQgdG8gYSBaSW1hZ2UgZWxlbWVudClcbiAgICAvLyBCdXQgaXQgc3RpbGwgdW5kZXIgbWFuYWdlbWVudCBvZiB6cmVuZGVyLlxuXG4gICAgaWYgKCFsYXllci52aXJ0dWFsKSB7XG4gICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgIHZhciBwcmV2RG9tID0gcHJldkxheWVyLmRvbTtcblxuICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgcHJldkRvbS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZG9tUm9vdC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIGxheWVyXG4gIGVhY2hMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbel0sIHopO1xuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIGJ1aWxkaW4gbGF5ZXJcbiAgZWFjaEJ1aWx0aW5MYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllcjtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggb3RoZXIgbGF5ZXIgZXhjZXB0IGJ1aWxkaW4gbGF5ZXJcbiAgZWFjaE90aGVyTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9MYXllcj59IFtwcmV2TGF5ZXJdXG4gICAqL1xuICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICB9LFxuICBfdXBkYXRlTGF5ZXJTdGF0dXM6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgbGF5ZXIuX19kaXJ0eSA9IGxheWVyLl9fdXNlZCA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUHJldkxheWVyKGlkeCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICBpZiAocHJldkxheWVyLl9fZW5kSW5kZXggIT09IGlkeCkge1xuICAgICAgICAgIHByZXZMYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZMYXllci5fX2VuZEluZGV4ID0gaWR4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuXG4gICAgICAgIGlmIChlbC56bGV2ZWwgIT09IGxpc3RbaSAtIDFdLnpsZXZlbCB8fCBlbC5pbmNyZW1lbnRhbCkge1xuICAgICAgICAgIHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldkxheWVyID0gbnVsbDtcbiAgICB2YXIgaW5jcmVtZW50YWxMYXllckNvdW50ID0gMDtcbiAgICB2YXIgcHJldlpsZXZlbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICB2YXIgbGF5ZXI7XG5cbiAgICAgIGlmIChwcmV2WmxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgcHJldlpsZXZlbCA9IHpsZXZlbDtcbiAgICAgICAgaW5jcmVtZW50YWxMYXllckNvdW50ID0gMDtcbiAgICAgIH0gLy8gVE9ETyBOb3QgdXNlIG1hZ2ljIG51bWJlciBvbiB6bGV2ZWwuXG4gICAgICAvLyBFYWNoIGxheWVyIHdpdGggaW5jcmVtZW50IGVsZW1lbnQgY2FuIGJlIHNlcGFyYXRlZCB0byAzIGxheWVycy5cbiAgICAgIC8vICAgICAgICAgIChPdGhlciBFbGVtZW50IGRyYXduIGFmdGVyIGluY3JlbWVudGFsIGVsZW1lbnQpXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLXpsZXZlbCArIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQy0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoSW5jcmVtZW50YWwgZWxlbWVudClcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS16bGV2ZWwgKyBJTkNSRU1FTlRBTF9JTkMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vICAgICAgICAgICAgICAoRWxlbWVudCBkcmF3biBiZWZvcmUgaW5jcmVtZW50YWwgZWxlbWVudClcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0temxldmVsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICBpZiAoZWwuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKHpsZXZlbCArIElOQ1JFTUVOVEFMX0lOQywgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKTtcbiAgICAgICAgbGF5ZXIuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgICBpbmNyZW1lbnRhbExheWVyQ291bnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKHpsZXZlbCArIChpbmNyZW1lbnRhbExheWVyQ291bnQgPiAwID8gRUxfQUZURVJfSU5DUkVNRU5UQUxfSU5DIDogMCksIHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgbG9nRXJyb3IoJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgbGF5ZXIuaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIgIT09IHByZXZMYXllcikge1xuICAgICAgICBsYXllci5fX3VzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChsYXllci5fX3N0YXJ0SW5kZXggIT09IGkpIHtcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVyLl9fc3RhcnRJbmRleCA9IGk7XG5cbiAgICAgICAgaWYgKCFsYXllci5pbmNyZW1lbnRhbCkge1xuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNYXJrIGxheWVyIGRyYXcgaW5kZXggbmVlZHMgdG8gdXBkYXRlLlxuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVQcmV2TGF5ZXIoaSk7XG4gICAgICAgIHByZXZMYXllciA9IGxheWVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAobGF5ZXIuaW5jcmVtZW50YWwgJiYgbGF5ZXIuX19kcmF3SW5kZXggPCAwKSB7XG4gICAgICAgICAgLy8gU3RhcnQgZHJhdyBmcm9tIHRoZSBmaXJzdCBkaXJ0eSBlbGVtZW50LlxuICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVByZXZMYXllcihpKTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAvLyBVc2VkIGluIGxhc3QgZnJhbWUgYnV0IG5vdCBpbiB0aGlzIGZyYW1lLiBOZWVkcyBjbGVhclxuICAgICAgaWYgKCFsYXllci5fX3VzZWQgJiYgbGF5ZXIuZ2V0RWxlbWVudENvdW50KCkgPiAwKSB7XG4gICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICBsYXllci5fX3N0YXJ0SW5kZXggPSBsYXllci5fX2VuZEluZGV4ID0gbGF5ZXIuX19kcmF3SW5kZXggPSAwO1xuICAgICAgfSAvLyBGb3IgaW5jcmVtZW50YWwgbGF5ZXIuIEluIGNhc2Ugc3RhcnQgaW5kZXggY2hhbmdlZCBhbmQgbm8gZWxlbWVudHMgYXJlIGRpcnR5LlxuXG5cbiAgICAgIGlmIChsYXllci5fX2RpcnR5ICYmIGxheWVyLl9fZHJhd0luZGV4IDwgMCkge1xuICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGxheWVyLl9fc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcbiAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkv67mlLnmjIflrpp6bGV2ZWznmoTnu5jliLblj4LmlbBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpsZXZlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOmFjee9ruWvueixoVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XVxuICAgKiAgICAgICAgICAgICAgICAg5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoemxldmVsLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB2YXIgbGF5ZXJDb25maWcgPSB0aGlzLl9sYXllckNvbmZpZztcblxuICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgIGxheWVyQ29uZmlnW3psZXZlbF0gPSBjb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyQ29uZmlnW3psZXZlbF0sIGNvbmZpZywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5femxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3psZXZlbCA9IHRoaXMuX3psZXZlbExpc3RbaV07IC8vIFRPRE8gUmVtb3ZlIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyBtYWdpYyBudW1iZXJcblxuICAgICAgICBpZiAoX3psZXZlbCA9PT0gemxldmVsIHx8IF96bGV2ZWwgPT09IHpsZXZlbCArIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQykge1xuICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tfemxldmVsXTtcbiAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCBsYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCF0aGlzLl9kb21Sb290LnN0eWxlKSB7XG4gICAgICAvLyBNYXliZSBpbiBub2RlIG9yIHdvcmtlclxuICAgICAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5nZXRMYXllcihDQU5WQVNfWkxFVkVMKS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDsgLy8gRklYTUUgV2h5ID9cblxuICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgICB3aWR0aCAhPSBudWxsICYmIChvcHRzLndpZHRoID0gd2lkdGgpO1xuICAgICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICAgIGlmICh0aGlzLl93aWR0aCAhPT0gd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgZG9tUm9vdC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICovXG4gIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmHiuaUvlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLnJvb3QgPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLl9kb21Sb290ID0gdGhpcy5fbGF5ZXJzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5waXhlbFJhdGlvXVxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzICYmICF0aGlzLl9jb21wb3NpdGVNYW51YWxseSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tDQU5WQVNfWkxFVkVMXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhcihmYWxzZSwgb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fYmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChvcHRzLnBpeGVsUmF0aW8gPD0gdGhpcy5kcHIpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgdmFyIHdpZHRoID0gaW1hZ2VMYXllci5kb20ud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VMYXllci5kb20uaGVpZ2h0O1xuICAgICAgdmFyIGN0eCA9IGltYWdlTGF5ZXIuY3R4O1xuICAgICAgdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICAgIGltYWdlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICBsYXllci5yZW5kZXJUb0NhbnZhcyhpbWFnZUxheWVyLmN0eCk7XG4gICAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUEVORElORywgZWNoYXJ0cy1nbCBhbmQgaW5jcmVtZW50YWwgcmVuZGVyaW5nLlxuICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXIgKiBkcHI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYICogZHByO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WSAqIGRwcjtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgR3JvdXAgPSByZXF1aXJlKFwiLi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG4vLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAvLyB9XG4gICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueiAtIGIuejtcbiAgfVxuXG4gIHJldHVybiBhLnpsZXZlbCAtIGIuemxldmVsO1xufVxuLyoqXG4gKiDlhoXlrrnku5PlupMgKE0pXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIHRoaXMuX3Jvb3RzID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbn07XG5cblN0b3JhZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqXG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcm9vdHNbaV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgKlxuICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICovXG4gIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcbiAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICB9LFxuICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuXG4gICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDsgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuXG4gICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG4gICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgfSAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcblxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuXG4gICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICovXG4gIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuXG4gICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgZWwuZGlydHkoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCA9IHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgfSxcbiAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xufTtcbnZhciBfZGVmYXVsdCA9IFN0b3JhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciB1dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgRGlzcGF0Y2hlciA9IF9ldmVudC5EaXNwYXRjaGVyO1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZShcIi4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi9BbmltYXRvclwiKTtcblxuLyoqXG4gKiBBbmltYXRpb24gbWFpbiBjbGFzcywgZGlzcGF0Y2ggYW5kIG1hbmFnZSBhbGwgYW5pbWF0aW9uIGNvbnRyb2xsZXJzXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25mcmFtZV1cbiAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgeDogMTAwLFxuICogICAgICAgICB5OiAxMDBcbiAqICAgICB9O1xuICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDUwMCxcbiAqICAgICAgICAgICAgIHk6IDUwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAud2hlbigyMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAqL1xudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24gKCkge307IC8vIHByaXZhdGUgcHJvcGVydGllc1xuXG5cbiAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB0aGlzLl90aW1lO1xuICB0aGlzLl9wYXVzZWRUaW1lO1xuICB0aGlzLl9wYXVzZVN0YXJ0O1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGlvbixcblxuICAvKipcbiAgICogQWRkIGNsaXBcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcy5wdXNoKGNsaXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYW5pbWF0b3JcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbmltYXRpb24gY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICByZW1vdmVDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbmltYXRpb24gY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG5cbiAgICBhbmltYXRvci5hbmltYXRpb24gPSBudWxsO1xuICB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpOyAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgbGVuLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICB0aGlzLm9uZnJhbWUoZGVsdGEpOyAvLyAnZnJhbWUnIHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHN0YWdlLCBiZWNhdXNlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgLy8gZGVwZW5kcyBvbiB0aGUgc2VxdWVuY2UgKGUuZy4sIGVjaGFydHMtc3RyZWFtIGFuZCBmaW5pc2hcbiAgICAvLyBldmVudCBqdWRnZSlcblxuICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFuaW1hdGlvbi5cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5pbWF0aW9uLlxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUGF1c2UgYW5pbWF0aW9uLlxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3VtZSBhbmltYXRpb24uXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYW5pbWF0aW9uLlxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGFuaW1hdGlvbiBmaW5pc2hlZC5cbiAgICovXG4gIGlzRmluaXNoZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2NsaXBzLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXQgYW5pbWF0b3IgZm9yIGEgdGFyZ2V0LCB3aG9zZSBwcm9wcyBjYW4gYmUgYW5pbWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSBXaGV0aGVyIGxvb3AgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdIEdldCB2YWx1ZSBmcm9tIHRhcmdldC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXSBTZXQgdmFsdWUgdG8gdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgKi9cbiAgLy8gVE9ETyBHYXBcbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIG9wdGlvbnMubG9vcCwgb3B0aW9ucy5nZXR0ZXIsIG9wdGlvbnMuc2V0dGVyKTtcbiAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn07XG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG52YXIgX2RlZmF1bHQgPSBBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBDbGlwID0gcmVxdWlyZShcIi4vQ2xpcFwiKTtcblxudmFyIGNvbG9yID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICB0YXJnZXRba2V5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBsZW4gJiYgcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuXG5cbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG5cbiAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG5cbiAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgYXJyMC5wdXNoKGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGluZyBOYU4gdmFsdWVcblxuXG4gIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcblxuICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0Myk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLCB0LCB0MiwgdDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG4gIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuXG4gIGlmICghdHJhY2tMZW4pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR3Vlc3MgZGF0YSB0eXBlXG5cblxuICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTsgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG5cbiAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuICB2YXIgdHJhY2tNYXhUaW1lOyAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuXG4gIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgfSk7XG4gIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7IC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZQZXJjZW50cyA9IFtdOyAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmVmFsdWVzID0gW107XG4gIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7IC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcblxuICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTsgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcblxuICAgIGlmICghKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pIHx8ICFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpIHtcbiAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZWYWx1ZSA9IHZhbHVlOyAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07IC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pOyAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcblxuICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciB3O1xuICB2YXIgcDA7XG4gIHZhciBwMTtcbiAgdmFyIHAyO1xuICB2YXIgcDM7XG5cbiAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZyYW1lOyAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgZnJhbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuXG4gICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuXG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgIH1cblxuICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuICAgIHZhciByYW5nZSA9IGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG5cbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgb25mcmFtZTogb25mcmFtZSxcbiAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICB9KTtcblxuICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgfVxuXG4gIHJldHVybiBjbGlwO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqL1xuXG5cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gIHRoaXMuX3RyYWNrcyA9IHt9O1xuICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG4gIHRoaXMuX2NsaXBDb3VudCA9IDA7XG4gIHRoaXMuX2RlbGF5ID0gMDtcbiAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNldCBBbmltYXRpb24ga2V5ZnJhbWVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHdoZW46IGZ1bmN0aW9uICh0aW1lXG4gIC8qIG1zICovXG4gICwgcHJvcHMpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdOyAvLyBJbnZhbGlkIHZhbHVlXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAvLyBFbHNlXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG5cblxuICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH0sXG4gIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICB9LFxuICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgIHRoaXMuX3RyYWNrcyA9IHt9OyAvLyBDbGVhciBhbGwgY2xpcHNcblxuICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gW2Vhc2luZ11cbiAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VBbmltYXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nLCBmb3JjZUFuaW1hdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xpcENvdW50LS07XG5cbiAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFzdENsaXA7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAodGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuXG4gICAgICAgIGNsaXBDb3VudCsrOyAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG5cblxuICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuXG4gICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUaGlzIG9wdGltaXphdGlvbiB3aWxsIGhlbHAgdGhlIGNhc2UgdGhhdCBpbiB0aGUgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyB0aGUgdmlldyBtYXkgYmUgcmVmcmVzaGVkIGZyZXF1ZW50bHksIHdoZXJlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG5cblxuICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuXG4gICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICB9XG5cbiAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgd2hlbiBhbmltYXRpb24gZGVsYXkgc3RhcnRzXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjayBmb3IgYW5pbWF0aW9uIGVuZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICovXG4gIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoXCIuL2Vhc2luZ1wiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5mdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcbiAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7IC8vIOeUn+WRveWRqOacn1xuXG4gIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDsgLy8g5bu25pe2XG5cbiAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7IC8vIOW8gOWni+aXtumXtFxuICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuXG4gIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7IC8vIOaYr+WQpuW+queOr1xuXG4gIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG4gIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2xpcCxcbiAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUsIGRlbHRhVGltZSkge1xuICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgIC8vIFBFTkRJTkdcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTsgLy8g6L+Y5rKh5byA5aeLXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG4gICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgIHZhciBzY2hlZHVsZSA9IHR5cGVvZiBlYXNpbmdGdW5jID09PSAnZnVuY3Rpb24nID8gZWFzaW5nRnVuYyhwZXJjZW50KSA6IHBlcmNlbnQ7XG4gICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTsgLy8g57uT5p2fXG5cbiAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICB0aGlzLnJlc3RhcnQoZ2xvYmFsVGltZSk7IC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuXG4gICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICB9IC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuXG5cbiAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICB9LFxuICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuXG4gICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xudmFyIGVhc2luZyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9LFxuICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSAtLWsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICB9LFxuICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICB9LFxuICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgfSxcbiAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gIH0sXG4gIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcbiAgfSxcbiAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbiAgLy8g5Yib5bu65by56Lez5pWI5p6cXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAxLjUgLyAyLjc1KSAqIGsgKyAwLjc1O1xuICAgIH0gZWxzZSBpZiAoayA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi42MjUgLyAyLjc1KSAqIGsgKyAwLjk4NDM3NTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMC41KSB7XG4gICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gZWFzaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvaXNzdWVzLzE4OSNpc3N1ZWNvbW1lbnQtMjI0OTE5ODA5XG53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHNldFRpbWVvdXQoZnVuYywgMTYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgZHByID0gMTsgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG4vKipcbiAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogRGVidWcgbG9nIG1vZGU6XG4gKiAwOiBEbyBub3RoaW5nLCBmb3IgcmVsZWFzZS5cbiAqIDE6IGNvbnNvbGUuZXJyb3IsIGZvciBkZWJ1Zy5cbiAqL1xuXG5cbnZhciBkZWJ1Z01vZGUgPSAwOyAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuZXhwb3J0cy5kZWJ1Z01vZGUgPSBkZWJ1Z01vZGU7XG5leHBvcnRzLmRldmljZVBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvOyIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7IiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTsiLCIvKipcbiAqIOe6v+auteWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHZhciBfYSA9IDA7XG4gIHZhciBfYiA9IHgwOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoeDAgIT09IHgxKSB7XG4gICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgfVxuXG4gIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG5cbiAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcblxuICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlOyIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBsaW5lID0gcmVxdWlyZShcIi4vbGluZVwiKTtcblxudmFyIGN1YmljID0gcmVxdWlyZShcIi4vY3ViaWNcIik7XG5cbnZhciBxdWFkcmF0aWMgPSByZXF1aXJlKFwiLi9xdWFkcmF0aWNcIik7XG5cbnZhciBhcmMgPSByZXF1aXJlKFwiLi9hcmNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKFwiLi93aW5kaW5nTGluZVwiKTtcblxudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgRVBTSUxPTiA9IDFlLTQ7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbn0gLy8g5Li05pe25pWw57uEXG5cblxudmFyIHJvb3RzID0gWy0xLCAtMSwgLTFdO1xudmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgZXh0cmVtYVsxXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MyB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5jdWJpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5MywgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgdmFyIHkwXztcbiAgICB2YXIgeTFfO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgdmFyIHQgPSByb290c1tpXTsgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG5cbiAgICAgIHZhciB1bml0ID0gdCA9PT0gMCB8fCB0ID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLmN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG5cbiAgICAgICAgaWYgKGV4dHJlbWFbMV0gPCBleHRyZW1hWzBdICYmIG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgIH1cblxuICAgICAgICB5MF8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzBdKTtcblxuICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgeTFfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hID09PSAyKSB7XG4gICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgdyArPSB5MV8gPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcblxuICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHQgPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKTtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICB2YXIgdyA9IDA7XG4gICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICB2YXIgdW5pdCA9IHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxID8gMC41IDogMTtcbiAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuXG4gICAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb290c1tpXSA8IHQpIHtcbiAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgdmFyIHVuaXQgPSByb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geTIgPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICB9XG4gIH1cbn0gLy8gVE9ET1xuLy8gQXJjIOaXi+i9rFxuXG5cbmZ1bmN0aW9uIHdpbmRpbmdBcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgeCwgeSkge1xuICB5IC09IGN5O1xuXG4gIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gIHJvb3RzWzBdID0gLXRtcDtcbiAgcm9vdHNbMV0gPSB0bXA7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICBpZiAoeCA+PSByb290c1swXSArIGN4ICYmIHggPD0gcm9vdHNbMV0gKyBjeCkge1xuICAgICAgcmV0dXJuIGRpcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciB3ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuXG4gICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgZGlyID0gLWRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgKz0gZGlyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG5mdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gIHZhciB3ID0gMDtcbiAgdmFyIHhpID0gMDtcbiAgdmFyIHlpID0gMDtcbiAgdmFyIHgwID0gMDtcbiAgdmFyIHkwID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIHZhciBjbWQgPSBkYXRhW2krK107IC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcblxuICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgfSAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyB9XG5cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5OyAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuXG4gICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgfSAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuXG5cbiAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCBfeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBfeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHlpID0gTWF0aC5zaW4odGhldGEgKyBkVGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MCwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTEsIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MSwgeTAsIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsb3NlIGEgc3VicGF0aFxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpOyAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNTdHJva2UgJiYgIWlzQXJvdW5kRXF1YWwoeWksIHkwKSkge1xuICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gIH1cblxuICByZXR1cm4gdyAhPT0gMDtcbn1cblxuZnVuY3Rpb24gY29udGFpbihwYXRoRGF0YSwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIDAsIGZhbHNlLCB4LCB5KTtcbn1cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbn1cblxuZXhwb3J0cy5jb250YWluID0gY29udGFpbjtcbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7IiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTsiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0cmltID0gX3V0aWwudHJpbTtcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCByaWNoLCB0cnVuY2F0ZSkge1xuICByZXR1cm4gcmljaCA/IGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHJpY2gsIHRydW5jYXRlKSA6IGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCB0cnVuY2F0ZSk7XG4gIHZhciBvdXRlcldpZHRoID0gZ2V0V2lkdGgodGV4dCwgZm9udCk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgb3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbiAgcmVjdC5saW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmcsXG4gICAgdGV4dExpbmVIZWlnaHQ6IHRleHRMaW5lSGVpZ2h0XG4gIH0pO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRYKHgsIHdpZHRoLCB0ZXh0QWxpZ24pIHtcbiAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSB3aWR0aCAvIDI7XG4gIH1cblxuICByZXR1cm4geDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHkuXG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0WSh5LCBoZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICB5IC09IGhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQ7XG4gIH1cblxuICByZXR1cm4geTtcbn1cbi8qKlxuICogRm9sbG93IHNhbWUgaW50ZXJmYWNlIHRvIGBEaXNwbGF5YWJsZS5wcm90b3R5cGUuY2FsY3VsYXRlVGV4dFBvc2l0aW9uYC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JlamN0fSBbb3V0XSBQcmVwYXJlZCBvdXQgb2JqZWN0LiBJZiBub3QgaW5wdXQsIGF1dG8gY3JlYXRlZCBpbiB0aGUgbWV0aG9kLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZSB3aGVyZSBgdGV4dFBvc2l0aW9uYCBhbmQgYHRleHREaXN0YW5jZWAgYXJlIHZpc2l0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gUmVjdCBvZiB0aGUgaG9zdCBlbG1lbnQsIGFjY29yZGluZyB0byB3aGljaCB0aGUgdGV4dCBwb3NpdGlvbmVkLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYG91dGAuIFNldDoge3gsIHksIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ259XG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0UG9zaXRpb24ob3V0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCAwO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cbiAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSAtPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgKyBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21MZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBvdXQgPSBvdXQgfHwge307XG4gIG91dC54ID0geDtcbiAgb3V0LnkgPSB5O1xuICBvdXQudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICBvdXQudGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVG8gYmUgcmVtb3ZlZC4gQnV0IHN0aWxsIGRvIG5vdCByZW1vdmUgaW4gY2FzZSB0aGF0IHNvbWUgb25lIGhhcyBpbXBvcnRlZCBpdC5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciBkdW1teVN0eWxlID0ge1xuICAgIHRleHRQb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgIHRleHREaXN0YW5jZTogZGlzdGFuY2VcbiAgfTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRleHRQb3NpdGlvbih7fSwgZHVtbXlTdHlsZSwgcmVjdCk7XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcywgZm9udCk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodCwgY2FuQ2FjaGVCeVRleHRTdHJpbmd9XG4gKiAgTm90aWNlOiBmb3IgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxjdWxhdGUgb3V0ZXJXaWR0aCB1dGlsIG5lZWRlZC5cbiAqICBgY2FuQ2FjaGVCeVRleHRTdHJpbmdgIG1lYW5zIHRoZSByZXN1bHQgYGxpbmVzYCBpcyBvbmx5IGRldGVybWluZWQgYnkgdGhlIGlucHV0IGB0ZXh0YC5cbiAqICBUaHVzIHdlIGNhbiBzaW1wbHkgY29tcGFyaW5nIHRoZSBgaW5wdXRgIHRleHQgdG8gZGV0ZXJtaW4gd2hldGhlciB0aGUgcmVzdWx0IGNoYW5nZWQsXG4gKiAgd2l0aG91dCB0cmF2ZWwgdGhlIHJlc3VsdCBgbGluZXNgLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHRydW5jYXRlKSB7XG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gIHZhciBsaW5lSGVpZ2h0ID0gcmV0cmlldmUyKHRleHRMaW5lSGVpZ2h0LCBnZXRMaW5lSGVpZ2h0KGZvbnQpKTtcbiAgdmFyIGxpbmVzID0gdGV4dCA/IHRleHQuc3BsaXQoJ1xcbicpIDogW107XG4gIHZhciBoZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0O1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQ7XG4gIHZhciBjYW5DYWNoZUJ5VGV4dFN0cmluZyA9IHRydWU7XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICBvdXRlckhlaWdodCArPSBwYWRkaW5nWzBdICsgcGFkZGluZ1syXTtcbiAgfVxuXG4gIGlmICh0ZXh0ICYmIHRydW5jYXRlKSB7XG4gICAgY2FuQ2FjaGVCeVRleHRTdHJpbmcgPSBmYWxzZTtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgY2FuQ2FjaGVCeVRleHRTdHJpbmc6IGNhbkNhY2hlQnlUZXh0U3RyaW5nXG4gIH07XG59XG4vKipcbiAqIEZvciBleGFtcGxlOiAnc29tZSB0ZXh0IHthfHNvbWUgdGV4dH1vdGhlciB0ZXh0e2J8c29tZSB0ZXh0fXh4eHtjfH14eHgnXG4gKiBBbHNvIGNvbnNpZGVyICdiYmJie2F8eHh4XFxuenp6fXh4eHhcXG5hYWFhJy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IGJsb2NrXG4gKiB7XG4gKiAgICAgIHdpZHRoLFxuICogICAgICBoZWlnaHQsXG4gKiAgICAgIGxpbmVzOiBbe1xuICogICAgICAgICAgbGluZUhlaWdodCxcbiAqICAgICAgICAgIHdpZHRoLFxuICogICAgICAgICAgdG9rZW5zOiBbW3tcbiAqICAgICAgICAgICAgICBzdHlsZU5hbWUsXG4gKiAgICAgICAgICAgICAgdGV4dCxcbiAqICAgICAgICAgICAgICB3aWR0aCwgICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgaGVpZ2h0LCAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIHRleHRXaWR0aCwgLy8gcHVyZSB0ZXh0IHdpZHRoXG4gKiAgICAgICAgICAgICAgdGV4dEhlaWdodCwgLy8gcHVyZSB0ZXh0IGhlaWdodFxuICogICAgICAgICAgICAgIGxpbmVIZWloZ3QsXG4gKiAgICAgICAgICAgICAgZm9udCxcbiAqICAgICAgICAgICAgICB0ZXh0QWxpZ24sXG4gKiAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ25cbiAqICAgICAgICAgIH1dLCBbLi4uXSwgLi4uXVxuICogICAgICB9LCAuLi5dXG4gKiB9XG4gKiBJZiBzdHlsZU5hbWUgaXMgdW5kZWZpbmVkLCBpdCBpcyBwbGFpbiB0ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSkge1xuICB2YXIgY29udGVudEJsb2NrID0ge1xuICAgIGxpbmVzOiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gY29udGVudEJsb2NrO1xuICB9XG5cbiAgdmFyIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXggPSAwO1xuICB2YXIgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gU1RZTEVfUkVHLmV4ZWModGV4dCkpICE9IG51bGwpIHtcbiAgICB2YXIgbWF0Y2hlZEluZGV4ID0gcmVzdWx0LmluZGV4O1xuXG4gICAgaWYgKG1hdGNoZWRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hlZEluZGV4KSk7XG4gICAgfVxuXG4gICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHJlc3VsdFsyXSwgcmVzdWx0WzFdKTtcbiAgICBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4O1xuICB9XG5cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgdGV4dC5sZW5ndGgpKTtcbiAgfVxuXG4gIHZhciBsaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSAwO1xuICB2YXIgY29udGVudFdpZHRoID0gMDsgLy8gRm9yIGB0ZXh0V2lkdGg6IDEwMCVgXG5cbiAgdmFyIHBlbmRpbmdMaXN0ID0gW107XG4gIHZhciBzdGxQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciB0cnVuY2F0ZSA9IHN0eWxlLnRydW5jYXRlO1xuICB2YXIgdHJ1bmNhdGVXaWR0aCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVyV2lkdGg7XG4gIHZhciB0cnVuY2F0ZUhlaWdodCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVySGVpZ2h0O1xuXG4gIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgdHJ1bmNhdGVXaWR0aCAhPSBudWxsICYmICh0cnVuY2F0ZVdpZHRoIC09IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdKTtcbiAgICB0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmICh0cnVuY2F0ZUhlaWdodCAtPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXSk7XG4gIH0gLy8gQ2FsY3VsYXRlIGxheW91dCBpbmZvIG9mIHRva2Vucy5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gMDtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS50b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IGxpbmUudG9rZW5zW2pdO1xuICAgICAgdmFyIHRva2VuU3R5bGUgPSB0b2tlbi5zdHlsZU5hbWUgJiYgc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyB0ZXh0UGFkZGluZyBzaG91bGQgbm90IGluaGVyaXQgZnJvbSBzdHlsZS5cblxuICAgICAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmcgPSB0b2tlblN0eWxlLnRleHRQYWRkaW5nOyAvLyB0ZXh0Rm9udCBoYXMgYmVlbiBhc2lnbmVkIHRvIGZvbnQgYnkgYG5vcm1hbGl6ZVN0eWxlYC5cblxuICAgICAgdmFyIGZvbnQgPSB0b2tlbi5mb250ID0gdG9rZW5TdHlsZS5mb250IHx8IHN0eWxlLmZvbnQ7IC8vIHRleHRIZWlnaHQgY2FuIGJlIHVzZWQgd2hlbiB0ZXh0VmVydGljYWxBbGlnbiBpcyBzcGVjaWZpZWQgaW4gdG9rZW4uXG5cbiAgICAgIHZhciB0b2tlbkhlaWdodCA9IHRva2VuLnRleHRIZWlnaHQgPSByZXRyaWV2ZTIoIC8vIHRleHRIZWlnaHQgc2hvdWxkIG5vdCBiZSBpbmhlcml0ZWQsIGNvbnNpZGVyIGl0IGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgIC8vIGFzIGJveCBoZWlnaHQgb2YgdGhlIGJsb2NrLlxuICAgICAgdG9rZW5TdHlsZS50ZXh0SGVpZ2h0LCBnZXRMaW5lSGVpZ2h0KGZvbnQpKTtcbiAgICAgIHRleHRQYWRkaW5nICYmICh0b2tlbkhlaWdodCArPSB0ZXh0UGFkZGluZ1swXSArIHRleHRQYWRkaW5nWzJdKTtcbiAgICAgIHRva2VuLmhlaWdodCA9IHRva2VuSGVpZ2h0O1xuICAgICAgdG9rZW4ubGluZUhlaWdodCA9IHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRMaW5lSGVpZ2h0LCBzdHlsZS50ZXh0TGluZUhlaWdodCwgdG9rZW5IZWlnaHQpO1xuICAgICAgdG9rZW4udGV4dEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ247XG4gICAgICB0b2tlbi50ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCAnbWlkZGxlJztcblxuICAgICAgaWYgKHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgY29udGVudEhlaWdodCArIHRva2VuLmxpbmVIZWlnaHQgPiB0cnVuY2F0ZUhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4udGV4dFdpZHRoID0gZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICB2YXIgdG9rZW5XaWR0aCA9IHRva2VuU3R5bGUudGV4dFdpZHRoO1xuICAgICAgdmFyIHRva2VuV2lkdGhOb3RTcGVjaWZpZWQgPSB0b2tlbldpZHRoID09IG51bGwgfHwgdG9rZW5XaWR0aCA9PT0gJ2F1dG8nOyAvLyBQZXJjZW50IHdpZHRoLCBjYW4gYmUgYDEwMCVgLCBjYW4gYmUgdXNlZCBpbiBkcmF3aW5nIHNlcGFyYXRlXG4gICAgICAvLyBsaW5lIHdoZW4gYm94IHdpZHRoIGlzIG5lZWRlZCB0byBiZSBhdXRvLlxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuV2lkdGggPT09ICdzdHJpbmcnICYmIHRva2VuV2lkdGguY2hhckF0KHRva2VuV2lkdGgubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICB0b2tlbi5wZXJjZW50V2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgICBwZW5kaW5nTGlzdC5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5XaWR0aCA9IDA7IC8vIERvIG5vdCB0cnVuY2F0ZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXNlciBjYXNlXG4gICAgICAgIC8vIGFuZCBpdCBpcyB0b28gY29tcGxpY2F0ZWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5XaWR0aE5vdFNwZWNpZmllZCkge1xuICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGg7IC8vIEZJWE1FOiBJZiBpbWFnZSBpcyBub3QgbG9hZGVkIGFuZCB0ZXh0V2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsbGluZ1xuICAgICAgICAgIC8vIGBnZXRCb3VuZGluZ1JlY3QoKWAgd2lsbCBub3QgZ2V0IGNvcnJlY3QgcmVzdWx0LlxuXG4gICAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSB0b2tlblN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgdmFyIGJnSW1nID0gdGV4dEJhY2tncm91bmRDb2xvciAmJiB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlOyAvLyBVc2UgY2FzZXM6XG4gICAgICAgICAgLy8gKDEpIElmIGltYWdlIGlzIG5vdCBsb2FkZWQsIGl0IHdpbGwgYmUgbG9hZGVkIGF0IHJlbmRlciBwaGFzZSBhbmQgY2FsbFxuICAgICAgICAgIC8vIGBkaXJ0eSgpYCBhbmQgYHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2VgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbG9hZGVkXG4gICAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIHRoZSByaWdodCBzaXplIHdpbGwgYmUgY2FsY3VsYXRlZCBoZXJlIGF0IHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgLy8gU2VlIGBncmFwaGljL2hlbHBlci90ZXh0LmpzYC5cbiAgICAgICAgICAvLyAoMikgSWYgaW1hZ2UgbG9hZGVkLCBhbmQgYHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2VgIGlzIGltYWdlIHNyYyBzdHJpbmcsXG4gICAgICAgICAgLy8gdXNlIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgdG8gZmluZCBjYWNoZWQgaW1hZ2UuXG4gICAgICAgICAgLy8gYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB3aWxsIGFsd2F5cyBiZSBjYWxsZWQgaGVyZSBiZWZvcmVcbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZWAgaW4gYGdyYXBoaWMvaGVscGVyL3RleHQuanMjcmVuZGVyUmljaFRleHRgXG4gICAgICAgICAgLy8gd2hpY2ggZW5zdXJlcyB0aGF0IGltYWdlIHdpbGwgbm90IGJlIHJlbmRlcmVkIGJlZm9yZSBjb3JyZWN0IHNpemUgY2FsY3VhbHRlZC5cblxuICAgICAgICAgIGlmIChiZ0ltZykge1xuICAgICAgICAgICAgYmdJbWcgPSBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZShiZ0ltZyk7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoYmdJbWcpKSB7XG4gICAgICAgICAgICAgIHRva2VuV2lkdGggPSBNYXRoLm1heCh0b2tlbldpZHRoLCBiZ0ltZy53aWR0aCAqIHRva2VuSGVpZ2h0IC8gYmdJbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFkZGluZ1cgPSB0ZXh0UGFkZGluZyA/IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10gOiAwO1xuICAgICAgICB0b2tlbldpZHRoICs9IHBhZGRpbmdXO1xuICAgICAgICB2YXIgcmVtaWFuVHJ1bmNXaWR0aCA9IHRydW5jYXRlV2lkdGggIT0gbnVsbCA/IHRydW5jYXRlV2lkdGggLSBsaW5lV2lkdGggOiBudWxsO1xuXG4gICAgICAgIGlmIChyZW1pYW5UcnVuY1dpZHRoICE9IG51bGwgJiYgcmVtaWFuVHJ1bmNXaWR0aCA8IHRva2VuV2lkdGgpIHtcbiAgICAgICAgICBpZiAoIXRva2VuV2lkdGhOb3RTcGVjaWZpZWQgfHwgcmVtaWFuVHJ1bmNXaWR0aCA8IHBhZGRpbmdXKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gJyc7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSB0b2tlbldpZHRoID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IHRydW5jYXRlVGV4dCh0b2tlbi50ZXh0LCByZW1pYW5UcnVuY1dpZHRoIC0gcGFkZGluZ1csIGZvbnQsIHRydW5jYXRlLmVsbGlwc2lzLCB7XG4gICAgICAgICAgICAgIG1pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoICsgcGFkZGluZ1c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVXaWR0aCArPSB0b2tlbi53aWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICB0b2tlblN0eWxlICYmIChsaW5lSGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgdG9rZW4ubGluZUhlaWdodCkpO1xuICAgIH1cblxuICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgbGluZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICBjb250ZW50SGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgY29udGVudFdpZHRoID0gTWF0aC5tYXgoY29udGVudFdpZHRoLCBsaW5lV2lkdGgpO1xuICB9XG5cbiAgY29udGVudEJsb2NrLm91dGVyV2lkdGggPSBjb250ZW50QmxvY2sud2lkdGggPSByZXRyaWV2ZTIoc3R5bGUudGV4dFdpZHRoLCBjb250ZW50V2lkdGgpO1xuICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2suaGVpZ2h0ID0gcmV0cmlldmUyKHN0eWxlLnRleHRIZWlnaHQsIGNvbnRlbnRIZWlnaHQpO1xuXG4gIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgY29udGVudEJsb2NrLm91dGVyV2lkdGggKz0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM107XG4gICAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ICs9IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHBlbmRpbmdMaXN0W2ldO1xuICAgIHZhciBwZXJjZW50V2lkdGggPSB0b2tlbi5wZXJjZW50V2lkdGg7IC8vIFNob3VsZCBub3QgYmFzZSBvbiBvdXRlcldpZHRoLCBiZWNhdXNlIHRva2VuIGNhbiBub3QgYmUgcGxhY2VkIG91dCBvZiBwYWRkaW5nLlxuXG4gICAgdG9rZW4ud2lkdGggPSBwYXJzZUludChwZXJjZW50V2lkdGgsIDEwKSAvIDEwMCAqIGNvbnRlbnRXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50QmxvY2s7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb2tlbnMoYmxvY2ssIHN0ciwgc3R5bGVOYW1lKSB7XG4gIHZhciBpc0VtcHR5U3RyID0gc3RyID09PSAnJztcbiAgdmFyIHN0cnMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuICB2YXIgbGluZXMgPSBibG9jay5saW5lcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGV4dCA9IHN0cnNbaV07XG4gICAgdmFyIHRva2VuID0ge1xuICAgICAgc3R5bGVOYW1lOiBzdHlsZU5hbWUsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgaXNMaW5lSG9sZGVyOiAhdGV4dCAmJiAhaXNFbXB0eVN0clxuICAgIH07IC8vIFRoZSBmaXJzdCB0b2tlbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgbGluZS5cblxuICAgIGlmICghaSkge1xuICAgICAgdmFyIHRva2VucyA9IChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSB8fCAobGluZXNbMF0gPSB7XG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH0pKS50b2tlbnM7IC8vIENvbnNpZGVyIGNhc2VzOlxuICAgICAgLy8gKDEpICcnLnNwbGl0KCdcXG4nKSA9PiBbJycsICdcXG4nLCAnJ10sIHRoZSAnJyBhdCB0aGUgZmlyc3QgaXRlbVxuICAgICAgLy8gKHdoaWNoIGlzIGEgcGxhY2Vob2xkZXIpIHNob3VsZCBiZSByZXBsYWNlZCBieSBuZXcgdG9rZW4uXG4gICAgICAvLyAoMikgQSBpbWFnZSBiYWNrYWdlLCB3aGVyZSB0b2tlbiBsaWtlcyB7YXx9LlxuICAgICAgLy8gKDMpIEEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgLy8gKDQpIHRva2VucyB3aXRoIHRoZSBzYW1lIHRwbE5hbWUgc2hvdWxkIG5vdCBiZSBtZXJnZWQsIGJlY2F1c2VcbiAgICAgIC8vIHRoZXkgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkaWZmZXJlbnQgYm94ICh3aXRoIGJvcmRlciBhbmQgcGFkZGluZykuXG5cbiAgICAgIHZhciB0b2tlbnNMZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgdG9rZW5zTGVuID09PSAxICYmIHRva2Vuc1swXS5pc0xpbmVIb2xkZXIgPyB0b2tlbnNbMF0gPSB0b2tlbiA6IC8vIENvbnNpZGVyIHRleHQgaXMgJycsIG9ubHkgaW5zZXJ0IHdoZW4gaXQgaXMgdGhlIFwibGluZUhvbGRlclwiIG9yXG4gICAgICAvLyBcImVtcHR5U3RyXCIuIE90aGVyd2lzZSBhIHJlZHVuZGFudCAnJyB3aWxsIGFmZmVjdCB0ZXh0QWxpZ24gaW4gbGluZS5cbiAgICAgICh0ZXh0IHx8ICF0b2tlbnNMZW4gfHwgaXNFbXB0eVN0cikgJiYgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH0gLy8gT3RoZXIgdG9rZW5zIGFsd2F5cyBzdGFydCBhIG5ldyBsaW5lLlxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyAnJywgaW5zZXJ0IGl0IGFzIGEgcGxhY2Vob2xkZXIuXG4gICAgICAgIGxpbmVzLnB1c2goe1xuICAgICAgICAgIHRva2VuczogW3Rva2VuXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRm9udChzdHlsZSkge1xuICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgLy8gVXNlIGBmb250U2l6ZWAgYGZvbnRGYW1pbHlgIHRvIGNoZWNrIHdoZXRoZXIgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICB2YXIgZm9udCA9IChzdHlsZS5mb250U2l6ZSB8fCBzdHlsZS5mb250RmFtaWx5KSAmJiBbc3R5bGUuZm9udFN0eWxlLCBzdHlsZS5mb250V2VpZ2h0LCAoc3R5bGUuZm9udFNpemUgfHwgMTIpICsgJ3B4JywgLy8gSWYgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLCBgZm9udEZhbWlseWAgc2hvdWxkIG5vdCBiZSBpZ25vcmVkLlxuICBzdHlsZS5mb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJ10uam9pbignICcpO1xuICByZXR1cm4gZm9udCAmJiB0cmltKGZvbnQpIHx8IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG59XG5cbmV4cG9ydHMuREVGQVVMVF9GT05UID0gREVGQVVMVF9GT05UO1xuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmdldFdpZHRoID0gZ2V0V2lkdGg7XG5leHBvcnRzLmdldEJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdDtcbmV4cG9ydHMuYWRqdXN0VGV4dFggPSBhZGp1c3RUZXh0WDtcbmV4cG9ydHMuYWRqdXN0VGV4dFkgPSBhZGp1c3RUZXh0WTtcbmV4cG9ydHMuY2FsY3VsYXRlVGV4dFBvc2l0aW9uID0gY2FsY3VsYXRlVGV4dFBvc2l0aW9uO1xuZXhwb3J0cy5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QgPSBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q7XG5leHBvcnRzLnRydW5jYXRlVGV4dCA9IHRydW5jYXRlVGV4dDtcbmV4cG9ydHMuZ2V0TGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQ7XG5leHBvcnRzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG5leHBvcnRzLnBhcnNlUGxhaW5UZXh0ID0gcGFyc2VQbGFpblRleHQ7XG5leHBvcnRzLnBhcnNlUmljaFRleHQgPSBwYXJzZVJpY2hUZXh0O1xuZXhwb3J0cy5tYWtlRm9udCA9IG1ha2VGb250OyIsInZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuZnVuY3Rpb24gbm9ybWFsaXplUmFkaWFuKGFuZ2xlKSB7XG4gIGFuZ2xlICU9IFBJMjtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVJhZGlhbiA9IG5vcm1hbGl6ZVJhZGlhbjsiLCJmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICBpZiAoeSA+IHkwICYmIHkgPiB5MSB8fCB5IDwgeTAgJiYgeSA8IHkxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuXG5cbiAgaWYgKHkxID09PSB5MCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7IC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuXG4gIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICBkaXIgPSB5MSA8IHkwID8gMC41IDogLTAuNTtcbiAgfVxuXG4gIHZhciB4XyA9IHQgKiAoeDEgLSB4MCkgKyB4MDsgLy8gSWYgKHgsIHkpIG9uIHRoZSBsaW5lLCBjb25zaWRlcmVkIGFzIFwiY29udGFpblwiLlxuXG4gIHJldHVybiB4XyA9PT0geCA/IEluZmluaXR5IDogeF8gPiB4ID8gZGlyIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kaW5nTGluZTsiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG4gKiAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAqICAgICBnLnBvc2l0aW9uWzBdID0gMTAwO1xuICogICAgIGcucG9zaXRpb25bMV0gPSAxMDA7XG4gKiAgICAgZy5hZGQobmV3IENpcmNsZSh7XG4gKiAgICAgICAgIHN0eWxlOiB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDAsXG4gKiAgICAgICAgICAgICByOiAyMCxcbiAqICAgICAgICAgfVxuICogICAgIH0pKTtcbiAqICAgICB6ci5hZGQoZyk7XG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICovXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NoaWxkcmVuID0gW107XG4gIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcbiAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbn07XG5cbkdyb3VwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyb3VwLFxuICBpc0dyb3VwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2dyb3VwJyxcblxuICAvKipcbiAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgKi9cbiAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgKi9cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcyAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICB9XG5cbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5a2Q6IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgKi9cbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgdmFyIHJlY3QgPSBudWxsO1xuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTsgLy8gVE9ET1xuICAgICAgLy8gVGhlIGJvdW5kaW5nUmVjdCBjYWNsdWF0ZWQgYnkgdHJhbnNmb3JtaW5nIG9yaWdpbmFsXG4gICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgLy8gdGhlIGFjdHVhbCBib3VuZGluZ1JlY3Qgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoYXQgbm90IGJlXG4gICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcbnZhciBfZGVmYXVsdCA9IEdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cbmZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuXG4gIHRoaXMueCA9IHg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnkgPSB5O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG4gICAgdGhpcy53aWR0aCA9IG1hdGhNYXgob3RoZXIueCArIG90aGVyLndpZHRoLCB0aGlzLnggKyB0aGlzLndpZHRoKSAtIHg7XG4gICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KG90aGVyLnkgKyBvdGhlci5oZWlnaHQsIHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAqIEBtZXRob2RzXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsdCA9IFtdO1xuICAgIHZhciByYiA9IFtdO1xuICAgIHZhciBsYiA9IFtdO1xuICAgIHZhciBydCA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgcmJbMF0gPSBydFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGxiLCBsYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG4gICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcbiAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTsgLy8g55+p6Zi15Y+z5LmYXG5cbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICBiID0gQm91bmRpbmdSZWN0LmNyZWF0ZShiKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGF4MCA9IGEueDtcbiAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICB2YXIgYXkwID0gYS55O1xuICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcbiAgICB2YXIgYngwID0gYi54O1xuICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgIHZhciBieTAgPSBiLnk7XG4gICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuICAgIHJldHVybiAhKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgeSA+PSByZWN0LnkgJiYgeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gIH0sXG4gIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5Cb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEJvdW5kaW5nUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xuXG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xudmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuICB0aGlzLl90cmFjayA9IFtdO1xufTtcblxuR2VzdHVyZU1nci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdGhpcy5fZG9UcmFjayhldmVudCwgdGFyZ2V0LCByb290KTtcblxuICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemUoZXZlbnQpO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICBwb2ludHM6IFtdLFxuICAgICAgdG91Y2hlczogW10sXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgIHZhciBwb3MgPSBldmVudFV0aWwuY2xpZW50VG9Mb2NhbChyb290LCB0b3VjaCwge30pO1xuICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gIH0sXG4gIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gIHJldHVybiBbKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLCAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJdO1xufVxuXG52YXIgcmVjb2duaXplcnMgPSB7XG4gIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgIGlmIChwaW5jaFByZSAmJiBwaW5jaFByZS5sZW5ndGggPiAxICYmIHBpbmNoRW5kICYmIHBpbmNoRW5kLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG4gICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuXG59O1xudmFyIF9kZWZhdWx0ID0gR2VzdHVyZU1ncjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG5cbnZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbi8qKlxuICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHt9IHZhbFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gKi9cblxubGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICByZXR1cm4gZW50cnk7XG59O1xuLyoqXG4gKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9XG5cbiAgdGhpcy5fbGVuKys7XG59O1xuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGhlYWRcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIHRhaWxcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICB0aGlzLl9sZW4tLTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sZW47XG59O1xuLyoqXG4gKiBDbGVhciBsaXN0XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xuXG5cbnZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHt9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdmFsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLm5leHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMucHJldjtcbn07XG4vKipcbiAqIExSVSBDYWNoZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAqL1xuXG5cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbn07XG5cbnZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuXG5MUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIHZhciByZW1vdmVkID0gbnVsbDtcblxuICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBsaXN0LmxlbigpOyAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbGVhc3RVc2VkRW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZW50cnkua2V5ID0ga2V5O1xuICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIG1hcFtrZXldID0gZW50cnk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cblxuXG5MUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG5cbiAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxufTtcbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKi9cblxuXG5MUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbGlzdC5jbGVhcigpO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gTFJVO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3ksIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQpIHtcbiAgICAvLyBDb21wYXQuIFByZXZpb3VzbHkgdGhlcmUgaXMgbm8gc2VnbWVudElnbm9yZVRocmVzaG9sZC5cbiAgICBzZWdtZW50SWdub3JlVGhyZXNob2xkID0gc2VnbWVudElnbm9yZVRocmVzaG9sZCB8fCAwO1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicyhzZWdtZW50SWdub3JlVGhyZXNob2xkIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PT0gMCAmJiAoZHkgPiAwICYmIHkgPD0geTEgfHwgZHkgPCAwICYmIHkgPj0geTEpKSB7XG4gICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoOyAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuXG4gICAgICBpZiAoZHggPiAwICYmIHggPCB4MCB8fCBkeCA8IDAgJiYgeCA+IHgwIHx8IGR5ID4gMCAmJiB5IDwgeTAgfHwgZHkgPCAwICYmIHkgPiB5MCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSwgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSkpO1xuICAgIH0gLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuXG5cbiAgICBkeCA9IHggLSB4MTtcbiAgICBkeSA9IHkgLSB5MTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICB2YXIgdDtcbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07IC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG5cbiAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSkgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSkgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG5cblxuICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuXG4gICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgIHdoaWxlICh0IDw9IDEpIHtcbiAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTsgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcblxuICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSkgOiBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgfSAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG5cblxuICAgIGlkeCAlIDIgIT09IDAgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgIGR4ID0geDMgLSB4O1xuICAgIGR5ID0geTMgLSB5O1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICB2YXIgeDMgPSB4MjtcbiAgICB2YXIgeTMgPSB5MjtcbiAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAqL1xuICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG5cbiAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IDA7XG4gICAgdmFyIHlpID0gMDtcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MDtcbiAgICB2YXIgeTA7XG4gICAgdmFyIHhpO1xuICAgIHZhciB5aTtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICBjdHgucmVjdChkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5QYXRoUHJveHkuQ01EID0gQ01EO1xudmFyIF9kZWZhdWx0ID0gUGF0aFByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCIvLyBNeWVycycgRGlmZiBBbGdvcml0aG1cbi8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi9ibG9iL21hc3Rlci9zcmMvZGlmZi9iYXNlLmpzXG5mdW5jdGlvbiBEaWZmKCkge31cblxuRGlmZi5wcm90b3R5cGUgPSB7XG4gIGRpZmY6IGZ1bmN0aW9uIChvbGRBcnIsIG5ld0FyciwgZXF1YWxzKSB7XG4gICAgaWYgKCFlcXVhbHMpIHtcbiAgICAgIGVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgb2xkQXJyID0gb2xkQXJyLnNsaWNlKCk7XG4gICAgbmV3QXJyID0gbmV3QXJyLnNsaWNlKCk7IC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xuXG4gICAgdmFyIG5ld0xlbiA9IG5ld0Fyci5sZW5ndGg7XG4gICAgdmFyIG9sZExlbiA9IG9sZEFyci5sZW5ndGg7XG4gICAgdmFyIGVkaXRMZW5ndGggPSAxO1xuICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICBuZXdQb3M6IC0xLFxuICAgICAgY29tcG9uZW50czogW11cbiAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld0Fyciwgb2xkQXJyLCAwKTtcblxuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgfSAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcblxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgaW5kaWNlczogaW5kaWNlcyxcbiAgICAgICAgY291bnQ6IG5ld0Fyci5sZW5ndGhcbiAgICAgIH1dO1xuICAgIH0gLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuXG5cbiAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcbiAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xICogZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoIDw9IGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCArPSAyKSB7XG4gICAgICAgIHZhciBiYXNlUGF0aDtcbiAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXTtcbiAgICAgICAgdmFyIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXTtcbiAgICAgICAgdmFyIG9sZFBvcyA9IChyZW1vdmVQYXRoID8gcmVtb3ZlUGF0aC5uZXdQb3MgOiAwKSAtIGRpYWdvbmFsUGF0aDtcblxuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW47XG4gICAgICAgIHZhciBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gb2xkUG9zICYmIG9sZFBvcyA8IG9sZExlbjtcblxuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcblxuXG4gICAgICAgIGlmICghY2FuQWRkIHx8IGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxuXG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld0Fyciwgb2xkQXJyLCBkaWFnb25hbFBhdGgpOyAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxuXG4gICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBidWlsZFZhbHVlcyhzZWxmLCBiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdBcnIsIG9sZEFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfVxuXG4gICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHB1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxuICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0ge1xuICAgICAgICBjb3VudDogbGFzdC5jb3VudCArIDEsXG4gICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbiAoYmFzZVBhdGgsIG5ld0Fyciwgb2xkQXJyLCBkaWFnb25hbFBhdGgpIHtcbiAgICB2YXIgbmV3TGVuID0gbmV3QXJyLmxlbmd0aDtcbiAgICB2YXIgb2xkTGVuID0gb2xkQXJyLmxlbmd0aDtcbiAgICB2YXIgbmV3UG9zID0gYmFzZVBhdGgubmV3UG9zO1xuICAgIHZhciBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGg7XG4gICAgdmFyIGNvbW1vbkNvdW50ID0gMDtcblxuICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3QXJyW25ld1BvcyArIDFdLCBvbGRBcnJbb2xkUG9zICsgMV0pKSB7XG4gICAgICBuZXdQb3MrKztcbiAgICAgIG9sZFBvcysrO1xuICAgICAgY29tbW9uQ291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoY29tbW9uQ291bnQpIHtcbiAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGNvdW50OiBjb21tb25Db3VudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xuICAgIHJldHVybiBvbGRQb3M7XG4gIH0sXG4gIHRva2VuaXplOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld0Fyciwgb2xkQXJyKSB7XG4gIHZhciBjb21wb25lbnRQb3MgPSAwO1xuICB2YXIgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gIHZhciBuZXdQb3MgPSAwO1xuICB2YXIgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG5cbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmV3UG9zOyBpIDwgbmV3UG9zICsgY29tcG9uZW50LmNvdW50OyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBDb21tb24gY2FzZVxuXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2xkUG9zOyBpIDwgb2xkUG9zICsgY29tcG9uZW50LmNvdW50OyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4ge1xuICAgIG5ld1BvczogcGF0aC5uZXdQb3MsXG4gICAgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApXG4gIH07XG59XG5cbnZhciBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG4vKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuLyoqXG4gKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcCA9IHBvaW50c1swXTtcbiAgdmFyIGxlZnQgPSBwWzBdO1xuICB2YXIgcmlnaHQgPSBwWzBdO1xuICB2YXIgdG9wID0gcFsxXTtcbiAgdmFyIGJvdHRvbSA9IHBbMV07XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IGxlZnQ7XG4gIG1pblsxXSA9IHRvcDtcbiAgbWF4WzBdID0gcmlnaHQ7XG4gIG1heFsxXSA9IGJvdHRvbTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUxpbmUoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbn1cblxudmFyIHhEaW0gPSBbXTtcbnZhciB5RGltID0gW107XG4vKipcbiAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heCkge1xuICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gIHZhciBpO1xuICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gIG1pblswXSA9IEluZmluaXR5O1xuICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgbWF4WzBdID0gLUluZmluaXR5O1xuICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgfVxuXG4gIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xufVxuLyoqXG4gKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7IC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuXG4gIHZhciB0eCA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDApO1xuICB2YXIgdHkgPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwKTtcbiAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG59XG4vKipcbiAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gKiBAcGFyYW0ge251bWJlcn0gcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFyYyh4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heCkge1xuICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgbWluWzFdID0geSAtIHJ5O1xuICAgIG1heFswXSA9IHggKyByeDtcbiAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG4gIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcbiAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7IC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG5cbiAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSBQSTI7XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gIH1cblxuICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgUEkyO1xuXG4gIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfSBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gIH0gLy8gdmFyIG51bWJlciA9IDA7XG4gIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcblxuXG4gIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZnJvbVBvaW50cyA9IGZyb21Qb2ludHM7XG5leHBvcnRzLmZyb21MaW5lID0gZnJvbUxpbmU7XG5leHBvcnRzLmZyb21DdWJpYyA9IGZyb21DdWJpYztcbmV4cG9ydHMuZnJvbVF1YWRyYXRpYyA9IGZyb21RdWFkcmF0aWM7XG5leHBvcnRzLmZyb21BcmMgPSBmcm9tQXJjOyIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgdjJDcmVhdGUgPSBfdmVjdG9yLmNyZWF0ZTtcbnZhciB2MkRpc3RTcXVhcmUgPSBfdmVjdG9yLmRpc3RTcXVhcmU7XG5cbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBFUFNJTE9OID0gMWUtODtcbnZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xudmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbnZhciBPTkVfVEhJUkQgPSAxIC8gMzsgLy8g5Li05pe25Y+Y6YePXG5cbnZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YxID0gdjJDcmVhdGUoKTtcblxudmFyIF92MiA9IHYyQ3JlYXRlKCk7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG59XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSkgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gMyAqICgoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXQgKyAocDMgLSBwMikgKiB0ICogdCk7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICB2YXIgYyA9IDMgKiAocDEgLSBwMCk7XG4gIHZhciBkID0gcDAgLSB2YWw7XG4gIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgIHJvb3RzWzBdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHQxID0gLWMgLyBiOyAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgLy8gdDEsIGEgaXMgbm90IHplcm9cblxuICAgICAgdmFyIHQyID0gLUsgLyAyOyAvLyB0MiwgdDNcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuXG4gICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcbiAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjtcbiAgb3V0WzNdID0gcDAxMjM7IC8vIFNlZzFcblxuICBvdXRbNF0gPSBwMDEyMztcbiAgb3V0WzVdID0gcDEyMztcbiAgb3V0WzZdID0gcDIzO1xuICBvdXRbN10gPSBwMztcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciBwcmV2O1xuICB2YXIgbmV4dDtcbiAgdmFyIGQxO1xuICB2YXIgZDI7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogKG9uZXQgKiBwMCArIDIgKiB0ICogcDEpICsgdCAqIHQgKiBwMjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICB2YXIgYyA9IHAwIC0gdmFsO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICB2YXIgZGl2aWRlciA9IHAwICsgcDIgLSAyICogcDE7XG5cbiAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgcmV0dXJuIDAuNTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgfVxufVxuLyoqXG4gKiDnu4bliIbkuozmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyOyAvLyBTZWcxXG5cbiAgb3V0WzNdID0gcDAxMjtcbiAgb3V0WzRdID0gcDEyO1xuICBvdXRbNV0gPSBwMjtcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LqM5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICB2YXIgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdCk7XG4gICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuXG5leHBvcnRzLmN1YmljQXQgPSBjdWJpY0F0O1xuZXhwb3J0cy5jdWJpY0Rlcml2YXRpdmVBdCA9IGN1YmljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5jdWJpY1Jvb3RBdCA9IGN1YmljUm9vdEF0O1xuZXhwb3J0cy5jdWJpY0V4dHJlbWEgPSBjdWJpY0V4dHJlbWE7XG5leHBvcnRzLmN1YmljU3ViZGl2aWRlID0gY3ViaWNTdWJkaXZpZGU7XG5leHBvcnRzLmN1YmljUHJvamVjdFBvaW50ID0gY3ViaWNQcm9qZWN0UG9pbnQ7XG5leHBvcnRzLnF1YWRyYXRpY0F0ID0gcXVhZHJhdGljQXQ7XG5leHBvcnRzLnF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMucXVhZHJhdGljUm9vdEF0ID0gcXVhZHJhdGljUm9vdEF0O1xuZXhwb3J0cy5xdWFkcmF0aWNFeHRyZW11bSA9IHF1YWRyYXRpY0V4dHJlbXVtO1xuZXhwb3J0cy5xdWFkcmF0aWNTdWJkaXZpZGUgPSBxdWFkcmF0aWNTdWJkaXZpZGU7XG5leHBvcnRzLnF1YWRyYXRpY1Byb2plY3RQb2ludCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludDsiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG52YXIgX2ZvdXJQb2ludHNUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9mb3VyUG9pbnRzVHJhbnNmb3JtXCIpO1xuXG52YXIgYnVpbGRUcmFuc2Zvcm1lciA9IF9mb3VyUG9pbnRzVHJhbnNmb3JtLmJ1aWxkVHJhbnNmb3JtZXI7XG52YXIgRVZFTlRfU0FWRURfUFJPUCA9ICdfX196ckVWRU5UU0FWRUQnO1xudmFyIF9jYWxjT3V0ID0gW107XG4vKipcbiAqIFRyYW5zZm9ybSBcImxvY2FsIGNvb3JkXCIgZnJvbSBgZWxGcm9tYCB0byBgZWxUYXJnZXRgLlxuICogXCJsb2NhbCBjb29yZFwiOiB0aGUgY29vcmQgYmFzZWQgb24gdGhlIGlucHV0IGBlbGAuIFRoZSBvcmlnaW4gcG9pbnQgaXMgYXRcbiAqICAgICB0aGUgcG9zaXRpb24gb2YgXCJsZWZ0OiAwOyB0b3A6IDA7XCIgaW4gdGhlIGBlbGAuXG4gKlxuICogU3VwcG9ydCB3aGVuIENTUyB0cmFuc2Zvcm0gaXMgdXNlZC5cbiAqXG4gKiBIYXZpbmcgdGhlIGBvdXRgICh0aGF0IGlzLCBgW291dFgsIG91dFldYCksIHdlIGNhbiBjcmVhdGUgYW4gRE9NIGVsZW1lbnRcbiAqIGFuZCBzZXQgdGhlIENTUyBzdHlsZSBhcyBcImxlZnQ6IG91dFg7IHRvcDogb3V0WTtcIiBhbmQgYXBwZW5kIGl0IHRvIGBlbFRhcmdlYFxuICogdG8gbG9jYXRlIHRoZSBlbGVtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGlzIGNvZGUgYmVsb3cgcG9zaXRpb25zIGEgY2hpbGQgb2YgYGRvY3VtZW50LmJvZHlgIG9uIHRoZSBldmVudFxuICogcG9pbnQsIG5vIG1hdHRlciB3aGV0aGVyIGBib2R5YCBoYXMgYG1hcmdpbmAvYHBhZGRpbmAvYHRyYW5zZnJvbWAvLi4uIDpcbiAqIGBgYGpzXG4gKiB0cmFuc2Zvcm1Mb2NhbENvb3JkKG91dCwgY29udGFpbmVyLCBkb2N1bWVudC5ib2R5LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAqIGlmICghZXFOYU4ob3V0WzBdKSkge1xuICogICAgIC8vIFRoZW4gbG9jYXRlIHRoZSB0aXAgZWxlbWVudCBvbiB0aGUgZXZlbnQgcG9pbnQuXG4gKiAgICAgdmFyIHRpcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gKiAgICAgdGlwRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6JyArIG91dFswXSArICc7dG9wOicgKyBvdXRbMV0gKyAnOyc7XG4gKiAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aXBFbCk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2U6IEluIHNvbWUgZW52IHRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQuIElmIGNhbGxlZCwgYG91dGAgd2lsbCBiZSBgW05hTiwgTmFOXWAuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IFtpblg6IG51bWJlciwgaW5ZOiBudW1iZXJdIFRoZSBvdXRwdXQuLlxuICogICAgICAgIElmIGNhbiBub3QgdHJhbnNmb3JtLCBgb3V0YCB3aWxsIG5vdCBiZSBtb2RpZmllZCBidXQgcmV0dXJuIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbEZyb20gVGhlIGBbaW5YLCBpblldYCBpcyBiYXNlZCBvbiBlbEZyb20uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRhcmdldCBUaGUgYG91dGAgaXMgYmFzZWQgb24gZWxUYXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5YXG4gKiBAcGFyYW0ge251bWJlcn0gaW5ZXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRyYW5zZm9ybSBzdWNjZXNzZnVsbHkuXG4gKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9jYWxDb29yZChvdXQsIGVsRnJvbSwgZWxUYXJnZXQsIGluWCwgaW5ZKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1Db29yZFdpdGhWaWV3cG9ydChfY2FsY091dCwgZWxGcm9tLCBpblgsIGluWSwgdHJ1ZSkgJiYgdHJhbnNmb3JtQ29vcmRXaXRoVmlld3BvcnQob3V0LCBlbFRhcmdldCwgX2NhbGNPdXRbMF0sIF9jYWxjT3V0WzFdKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGJldHdlZW4gYSBcInZpZXdwb3J0IGNvb3JkXCIgYW5kIGEgXCJsb2NhbCBjb29yZFwiLlxuICogXCJ2aWV3cG9ydCBjb29yZFwiOiB0aGUgY29vcmQgYmFzZWQgb24gdGhlIGxlZnQtdG9wIGNvcm5lciBvZiB0aGUgdmlld3BvcnRcbiAqICAgICBvZiB0aGUgYnJvd3Nlci5cbiAqIFwibG9jYWwgY29vcmRcIjogdGhlIGNvb3JkIGJhc2VkIG9uIHRoZSBpbnB1dCBgZWxgLiBUaGUgb3JpZ2luIHBvaW50IGlzIGF0XG4gKiAgICAgdGhlIHBvc2l0aW9uIG9mIFwibGVmdDogMDsgdG9wOiAwO1wiIGluIHRoZSBgZWxgLlxuICpcbiAqIFN1cHBvcnQgdGhlIGNhc2Ugd2hlbiBDU1MgdHJhbnNmb3JtIGlzIHVzZWQgb24gZWwuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IFtpblg6IG51bWJlciwgaW5ZOiBudW1iZXJdIFRoZSBvdXRwdXQuIElmIGBpbnZlcnNlOiBmYWxzZWAsXG4gKiAgICAgICAgaXQgcmVwcmVzZW50cyBcImxvY2FsIGNvb3JkXCIsIG90aGVyd2lzZSBcInZpcmVwb3J0IGNvb3JkXCIuXG4gKiAgICAgICAgSWYgY2FuIG5vdCB0cmFuc2Zvcm0sIGBvdXRgIHdpbGwgbm90IGJlIG1vZGlmaWVkIGJ1dCByZXR1cm4gYGZhbHNlYC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBcImxvY2FsIGNvb3JkXCIgaXMgYmFzZWQgb24gdGhlIGBlbGAsIHNlZSBjb21tZW50IGFib3ZlLlxuICogQHBhcmFtIHtudW1iZXJ9IGluWCBJZiBgaW52ZXJzZTogZmFsc2VgLFxuICogICAgICAgIGl0IHJlcHJlc2VudHMgXCJ2aXJlcG9ydCBjb29yZFwiLCBvdGhlcndpc2UgXCJsb2NhbCBjb29yZFwiLlxuICogQHBhcmFtIHtudW1iZXJ9IGluWSBJZiBgaW52ZXJzZTogZmFsc2VgLFxuICogICAgICAgIGl0IHJlcHJlc2VudHMgXCJ2aXJlcG9ydCBjb29yZFwiLCBvdGhlcndpc2UgXCJsb2NhbCBjb29yZFwiLlxuICogQHBhcmFtIHtib29sZWFufSBbaW52ZXJzZT1mYWxzZV1cbiAqICAgICAgICBgdHJ1ZWA6IGZyb20gXCJ2aWV3cG9ydCBjb29yZFwiIHRvIFwibG9jYWwgY29vcmRcIi5cbiAqICAgICAgICBgZmFsc2VgOiBmcm9tIFwibG9jYWwgY29vcmRcIiB0byBcInZpZXdwb3J0IGNvb3JkXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRyYW5zZm9ybSBzdWNjZXNzZnVsbHkuXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Db29yZFdpdGhWaWV3cG9ydChvdXQsIGVsLCBpblgsIGluWSwgaW52ZXJzZSkge1xuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVudi5kb21TdXBwb3J0ZWQgJiYgIWlzQ2FudmFzRWwoZWwpKSB7XG4gICAgdmFyIHNhdmVkID0gZWxbRVZFTlRfU0FWRURfUFJPUF0gfHwgKGVsW0VWRU5UX1NBVkVEX1BST1BdID0ge30pO1xuICAgIHZhciBtYXJrZXJzID0gcHJlcGFyZUNvb3JkTWFya2VycyhlbCwgc2F2ZWQpO1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IHByZXBhcmVQb2ludGVyVHJhbnNmb3JtZXIobWFya2Vycywgc2F2ZWQsIGludmVyc2UpO1xuXG4gICAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgICB0cmFuc2Zvcm1lcihvdXQsIGluWCwgaW5ZKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvb3JkTWFya2VycyhlbCwgc2F2ZWQpIHtcbiAgdmFyIG1hcmtlcnMgPSBzYXZlZC5tYXJrZXJzO1xuXG4gIGlmIChtYXJrZXJzKSB7XG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH1cblxuICBtYXJrZXJzID0gc2F2ZWQubWFya2VycyA9IFtdO1xuICB2YXIgcHJvcExSID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIHZhciBwcm9wVEIgPSBbJ3RvcCcsICdib3R0b20nXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgc3RsID0gbWFya2VyLnN0eWxlO1xuICAgIHZhciBpZHhMUiA9IGkgJSAyO1xuICAgIHZhciBpZHhUQiA9IChpID4+IDEpICUgMjtcbiAgICBzdGwuY3NzVGV4dCA9IFsncG9zaXRpb246IGFic29sdXRlJywgJ3Zpc2liaWxpdHk6IGhpZGRlbicsICdwYWRkaW5nOiAwJywgJ21hcmdpbjogMCcsICdib3JkZXItd2lkdGg6IDAnLCAndXNlci1zZWxlY3Q6IG5vbmUnLCAnd2lkdGg6MCcsICdoZWlnaHQ6MCcsIC8vICd3aWR0aDogNXB4JyxcbiAgICAvLyAnaGVpZ2h0OiA1cHgnLFxuICAgIHByb3BMUltpZHhMUl0gKyAnOjAnLCBwcm9wVEJbaWR4VEJdICsgJzowJywgcHJvcExSWzEgLSBpZHhMUl0gKyAnOmF1dG8nLCBwcm9wVEJbMSAtIGlkeFRCXSArICc6YXV0bycsICcnXS5qb2luKCchaW1wb3J0YW50OycpO1xuICAgIGVsLmFwcGVuZENoaWxkKG1hcmtlcik7XG4gICAgbWFya2Vycy5wdXNoKG1hcmtlcik7XG4gIH1cblxuICByZXR1cm4gbWFya2Vycztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVBvaW50ZXJUcmFuc2Zvcm1lcihtYXJrZXJzLCBzYXZlZCwgaW52ZXJzZSkge1xuICB2YXIgdHJhbnNmb3JtZXJOYW1lID0gaW52ZXJzZSA/ICdpbnZUcmFucycgOiAndHJhbnMnO1xuICB2YXIgdHJhbnNmb3JtZXIgPSBzYXZlZFt0cmFuc2Zvcm1lck5hbWVdO1xuICB2YXIgb2xkU3JjQ29vcmRzID0gc2F2ZWQuc3JjQ29vcmRzO1xuICB2YXIgb2xkQ29vcmRUaGVTYW1lID0gdHJ1ZTtcbiAgdmFyIHNyY0Nvb3JkcyA9IFtdO1xuICB2YXIgZGVzdENvb3JkcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIHJlY3QgPSBtYXJrZXJzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBpaSA9IDIgKiBpO1xuICAgIHZhciB4ID0gcmVjdC5sZWZ0O1xuICAgIHZhciB5ID0gcmVjdC50b3A7XG4gICAgc3JjQ29vcmRzLnB1c2goeCwgeSk7XG4gICAgb2xkQ29vcmRUaGVTYW1lID0gb2xkQ29vcmRUaGVTYW1lICYmIG9sZFNyY0Nvb3JkcyAmJiB4ID09PSBvbGRTcmNDb29yZHNbaWldICYmIHkgPT09IG9sZFNyY0Nvb3Jkc1tpaSArIDFdO1xuICAgIGRlc3RDb29yZHMucHVzaChtYXJrZXJzW2ldLm9mZnNldExlZnQsIG1hcmtlcnNbaV0ub2Zmc2V0VG9wKTtcbiAgfSAvLyBDYWNoZSB0byBhdm9pZCB0aW1lIGNvbnN1bWluZyBvZiBgYnVpbGRUcmFuc2Zvcm1lcmAuXG5cblxuICByZXR1cm4gb2xkQ29vcmRUaGVTYW1lICYmIHRyYW5zZm9ybWVyID8gdHJhbnNmb3JtZXIgOiAoc2F2ZWQuc3JjQ29vcmRzID0gc3JjQ29vcmRzLCBzYXZlZFt0cmFuc2Zvcm1lck5hbWVdID0gaW52ZXJzZSA/IGJ1aWxkVHJhbnNmb3JtZXIoZGVzdENvb3Jkcywgc3JjQ29vcmRzKSA6IGJ1aWxkVHJhbnNmb3JtZXIoc3JjQ29vcmRzLCBkZXN0Q29vcmRzKSk7XG59XG5cbmZ1bmN0aW9uIGlzQ2FudmFzRWwoZWwpIHtcbiAgcmV0dXJuIGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xufVxuXG5leHBvcnRzLnRyYW5zZm9ybUxvY2FsQ29vcmQgPSB0cmFuc2Zvcm1Mb2NhbENvb3JkO1xuZXhwb3J0cy50cmFuc2Zvcm1Db29yZFdpdGhWaWV3cG9ydCA9IHRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0O1xuZXhwb3J0cy5pc0NhbnZhc0VsID0gaXNDYW52YXNFbDsiLCIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xuXG4vKiBnbG9iYWwgd3ggKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiB3eCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHd4LmdldFN5c3RlbUluZm9TeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEluIFdlaXhpbiBBcHBsaWNhdGlvblxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIHd4YTogdHJ1ZSxcbiAgICAvLyBXZWl4aW4gQXBwbGljYXRpb25cbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiBmYWxzZSxcbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBkb21TdXBwb3J0ZWQ6IGZhbHNlXG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIHdvcmtlclxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIHdvcmtlcjogdHJ1ZSxcbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgZG9tU3VwcG9ydGVkOiBmYWxzZVxuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAvLyBJbiBub2RlXG4gIGVudiA9IHtcbiAgICBicm93c2VyOiB7fSxcbiAgICBvczoge30sXG4gICAgbm9kZTogdHJ1ZSxcbiAgICB3b3JrZXI6IGZhbHNlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBkb21TdXBwb3J0ZWQ6IGZhbHNlXG4gIH07XG59IGVsc2Uge1xuICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IGVudjsgLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gIHZhciBvcyA9IHt9O1xuICB2YXIgYnJvd3NlciA9IHt9OyAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcblxuICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7IC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuXG4gIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICB2YXIgd2VDaGF0ID0gL21pY3JvbWVzc2VuZ2VyL2kudGVzdCh1YSk7IC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuXG4gIGlmIChmaXJlZm94KSB7XG4gICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICB9IC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cblxuICBpZiAoaWUpIHtcbiAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgfVxuXG4gIGlmIChlZGdlKSB7XG4gICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICB9IC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuXG5cbiAgaWYgKHdlQ2hhdCkge1xuICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgfSAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBub2RlOiBmYWxzZSxcbiAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICBzdmdTdXBwb3J0ZWQ6IHR5cGVvZiBTVkdSZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAvLyAoMSkgRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGluIGlPUyAxMyBNb2JpbGUgQ2hyb21pdW0gNzgsIGlmIHRoZSB0b3VjaGluZyBiZWhhdmlvciBzdGFydHMgcGFnZVxuICAgIC8vIHNjcm9sbCwgdGhlIGBwb2ludGVybW92ZWAgZXZlbnQgY2FuIG5vdCBiZSBmaXJlZCBhbnkgbW9yZS4gVGhhdCB3aWxsIGJyZWFrIHNvbWVcbiAgICAvLyBmZWF0dXJlcyBsaWtlIFwicGFuIGhvcml6b250YWxseSB0byBtb3ZlIHNvbWV0aGluZyBhbmQgcGFuIHZlcnRpY2FsbHkgdG8gcGFnZSBzY3JvbGxcIi5cbiAgICAvLyBUaGUgaG9yaXpvbnRhbCBwYW4gcHJvYmFibHkgYmUgaW50ZXJydXB0ZWQgYnkgdGhlIGNhc3VhbGx5IHRyaWdnZXJlZCBwYWdlIHNjcm9sbC5cbiAgICAvLyAoMikgQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAnb25wb2ludGVyZG93bicgaW4gd2luZG93ICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpLFxuICAgIC8vIHBhc3NpdmVTdXBwb3J0ZWQ6IGRldGVjdFBhc3NpdmVTdXBwb3J0KClcbiAgICBkb21TdXBwb3J0ZWQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgfTtcbn0gLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4vLyBmdW5jdGlvbiBkZXRlY3RQYXNzaXZlU3VwcG9ydCgpIHtcbi8vICAgICAvLyBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlIGlmIHRoZSBwYXNzaXZlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4vLyAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbi8vICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIGZ1bmN0aW9uKCkge30sIG9wdHMpO1xuLy8gICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbi8vIH1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuZXhwb3J0cy5EaXNwYXRjaGVyID0gRXZlbnRmdWw7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9lbnZcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4vZG9tXCIpO1xuXG52YXIgaXNDYW52YXNFbCA9IF9kb20uaXNDYW52YXNFbDtcbnZhciB0cmFuc2Zvcm1Db29yZFdpdGhWaWV3cG9ydCA9IF9kb20udHJhbnNmb3JtQ29vcmRXaXRoVmlld3BvcnQ7XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBtb3VzZSBvciB0b3VjaCBldmVudHMuXG4gKi9cbnZhciBpc0RvbUxldmVsMiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgTU9VU0VfRVZFTlRfUkVHID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svO1xudmFyIF9jYWxjT3V0ID0gW107XG4vKipcbiAqIEdldCB0aGUgYHpyWGAgYW5kIGB6cllgLCB3aGljaCBhcmUgcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IG9mXG4gKiB0aGUgaW5wdXQgYGVsYC5cbiAqIENTUyB0cmFuc2Zvcm0gKDJEICYgM0QpIGlzIHN1cHBvcnRlZC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgdG8gZmV0Y2ggdGhlIGNvb3JkczpcbiAqICsgSWYgYGNhbGN1bGF0ZWAgaXMgbm90IHNldCBhcyBgdHJ1ZWAsIHVzZXJzIG9mIHRoaXMgbWV0aG9kIHNob3VsZFxuICogZW5zdXJlIHRoYXQgYGVsYCBpcyB0aGUgc2FtZSBvciB0aGUgc2FtZSBzaXplICYgbG9jYXRpb24gYXMgYGUudGFyZ2V0YC5cbiAqIE90aGVyd2lzZSB0aGUgcmVzdWx0IGNvb3JkcyBhcmUgcHJvYmFibHkgbm90IGV4cGVjdGVkLiBCZWNhdXNlIHdlXG4gKiBmaXJzdGx5IHRyeSB0byBnZXQgY29vcmRzIGZyb20gZS5vZmZzZXRYL2Uub2Zmc2V0WS5cbiAqICsgSWYgYGNhbGN1bGF0ZWAgaXMgc2V0IGFzIGB0cnVlYCwgdGhlIGlucHV0IGBlbGAgY2FuIGJlIGFueSBlbGVtZW50XG4gKiBhbmQgd2UgZm9yY2UgdG8gY2FsY3VsYXRlIHRoZSBjb29yZHMgYmFzZWQgb24gYGVsYC5cbiAqICsgVGhlIGlucHV0IGBlbGAgc2hvdWxkIGJlIHBvc2l0aW9uYWJsZSAobm90IHBvc2l0aW9uOnN0YXRpYykuXG4gKlxuICogVGhlIGZvcmNlIGBjYWxjdWxhdGVgIGNhbiBiZSB1c2VkIGluIGNhc2UgbGlrZTpcbiAqIFdoZW4gbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBvbiBlYyB0b29sdGlwLCBgZS50YXJnZXRgIGlzIG5vdCBgZWxgKHpyIHBhaW50ZXIuZG9tKS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGUgTW91c2UgZXZlbnQgb3IgdG91Y2ggZXZlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0IEdldCBgb3V0LnpyWGAgYW5kIGBvdXQuenJZYCBhcyB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtib29sZWFufSBbY2FsY3VsYXRlPWZhbHNlXSBXaGV0aGVyIHRvIGZvcmNlIGNhbGN1bGF0ZVxuICogICAgICAgIHRoZSBjb29yZGluYXRlcyBidXQgbm90IHVzZSBvbmVzIHByb3ZpZGVkIGJ5IGJyb3dzZXIuXG4gKi9cblxuZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgb3V0ID0gb3V0IHx8IHt9OyAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cblxuICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgY2FsY3VsYXRlWnJYWShlbCwgZSwgb3V0KTtcbiAgfSAvLyBDYXV0aW9uOiBJbiBGaXJlRm94LCBsYXllclgvbGF5ZXJZIE1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgLy8gYW5jZXN0b3IgZWxlbWVudCwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSBlbCBpcyBwb3NpdGlvbmVkIChlLmcuLCBub3QgcG9zaXRpb246c3RhdGljKS5cbiAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gIC8vIHpvb20tZmFjdG9yLCBvdmVyZmxvdyAvIG9wYWNpdHkgbGF5ZXJzLCB0cmFuc2Zvcm1zIC4uLilcbiAgLy8gQlRXMiwgKGV2Lm9mZnNldFkgfHwgZXYucGFnZVkgLSAkKGV2LnRhcmdldCkub2Zmc2V0KCkudG9wKSBpcyBub3QgY29ycmVjdCBpbiBwcmVzZXJ2ZS0zZC5cbiAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gIC8vIEJUVzMsIEluIGZmLCBvZmZzZXRYL29mZnNldFkgaXMgYWx3YXlzIDAuXG4gIGVsc2UgaWYgKGVudi5icm93c2VyLmZpcmVmb3ggJiYgZS5sYXllclggIT0gbnVsbCAmJiBlLmxheWVyWCAhPT0gZS5vZmZzZXRYKSB7XG4gICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICBvdXQuenJZID0gZS5sYXllclk7XG4gICAgfSAvLyBGb3IgSUU2KywgY2hyb21lLCBzYWZhcmksIG9wZXJhLiAoV2hlbiB3aWxsIGZmIHN1cHBvcnQgb2Zmc2V0WD8pXG4gICAgZWxzZSBpZiAoZS5vZmZzZXRYICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnpyWCA9IGUub2Zmc2V0WDtcbiAgICAgICAgb3V0LnpyWSA9IGUub2Zmc2V0WTtcbiAgICAgIH0gLy8gRm9yIHNvbWUgb3RoZXIgZGV2aWNlLCBlLmcuLCBJT1Mgc2FmYXJpLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsY3VsYXRlWnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVpyWFkoZWwsIGUsIG91dCkge1xuICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpIGRvbid0IGhhdmUgZ2V0Qm91bmRpbmdSZWN0LlxuICBpZiAoZW52LmRvbVN1cHBvcnRlZCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICB2YXIgZXggPSBlLmNsaWVudFg7XG4gICAgdmFyIGV5ID0gZS5jbGllbnRZO1xuXG4gICAgaWYgKGlzQ2FudmFzRWwoZWwpKSB7XG4gICAgICAvLyBPcmlnaW5hbCBhcHByb2FjaCwgd2hpY2ggZG8gbm90IHN1cHBvcnQgQ1NTIHRyYW5zZm9ybS5cbiAgICAgIC8vIG1hcmtlciBjYW4gbm90IGJlIGxvY2F0aW9uZWQgaW4gYSBjYW52YXMgY29udGFpbmVyXG4gICAgICAvLyAoZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGFsd2F5cyAwKS4gV2UgZG8gbm90IHN1cHBvcnRcbiAgICAgIC8vIHRoYXQgaW5wdXQgYSBwcmUtY3JlYXRlZCBjYW52YXMgdG8genIgd2hpbGUgdXNpbmcgY3NzXG4gICAgICAvLyB0cmFuc2Zvcm0gaW4gaU9TLlxuICAgICAgdmFyIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgb3V0LnpyWCA9IGV4IC0gYm94LmxlZnQ7XG4gICAgICBvdXQuenJZID0gZXkgLSBib3gudG9wO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHJhbnNmb3JtQ29vcmRXaXRoVmlld3BvcnQoX2NhbGNPdXQsIGVsLCBleCwgZXkpKSB7XG4gICAgICAgIG91dC56clggPSBfY2FsY091dFswXTtcbiAgICAgICAgb3V0LnpyWSA9IF9jYWxjT3V0WzFdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb3V0LnpyWCA9IG91dC56clkgPSAwO1xufVxuLyoqXG4gKiBGaW5kIG5hdGl2ZSBldmVudCBjb21wYXQgZm9yIGxlZ2VuY3kgSUUuXG4gKiBTaG91bGQgYmUgY2FsbGVkIGF0IHRoZSBiZWdpbmluZyBvZiBhIG5hdGl2ZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBbZV0gTW91c2UgZXZlbnQgb3IgdG91Y2ggZXZlbnQgb3IgcG9pbnRlciBldmVudC5cbiAqICAgICAgICBGb3IgbGFnZW5jeSBJRSwgd2UgdXNlIGB3aW5kb3cuZXZlbnRgIGlzIHVzZWQuXG4gKiBAcmV0dXJuIHtFdmVudH0gVGhlIG5hdGl2ZSBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5hdGl2ZUV2ZW50KGUpIHtcbiAgcmV0dXJuIGUgfHwgd2luZG93LmV2ZW50O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnB1dCBldmVudC5cbiAqXG4gKiBHZXQgdGhlIGBlLnpyWGAgYW5kIGBlLnpyWWAsIHdoaWNoIGFyZSByZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgb2ZcbiAqIHRoZSBpbnB1dCBgZWxgLlxuICogR2V0IGBlLnpyRGVsdGFgIGlmIHVzaW5nIG1vdXNlIHdoZWVsLlxuICogR2V0IGBlLndoaWNoYCwgc2VlIHRoZSBjb21tZW50IGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIERvIG5vdCBjYWxjdWxhdGUgcmVwZWF0bHkgaWYgYHpyWGAgYW5kIGB6cllgIGFscmVhZHkgZXhpc3QuXG4gKlxuICogTm90aWNlOiBzZWUgY29tbWVudHMgaW4gYGNsaWVudFRvTG9jYWxgLiBjaGVjayB0aGUgcmVsYXRpb25zaGlwXG4gKiBiZXR3ZWVuIHRoZSByZXN1bHQgY29vcmRzIGFuZCB0aGUgcGFyYW1ldGVycyBgZWxgIGFuZCBgY2FsY3VsYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IFtlXSBTZWUgYGdldE5hdGl2ZUV2ZW50YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbGN1bGF0ZT1mYWxzZV0gV2hldGhlciB0byBmb3JjZSBjYWxjdWxhdGVcbiAqICAgICAgICB0aGUgY29vcmRpbmF0ZXMgYnV0IG5vdCB1c2Ugb25lcyBwcm92aWRlZCBieSBicm93c2VyLlxuICogQHJldHVybiB7VUlFdmVudH0gVGhlIG5vcm1hbGl6ZWQgbmF0aXZlIFVJRXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG4gIGUgPSBnZXROYXRpdmVFdmVudChlKTtcblxuICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICBpZiAoIWlzVG91Y2gpIHtcbiAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgIGUuenJEZWx0YSA9IGUud2hlZWxEZWx0YSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICB9IGVsc2Uge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPT0gJ3RvdWNoZW5kJyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gIH0gLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpdCBtYXkgYmUgcmVhZG9ubHksXG4gIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcblxuXG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcblxuICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICBlLndoaWNoID0gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IGJ1dHRvbiAmIDQgPyAyIDogMDtcbiAgfSAvLyBbQ2F1dGlvbl06IGBlLndoaWNoYCBmcm9tIGJyb3dzZXIgaXMgbm90IGFsd2F5cyByZWxpYWJsZS4gRm9yIGV4YW1wbGUsXG4gIC8vIHdoZW4gcHJlc3MgbGVmdCBidXR0b24gYW5kIGBtb3VzZW1vdmUgKHBvaW50ZXJtb3ZlKWAgaW4gRWRnZSwgdGhlIGBlLndoaWNoYFxuICAvLyBpcyA2NTUzNiBhbmQgdGhlIGBlLmJ1dHRvbmAgaXMgLTEuIEJ1dCB0aGUgYG1vdXNldXAgKHBvaW50ZXJ1cClgIGFuZFxuICAvLyBgbW91c2Vkb3duIChwb2ludGVyZG93bilgIGlzIHRoZSBzYW1lIGFzIENocm9tZSBkb2VzLlxuXG5cbiAgcmV0dXJuIGU7XG59XG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gb3B0IElmIGJvb2xlYW4sIG1lYW5zIGBvcHQuY2FwdHVyZWBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5jYXB0dXJlPWZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LnBhc3NpdmU9ZmFsc2VdXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyLCBvcHQpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgLy8gUmVwcm9kdWN0IHRoZSBjb25zb2xlIHdhcm5pbmc6XG4gICAgLy8gW1Zpb2xhdGlvbl0gQWRkZWQgbm9uLXBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgdG8gYSBzY3JvbGwtYmxvY2tpbmcgPHNvbWU+IGV2ZW50LlxuICAgIC8vIENvbnNpZGVyIG1hcmtpbmcgZXZlbnQgaGFuZGxlciBhcyAncGFzc2l2ZScgdG8gbWFrZSB0aGUgcGFnZSBtb3JlIHJlc3BvbnNpdmUuXG4gICAgLy8gSnVzdCBzZXQgY29uc29sZSBsb2cgbGV2ZWw6IHZlcmJvc2UgaW4gY2hyb21lIGRldiB0b29sLlxuICAgIC8vIHRoZW4gdGhlIHdhcm5pbmcgbG9nIHdpbGwgYmUgcHJpbnRlZCB3aGVuIGFkZEV2ZW50TGlzdGVuZXIgY2FsbGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZFxuICAgIC8vIFdlIGhhdmUgbm90IHlldCBmb3VuZCBhIG5lYXQgd2F5IHRvIHVzaW5nIHBhc3NpdmUuIEJlY2F1c2UgaW4genJlbmRlciB0aGUgZG9tIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgZGVsZWdhdGUgYWxsIG9mIHRoZSB1cHBlciBldmVudHMgb2YgZWxlbWVudC4gU29tZSBvZiB0aG9zZSBldmVudHMgbmVlZFxuICAgIC8vIHRvIHByZXZlbnQgZGVmYXVsdC4gRm9yIGV4YW1wbGUsIHRoZSBmZWF0dXJlIGBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZWAgb2YgZWNoYXJ0cy5cbiAgICAvLyBCZWZvcmUgcGFzc2l2ZSBjYW4gYmUgYWRvcHRlZCwgdGhlc2UgaXNzdWVzIHNob3VsZCBiZSBjb25zaWRlcmVkOlxuICAgIC8vICgxKSBXaGV0aGVyIGFuZCBob3cgYSB6cmVuZGVyIHVzZXIgc3BlY2lmaWVzIGFuIGV2ZW50IGxpc3RlbmVyIHBhc3NpdmUuIEFuZCBieSBkZWZhdWx0LFxuICAgIC8vIHBhc3NpdmUgb3Igbm90LlxuICAgIC8vICgyKSBIb3cgdG8gdHJlYWQgdGhhdCBzb21lIHpyZW5kZXIgZXZlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZSwgYW5kIHNvbWUgaXMgbm90LiBJZlxuICAgIC8vIHdlIHVzZSBvdGhlciB3YXkgYnV0IG5vdCBwcmV2ZW50RGVmYXVsdCBvZiBtb3VzZXdoZWVsIGFuZCB0b3VjaG1vdmUsIGJyb3dzZXJcbiAgICAvLyBjb21wYXRpYmlsaXR5IHNob3VsZCBiZSBoYW5kbGVkLlxuICAgIC8vIHZhciBvcHRzID0gKGVudi5wYXNzaXZlU3VwcG9ydGVkICYmIG5hbWUgPT09ICdtb3VzZXdoZWVsJylcbiAgICAvLyAgICAgPyB7cGFzc2l2ZTogdHJ1ZX1cbiAgICAvLyAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRoaXJkIHBhcmFtIG9mIGVsLmFkZEV2ZW50TGlzdGVuZXIgaXMgYGNhcHR1cmU6IGZhbHNlYC5cbiAgICAvLyAgICAgOiB2b2lkIDA7XG4gICAgLy8gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyIC8qICwgb3B0cyAqLyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBvcHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCBkbyBub3QgaW1wbGVtZW50IGBzZXRDYXB0dXJlYCBmb3IgSUU5LS5cbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cbi8qKlxuICogUGFyYW1ldGVyIGFyZSB0aGUgc2FtZSBhcyBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogTm90aWNlIHRoYXQgaWYgYSBsaXN0ZW5lciBpcyByZWdpc3RlcmVkIHR3aWNlLCBvbmUgd2l0aCBjYXB0dXJlIGFuZCBvbmUgd2l0aG91dCxcbiAqIHJlbW92ZSBlYWNoIG9uZSBzZXBhcmF0ZWx5LiBSZW1vdmFsIG9mIGEgY2FwdHVyaW5nIGxpc3RlbmVyIGRvZXMgbm90IGFmZmVjdCBhXG4gKiBub24tY2FwdHVyaW5nIHZlcnNpb24gb2YgdGhlIHNhbWUgbGlzdGVuZXIsIGFuZCB2aWNlIHZlcnNhLlxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlciwgb3B0KSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgb3B0KTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cbi8qKlxuICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAqIE5vdGljZTogZG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpbiB6cmVuZGVyLiBJdCBjYW4gb25seSBiZVxuICogdXNlZCBieSB1cHBlciBhcHBsaWNhdGlvbnMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAqL1xuXG5cbnZhciBzdG9wID0gaXNEb21MZXZlbDIgPyBmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn0gOiBmdW5jdGlvbiAoZSkge1xuICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIG9ubHkgd29ya3MgZm9yIG1vdXNldXAgYW5kIG1vdXNlZG93bi4gVGhlIGZ1bmN0aW9uYWxpdHkgaXMgcmVzdHJpY3RlZFxuICogZm9yIGZhdWx0IHRvbGVyYW5jZSwgU2VlIHRoZSBgZS53aGljaGAgY29tcGF0aWJpbGl0eSBhYm92ZS5cbiAqXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNNaWRkbGVPclJpZ2h0QnV0dG9uT25Nb3VzZVVwRG93bihlKSB7XG4gIHJldHVybiBlLndoaWNoID09PSAyIHx8IGUud2hpY2ggPT09IDM7XG59XG4vKipcbiAqIFRvIGJlIHJlbW92ZWQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxuZnVuY3Rpb24gbm90TGVmdE1vdXNlKGUpIHtcbiAgLy8gSWYgZS53aGljaCBpcyB1bmRlZmluZWQsIGNvbnNpZGVyZWQgYXMgbGVmdCBtb3VzZSBldmVudC5cbiAgcmV0dXJuIGUud2hpY2ggPiAxO1xufSAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5cbmV4cG9ydHMuY2xpZW50VG9Mb2NhbCA9IGNsaWVudFRvTG9jYWw7XG5leHBvcnRzLmdldE5hdGl2ZUV2ZW50ID0gZ2V0TmF0aXZlRXZlbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZUV2ZW50ID0gbm9ybWFsaXplRXZlbnQ7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMuc3RvcCA9IHN0b3A7XG5leHBvcnRzLmlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24gPSBpc01pZGRsZU9yUmlnaHRCdXR0b25Pbk1vdXNlVXBEb3duO1xuZXhwb3J0cy5ub3RMZWZ0TW91c2UgPSBub3RMZWZ0TW91c2U7IiwiLyoqXG4gKiBUaGUgYWxnb3JpdG0gaXMgbGVhcm50IGZyb21cbiAqIGh0dHBzOi8vZnJhbmtsaW50YS5jb20vMjAxNC8wOS8wOC9jb21wdXRpbmctY3NzLW1hdHJpeDNkLXRyYW5zZm9ybXMvXG4gKiBBbmQgd2UgbWFkZSBzb21lIG9wdGltaXphdGlvbiBmb3IgbWF0cml4IGludmVyc2lvbi5cbiAqIE90aGVyIHNpbWlsYXIgYXBwcm9hY2hlczpcbiAqIFwiY3Y6OmdldFBlcnNwZWN0aXZlVHJhbnNmb3JtXCIsIFwiRGlyZWN0IExpbmVhciBUcmFuc2Zvcm1hdGlvblwiLlxuICovXG52YXIgTE4yID0gTWF0aC5sb2coMik7XG5cbmZ1bmN0aW9uIGRldGVybWluYW50KHJvd3MsIHJhbmssIHJvd1N0YXJ0LCByb3dNYXNrLCBjb2xNYXNrLCBkZXRDYWNoZSkge1xuICB2YXIgY2FjaGVLZXkgPSByb3dNYXNrICsgJy0nICsgY29sTWFzaztcbiAgdmFyIGZ1bGxSYW5rID0gcm93cy5sZW5ndGg7XG5cbiAgaWYgKGRldENhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBkZXRDYWNoZVtjYWNoZUtleV07XG4gIH1cblxuICBpZiAocmFuayA9PT0gMSkge1xuICAgIC8vIEluIHRoaXMgY2FzZSB0aGUgY29sTWFzayBtdXN0IGJlIGxpa2U6IGAxMTEwMTExMWAuIFdlIGNhbiBmaW5kIHRoZSBwbGFjZSBvZiBgMGAuXG4gICAgdmFyIGNvbFN0YXJ0ID0gTWF0aC5yb3VuZChNYXRoLmxvZygoMSA8PCBmdWxsUmFuaykgLSAxICYgfmNvbE1hc2spIC8gTE4yKTtcbiAgICByZXR1cm4gcm93c1tyb3dTdGFydF1bY29sU3RhcnRdO1xuICB9XG5cbiAgdmFyIHN1YlJvd01hc2sgPSByb3dNYXNrIHwgMSA8PCByb3dTdGFydDtcbiAgdmFyIHN1YlJvd1N0YXJ0ID0gcm93U3RhcnQgKyAxO1xuXG4gIHdoaWxlIChyb3dNYXNrICYgMSA8PCBzdWJSb3dTdGFydCkge1xuICAgIHN1YlJvd1N0YXJ0Kys7XG4gIH1cblxuICB2YXIgc3VtID0gMDtcblxuICBmb3IgKHZhciBqID0gMCwgY29sTG9jYWxJZHggPSAwOyBqIDwgZnVsbFJhbms7IGorKykge1xuICAgIHZhciBjb2xUYWcgPSAxIDw8IGo7XG5cbiAgICBpZiAoIShjb2xUYWcgJiBjb2xNYXNrKSkge1xuICAgICAgc3VtICs9IChjb2xMb2NhbElkeCAlIDIgPyAtMSA6IDEpICogcm93c1tyb3dTdGFydF1bal0gLy8gZGV0KHN1Yk1hdHJpeCgwLCBqKSlcbiAgICAgICogZGV0ZXJtaW5hbnQocm93cywgcmFuayAtIDEsIHN1YlJvd1N0YXJ0LCBzdWJSb3dNYXNrLCBjb2xNYXNrIHwgY29sVGFnLCBkZXRDYWNoZSk7XG4gICAgICBjb2xMb2NhbElkeCsrO1xuICAgIH1cbiAgfVxuXG4gIGRldENhY2hlW2NhY2hlS2V5XSA9IHN1bTtcbiAgcmV0dXJuIHN1bTtcbn1cbi8qKlxuICogVXNhZ2U6XG4gKiBgYGBqc1xuICogdmFyIHRyYW5zZm9ybWVyID0gYnVpbGRUcmFuc2Zvcm1lcihcbiAqICAgICBbMTAsIDQ0LCAxMDAsIDQ0LCAxMDAsIDMwMCwgMTAsIDMwMF0sXG4gKiAgICAgWzUwLCA1NCwgMTMwLCAxNCwgMTQwLCAzMzAsIDE0LCAyMjBdXG4gKiApO1xuICogdmFyIG91dCA9IFtdO1xuICogdHJhbnNmb3JtZXIgJiYgdHJhbnNmb3JtZXIoWzExLCAzM10sIG91dCk7XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2U6IGBidWlsZFRyYW5zZm9ybWVyYCBtYXkgdGFrZSBtb3JlIHRoYW4gMTBtcyBpbiBzb21lIEFuZHJvaWQgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNyYyBzb3VyY2UgZm91ciBwb2ludHMsIFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTNdXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkZXN0IGRlc3RpbmF0aW9uIGZvdXIgcG9pbnRzLCBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzXVxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zZm9ybWVyIElmIGZhaWwsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtZXIoc3JjLCBkZXN0KSB7XG4gIHZhciBtQSA9IFtbc3JjWzBdLCBzcmNbMV0sIDEsIDAsIDAsIDAsIC1kZXN0WzBdICogc3JjWzBdLCAtZGVzdFswXSAqIHNyY1sxXV0sIFswLCAwLCAwLCBzcmNbMF0sIHNyY1sxXSwgMSwgLWRlc3RbMV0gKiBzcmNbMF0sIC1kZXN0WzFdICogc3JjWzFdXSwgW3NyY1syXSwgc3JjWzNdLCAxLCAwLCAwLCAwLCAtZGVzdFsyXSAqIHNyY1syXSwgLWRlc3RbMl0gKiBzcmNbM11dLCBbMCwgMCwgMCwgc3JjWzJdLCBzcmNbM10sIDEsIC1kZXN0WzNdICogc3JjWzJdLCAtZGVzdFszXSAqIHNyY1szXV0sIFtzcmNbNF0sIHNyY1s1XSwgMSwgMCwgMCwgMCwgLWRlc3RbNF0gKiBzcmNbNF0sIC1kZXN0WzRdICogc3JjWzVdXSwgWzAsIDAsIDAsIHNyY1s0XSwgc3JjWzVdLCAxLCAtZGVzdFs1XSAqIHNyY1s0XSwgLWRlc3RbNV0gKiBzcmNbNV1dLCBbc3JjWzZdLCBzcmNbN10sIDEsIDAsIDAsIDAsIC1kZXN0WzZdICogc3JjWzZdLCAtZGVzdFs2XSAqIHNyY1s3XV0sIFswLCAwLCAwLCBzcmNbNl0sIHNyY1s3XSwgMSwgLWRlc3RbN10gKiBzcmNbNl0sIC1kZXN0WzddICogc3JjWzddXV07XG4gIHZhciBkZXRDYWNoZSA9IHt9O1xuICB2YXIgZGV0ID0gZGV0ZXJtaW5hbnQobUEsIDgsIDAsIDAsIDAsIGRldENhY2hlKTtcblxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgLy8gY2FuIG5vdCBtYWtlIHRyYW5zZm9ybWVyIHdoZW4gYW5kIG9ubHkgd2hlblxuICAgIC8vIGFueSB0aHJlZSBvZiB0aGUgbWFya2VycyBhcmUgY29sbGluZWFyLlxuICAgIHJldHVybjtcbiAgfSAvLyBgaW52ZXJ0KG1BKSAqIGRlc3RgLCB0aGF0IGlzLCBgYWRqKG1BKSAvIGRldCAqIGRlc3RgLlxuXG5cbiAgdmFyIHZoID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgdmhbal0gPT0gbnVsbCAmJiAodmhbal0gPSAwKTtcbiAgICAgIHZoW2pdICs9ICgoaSArIGopICUgMiA/IC0xIDogMSkgKiAvLyBkZXQoc3ViTWF0cml4KGksIGopKVxuICAgICAgZGV0ZXJtaW5hbnQobUEsIDcsIGkgPT09IDAgPyAxIDogMCwgMSA8PCBpLCAxIDw8IGosIGRldENhY2hlKSAvIGRldCAqIGRlc3RbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIHNyY1BvaW50WCwgc3JjUG9pbnRZKSB7XG4gICAgdmFyIHBrID0gc3JjUG9pbnRYICogdmhbNl0gKyBzcmNQb2ludFkgKiB2aFs3XSArIDE7XG4gICAgb3V0WzBdID0gKHNyY1BvaW50WCAqIHZoWzBdICsgc3JjUG9pbnRZICogdmhbMV0gKyB2aFsyXSkgLyBwaztcbiAgICBvdXRbMV0gPSAoc3JjUG9pbnRYICogdmhbM10gKyBzcmNQb2ludFkgKiB2aFs0XSArIHZoWzVdKSAvIHBrO1xuICB9O1xufVxuXG5leHBvcnRzLmJ1aWxkVHJhbnNmb3JtZXIgPSBidWlsZFRyYW5zZm9ybWVyOyIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cbnZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG5mdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIGlkU3RhcnQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkZWJ1Z01vZGUgPSBfY29uZmlnLmRlYnVnTW9kZTtcblxudmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChkZWJ1Z01vZGUgPT09IDEpIHtcbiAgbG9nRXJyb3IgPSBjb25zb2xlLmVycm9yO1xufVxuXG52YXIgX2RlZmF1bHQgPSBsb2dFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwiLyoqXG4gKiAzeDLnn6npmLXmk43kvZznsbtcbiAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAqL1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICogQ3JlYXRlIGEgaWRlbnRpdHkgbWF0cml4LlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gIGlkZW50aXR5KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBtKSB7XG4gIG91dFswXSA9IG1bMF07XG4gIG91dFsxXSA9IG1bMV07XG4gIG91dFsyXSA9IG1bMl07XG4gIG91dFszXSA9IG1bM107XG4gIG91dFs0XSA9IG1bNF07XG4gIG91dFs1XSA9IG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteebuOS5mFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bChvdXQsIG0xLCBtMikge1xuICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSBvdXQzO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlubPnp7vlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaXi+i9rOWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOe8qeaUvuWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHZ4ID0gdlswXTtcbiAgdmFyIHZ5ID0gdlsxXTtcbiAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICBvdXRbMV0gPSBhWzFdICogdnk7XG4gIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICBvdXRbNF0gPSBhWzRdICogdng7XG4gIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC6YCG55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2xvbmUgYSBuZXcgbWF0cml4LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIGIgPSBjcmVhdGUoKTtcbiAgY29weShiLCBhKTtcbiAgcmV0dXJuIGI7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9temljY2FyZC9ub2RlLXRpbXNvcnRcbnZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xudmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG52YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG5cbmZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gIHZhciByID0gMDtcblxuICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHIgfD0gbiAmIDE7XG4gICAgbiA+Pj0gMTtcbiAgfVxuXG4gIHJldHVybiBuICsgcjtcbn1cblxuZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gIHZhciBydW5IaSA9IGxvICsgMTtcblxuICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cblxuICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ1bkhpIC0gbG87XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICBoaS0tO1xuXG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgYXJyYXlbaGktLV0gPSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcbiAgICB2YXIgbGVmdCA9IGxvO1xuICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgIHZhciBtaWQ7XG5cbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgdmFyIG9mZnNldCA9IDE7XG5cbiAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfVxuXG4gIGxhc3RPZmZzZXQrKztcblxuICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gIHZhciBtaW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgdG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICB2YXIgc3RhY2tMZW5ndGggPSAwO1xuICB2YXIgcnVuU3RhcnQ7XG4gIHZhciBydW5MZW5ndGg7XG4gIHZhciBzdGFja1NpemUgPSAwO1xuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gIH1cblxuICB2YXIgdG1wID0gW107XG4gIHN0YWNrTGVuZ3RoID0gbGVuZ3RoIDwgMTIwID8gNSA6IGxlbmd0aCA8IDE1NDIgPyAxMCA6IGxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG4gIHJ1blN0YXJ0ID0gW107XG4gIHJ1bkxlbmd0aCA9IFtdO1xuXG4gIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICBydW5MZW5ndGhbc3RhY2tTaXplXSA9IF9ydW5MZW5ndGg7XG4gICAgc3RhY2tTaXplICs9IDE7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPj0gMSAmJiBydW5MZW5ndGhbbiAtIDFdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHJ1bkxlbmd0aFtuIC0gMl0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICBpZiAocnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgbi0tO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcbiAgICBydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICBydW5TdGFydFtpICsgMV0gPSBydW5TdGFydFtpICsgMl07XG4gICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICB9XG5cbiAgICBzdGFja1NpemUtLTtcbiAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgIHN0YXJ0MSArPSBrO1xuICAgIGxlbmd0aDEgLT0gaztcblxuICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcbiAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgIHZhciBjb3VudDE7XG4gICAgdmFyIGNvdW50MjtcbiAgICB2YXIgZXhpdDtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb3VudDEgPSAwO1xuICAgICAgY291bnQyID0gMDtcbiAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcblxuICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG4gICAgbWluR2FsbG9wIDwgMSAmJiAobWluR2FsbG9wID0gMSk7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG4gICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICBtaW5HYWxsb3AgPSAxO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xufVxuXG5mdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgaWYgKCFsbykge1xuICAgIGxvID0gMDtcbiAgfVxuXG4gIGlmICghaGkpIHtcbiAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG4gIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICBkbyB7XG4gICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcblxuICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcblxuICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgfVxuXG4gICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgfVxuXG4gICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICB0cy5tZXJnZVJ1bnMoKTtcbiAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICB0cy5mb3JjZU1lcmdlUnVucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7IiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cbi8vIOeUqOS6juWkhOeQhm1lcmdl5pe25peg5rOV6YGN5Y6GRGF0ZeetieWvueixoeeahOmXrumimFxudmFyIEJVSUxUSU5fT0JKRUNUID0ge1xuICAnW29iamVjdCBGdW5jdGlvbl0nOiAxLFxuICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgJ1tvYmplY3QgRGF0ZV0nOiAxLFxuICAnW29iamVjdCBFcnJvcl0nOiAxLFxuICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxLFxuICAnW29iamVjdCBDYW52YXNQYXR0ZXJuXSc6IDEsXG4gIC8vIEZvciBub2RlLWNhbnZhc1xuICAnW29iamVjdCBJbWFnZV0nOiAxLFxuICAnW29iamVjdCBDYW52YXNdJzogMVxufTtcbnZhciBUWVBFRF9BUlJBWSA9IHtcbiAgJ1tvYmplY3QgSW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MTZBcnJheV0nOiAxLFxuICAnW29iamVjdCBJbnQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogMVxufTtcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBuYXRpdmVGb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xudmFyIG5hdGl2ZUZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xudmFyIG5hdGl2ZVNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbnZhciBuYXRpdmVNYXAgPSBhcnJheVByb3RvLm1hcDtcbnZhciBuYXRpdmVSZWR1Y2UgPSBhcnJheVByb3RvLnJlZHVjZTsgLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxudmFyIG1ldGhvZHMgPSB7fTtcblxuZnVuY3Rpb24gJG92ZXJyaWRlKG5hbWUsIGZuKSB7XG4gIC8vIENsZWFyIGN0eCBpbnN0YW5jZSBmb3IgZGlmZmVyZW50IGVudmlyb25tZW50XG4gIGlmIChuYW1lID09PSAnY3JlYXRlQ2FudmFzJykge1xuICAgIF9jdHggPSBudWxsO1xuICB9XG5cbiAgbWV0aG9kc1tuYW1lXSA9IGZuO1xufVxuLyoqXG4gKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICogICAgIEJVSUxUSU5fT0JKRUNUXG4gKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAqXG4gKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHJldHVybiB7Kn0gbmV3XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzb3VyY2U7XG4gIHZhciB0eXBlU3RyID0gb2JqVG9TdHJpbmcuY2FsbChzb3VyY2UpO1xuXG4gIGlmICh0eXBlU3RyID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShzb3VyY2UpKSB7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWVt0eXBlU3RyXSkge1xuICAgIGlmICghaXNQcmltaXRpdmUoc291cmNlKSkge1xuICAgICAgdmFyIEN0b3IgPSBzb3VyY2UuY29uc3RydWN0b3I7XG5cbiAgICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgICByZXN1bHQgPSBDdG9yLmZyb20oc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgaWYgKGNsYXp6UHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICovXG5cblxuZnVuY3Rpb24gZWFjaChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChjYiwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICog5pWw57uE5pig5bCEXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBtYXAob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5tYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoY2IsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWVtb11cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZHVjZShvYmosIGNiLCBtZW1vLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLnJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICByZXR1cm4gb2JqLnJlZHVjZShjYiwgbWVtbywgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWVtbyA9IGNiLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9XG59XG4vKipcbiAqIOaVsOe7hOi/h+a7pFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gZmlsdGVyKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikge1xuICAgIHJldHVybiBvYmouZmlsdGVyKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4vKipcbiAqIOaVsOe7hOmhueafpeaJvlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgIHJldHVybiBvYmpbaV07XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gY3VycnkoZnVuYykge1xuICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgISF2YWx1ZSAmJiB0eXBlID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuICEhVFlQRURfQVJSQVlbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIFdoZXRoZXIgaXMgZXhhY3RseSBOYU4uIE5vdGljZSBpc05hTignYScpIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBlcU5hTih2YWx1ZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlICovXG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGJlIHRyaW1lZFxuICogQHJldHVybiB7c3RyaW5nfSB0cmltZWQgc3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICBpZiAoc3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyLnRyaW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gIH1cbn1cblxudmFyIHByaW1pdGl2ZUtleSA9ICdfX2VjX3ByaW1pdGl2ZV9fJztcbi8qKlxuICogU2V0IGFuIG9iamVjdCBhcyBwcmltaXRpdmUgdG8gYmUgaWdub3JlZCB0cmF2ZXJzaW5nIGNoaWxkcmVuIGluIGNsb25lIG9yIG1lcmdlXG4gKi9cblxuZnVuY3Rpb24gc2V0QXNQcmltaXRpdmUob2JqKSB7XG4gIG9ialtwcmltaXRpdmVLZXldID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gIHJldHVybiBvYmpbcHJpbWl0aXZlS2V5XTtcbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9ubHkgYXBwbHkgYG93blByb3BlcnR5YC5cbiAqL1xuXG5cbmZ1bmN0aW9uIEhhc2hNYXAob2JqKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTsgLy8gS2V5IHNob3VsZCBub3QgYmUgc2V0IG9uIHRoaXMsIG90aGVyd2lzZVxuICAvLyBtZXRob2RzIGdldC9zZXQvLi4uIG1heSBiZSBvdmVycmlkZWQuXG5cbiAgdGhpcy5kYXRhID0ge307XG4gIHZhciB0aGlzTWFwID0gdGhpcztcbiAgb2JqIGluc3RhbmNlb2YgSGFzaE1hcCA/IG9iai5lYWNoKHZpc2l0KSA6IG9iaiAmJiBlYWNoKG9iaiwgdmlzaXQpO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KHZhbHVlLCBrZXkpIHtcbiAgICBpc0FyciA/IHRoaXNNYXAuc2V0KHZhbHVlLCBrZXkpIDogdGhpc01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSA/IHRoaXMuZGF0YVtrZXldIDogbnVsbDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG4gIH0sXG4gIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAvLyBzaG91bGQgbm90IHVzZSB0aGUgZXhwb3NlZCBrZXlzLCB3aG8gYXJlIHByZWZpeGVkLlxuICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhLmhhc093blByb3BlcnR5KGtleSkgJiYgY2IodGhpcy5kYXRhW2tleV0sIGtleSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXG5cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlSGFzaE1hcChvYmopIHtcbiAgcmV0dXJuIG5ldyBIYXNoTWFwKG9iaik7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEFycmF5KGEsIGIpIHtcbiAgdmFyIG5ld0FycmF5ID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyYXlbaV0gPSBhW2ldO1xuICB9XG5cbiAgdmFyIG9mZnNldCA9IGEubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyYXlbaSArIG9mZnNldF0gPSBiW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5leHBvcnRzLmlzRG9tID0gaXNEb207XG5leHBvcnRzLmVxTmFOID0gZXFOYU47XG5leHBvcnRzLnJldHJpZXZlID0gcmV0cmlldmU7XG5leHBvcnRzLnJldHJpZXZlMiA9IHJldHJpZXZlMjtcbmV4cG9ydHMucmV0cmlldmUzID0gcmV0cmlldmUzO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy5ub3JtYWxpemVDc3NBcnJheSA9IG5vcm1hbGl6ZUNzc0FycmF5O1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLnRyaW0gPSB0cmltO1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMuY29uY2F0QXJyYXkgPSBjb25jYXRBcnJheTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7IiwiLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xudmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG5cbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZSh2KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgdjEsIHYyLCBhKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mVv+W6plxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBsZW4odikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGxlblNxdWFyZSh2KSk7XG59XG5cbnZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuU3F1YXJlKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG59XG5cbnZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG4vKipcbiAqIOWQkemHj+S5mOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5mdW5jdGlvbiBtdWwob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+eCueS5mFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICBvdXRbMF0gPSB2WzBdICogcztcbiAgb3V0WzFdID0gdlsxXSAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+W9kuS4gOWMllxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgdikge1xuICB2YXIgZCA9IGxlbih2KTtcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pKTtcbn1cblxudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICog5ZCR6YeP6Led56a75bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmUodjEsIHYyKSB7XG4gIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5cbnZhciBkaXN0U3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG4vKipcbiAqIOaxgui0n+WQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgb3V0WzBdID0gLXZbMF07XG4gIG91dFsxXSA9IC12WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmj5LlgLzkuKTkuKrngrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIHYxLCB2MiwgdCkge1xuICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi15bem5LmY5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKG91dCwgdiwgbSkge1xuICB2YXIgeCA9IHZbMF07XG4gIHZhciB5ID0gdlsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMubGVuID0gbGVuO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmxlblNxdWFyZSA9IGxlblNxdWFyZTtcbmV4cG9ydHMubGVuZ3RoU3F1YXJlID0gbGVuZ3RoU3F1YXJlO1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLmRpdiA9IGRpdjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3QgPSBkaXN0O1xuZXhwb3J0cy5kaXN0YW5jZVNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuZXhwb3J0cy5kaXN0U3F1YXJlID0gZGlzdFNxdWFyZTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7IiwidmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5hZGRFdmVudExpc3RlbmVyO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBfZXZlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbnZhciBub3JtYWxpemVFdmVudCA9IF9ldmVudC5ub3JtYWxpemVFdmVudDtcbnZhciBnZXROYXRpdmVFdmVudCA9IF9ldmVudC5nZXROYXRpdmVFdmVudDtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxuLyogZ2xvYmFsIGRvY3VtZW50ICovXG52YXIgVE9VQ0hfQ0xJQ0tfREVMQVkgPSAzMDA7XG52YXIgZ2xvYmFsRXZlbnRTdXBwb3J0ZWQgPSBlbnYuZG9tU3VwcG9ydGVkO1xuXG52YXIgbG9jYWxOYXRpdmVMaXN0ZW5lck5hbWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbW91c2VIYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4gIHZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnXTtcbiAgdmFyIHBvaW50ZXJFdmVudE5hbWVNYXAgPSB7XG4gICAgcG9pbnRlcmRvd246IDEsXG4gICAgcG9pbnRlcnVwOiAxLFxuICAgIHBvaW50ZXJtb3ZlOiAxLFxuICAgIHBvaW50ZXJvdXQ6IDFcbiAgfTtcbiAgdmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSB6clV0aWwubWFwKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgIHJldHVybiBwb2ludGVyRXZlbnROYW1lTWFwLmhhc093blByb3BlcnR5KG5tKSA/IG5tIDogbmFtZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbW91c2U6IG1vdXNlSGFuZGxlck5hbWVzLFxuICAgIHRvdWNoOiB0b3VjaEhhbmRsZXJOYW1lcyxcbiAgICBwb2ludGVyOiBwb2ludGVySGFuZGxlck5hbWVzXG4gIH07XG59KCk7XG5cbnZhciBnbG9iYWxOYXRpdmVMaXN0ZW5lck5hbWVzID0ge1xuICBtb3VzZTogWydtb3VzZW1vdmUnLCAnbW91c2V1cCddLFxuICBwb2ludGVyOiBbJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCddXG59O1xuXG5mdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ21vdXNld2hlZWwnICYmIGVudi5icm93c2VyLmZpcmVmb3ggPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gIHZhciBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICByZXR1cm4gcG9pbnRlclR5cGUgPT09ICdwZW4nIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufSAvLyBmdW5jdGlvbiB1c2VNU0d1ZXN0dXJlKGhhbmRsZXJQcm94eSwgZXZlbnQpIHtcbi8vICAgICByZXR1cm4gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSAmJiAhIWhhbmRsZXJQcm94eS5fbXNHZXN0dXJlO1xuLy8gfVxuLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4vLyAgICAgaWYgKGV2ZW50LnRyYW5zbGF0aW9uWCB8fCBldmVudC50cmFuc2xhdGlvblkpIHtcbi8vICAgICAgICAgLy8gbW91c2Vtb3ZlIGlzIGNhcnJpZWQgYnkgTVNHZXN0dXJlIHRvIHJlZHVjZSB0aGUgc2Vuc2l0aXZpdHkuXG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vICAgICBpZiAoZXZlbnQuc2NhbGUgIT09IDEpIHtcbi8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbi8vICAgICAgICAgZXZlbnQucGluY2hZID0gZXZlbnQub2Zmc2V0WTtcbi8vICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IGV2ZW50LnNjYWxlO1xuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vIH1cblxuLyoqXG4gKiBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAqIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUhhbmRsZXJTY29wZX0gc2NvcGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRvdWNoVGltZXIoc2NvcGUpIHtcbiAgc2NvcGUudG91Y2hpbmcgPSB0cnVlO1xuXG4gIGlmIChzY29wZS50b3VjaFRpbWVyICE9IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQoc2NvcGUudG91Y2hUaW1lcik7XG4gICAgc2NvcGUudG91Y2hUaW1lciA9IG51bGw7XG4gIH1cblxuICBzY29wZS50b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2NvcGUudG91Y2hpbmcgPSBmYWxzZTtcbiAgICBzY29wZS50b3VjaFRpbWVyID0gbnVsbDtcbiAgfSwgNzAwKTtcbn0gLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cblxuZnVuY3Rpb24gbWFya1RvdWNoKGV2ZW50KSB7XG4gIGV2ZW50ICYmIChldmVudC56ckJ5VG91Y2ggPSB0cnVlKTtcbn0gLy8gZnVuY3Rpb24gbWFya1RyaWdnZXJlZEZyb21Mb2NhbChldmVudCkge1xuLy8gICAgIGV2ZW50ICYmIChldmVudC5fX3pySXNGcm9tTG9jYWwgPSB0cnVlKTtcbi8vIH1cbi8vIGZ1bmN0aW9uIGlzVHJpZ2dlcmVkRnJvbUxvY2FsKGluc3RhbmNlLCBldmVudCkge1xuLy8gICAgIHJldHVybiAhIShldmVudCAmJiBldmVudC5fX3pySXNGcm9tTG9jYWwpO1xuLy8gfVxuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUdsb2JhbEV2ZW50KGluc3RhbmNlLCBldmVudCkge1xuICAvLyBvZmZzZXRYLCBvZmZzZXRZIHN0aWxsIG5lZWQgdG8gYmUgY2FsY3VsYXRlZC4gVGhleSBhcmUgbmVjZXNzYXJ5IGluIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBvZiB0aGUgdXBwZXIgYXBwbGljYXRpb25zLiBTZXQgYHRydWVgIHRvIGZvcmNlIGNhbGN1bGF0ZSB0aGVtLlxuICByZXR1cm4gbm9ybWFsaXplRXZlbnQoaW5zdGFuY2UuZG9tLCBuZXcgRmFrZUdsb2JhbEV2ZW50KGluc3RhbmNlLCBldmVudCksIHRydWUpO1xufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgZ2l2ZW4gZWwgaXMgaW4gYHBhaW50ZXJSb290YC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTG9jYWxFbChpbnN0YW5jZSwgZWwpIHtcbiAgdmFyIGVsVG1wID0gZWw7XG4gIHZhciBpc0xvY2FsID0gZmFsc2U7XG5cbiAgd2hpbGUgKGVsVG1wICYmIGVsVG1wLm5vZGVUeXBlICE9PSA5ICYmICEoaXNMb2NhbCA9IGVsVG1wLmRvbUJlbG9uZ1RvWnIgfHwgZWxUbXAgIT09IGVsICYmIGVsVG1wID09PSBpbnN0YW5jZS5wYWludGVyUm9vdCkpIHtcbiAgICBlbFRtcCA9IGVsVG1wLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gaXNMb2NhbDtcbn1cbi8qKlxuICogTWFrZSBhIGZha2UgZXZlbnQgYnV0IG5vdCBjaGFuZ2UgdGhlIG9yaWdpbmFsIGV2ZW50LFxuICogYmVjdWFzZSB0aGUgZ2xvYmFsIGV2ZW50IHByb2JhYmx5IGJlIHVzZWQgYnkgb3RoZXJcbiAqIGxpc3RlbmVycyBub3QgYmVsb25naW5nIHRvIHpyZW5kZXIuXG4gKiBAY2xhc3NcbiAqL1xuXG5cbmZ1bmN0aW9uIEZha2VHbG9iYWxFdmVudChpbnN0YW5jZSwgZXZlbnQpIHtcbiAgdGhpcy50eXBlID0gZXZlbnQudHlwZTtcbiAgdGhpcy50YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQgPSBpbnN0YW5jZS5kb207XG4gIHRoaXMucG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTsgLy8gTmVjZXNzcmF5IGZvciB0aGUgZm9yY2UgY2FsY3VsYXRpb24gb2YgenJYLCB6cllcblxuICB0aGlzLmNsaWVudFggPSBldmVudC5jbGllbnRYO1xuICB0aGlzLmNsaWVudFkgPSBldmVudC5jbGllbnRZOyAvLyBCZWNhdXNlIHdlIGRvIG5vdCBtb3VudCBnbG9iYWwgbGlzdGVuZXJzIHRvIHRvdWNoIGV2ZW50cyxcbiAgLy8gd2UgZG8gbm90IGNvcHkgYHRhcmdldFRvdWNoZXNgIGFuZCBgY2hhbmdlZFRvdWNoZXNgIGhlcmUuXG59XG5cbnZhciBmYWtlR2xvYmFsRXZlbnRQcm90byA9IEZha2VHbG9iYWxFdmVudC5wcm90b3R5cGU7IC8vIHdlIG1ha2UgdGhlIGRlZmF1bHQgbWV0aG9kcyBvbiB0aGUgZXZlbnQgZG8gbm90aGluZyxcbi8vIG90aGVyd2lzZSBpdCBpcyBkYW5nZXJvdXMuIFNlZSBtb3JlIGRldGFpbHMgaW5cbi8vIFtEcmFnIG91dHNpZGVdIGluIGBIYW5kbGVyLmpzYC5cblxuZmFrZUdsb2JhbEV2ZW50UHJvdG8uc3RvcFByb3BhZ2F0aW9uID0gZmFrZUdsb2JhbEV2ZW50UHJvdG8uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZmFrZUdsb2JhbEV2ZW50UHJvdG8ucHJldmVudERlZmF1bHQgPSB6clV0aWwubm9vcDtcbi8qKlxuICogTG9jYWwgRE9NIEhhbmRsZXJzXG4gKiBAdGhpcyB7SGFuZGxlclByb3h5fVxuICovXG5cbnZhciBsb2NhbERPTUhhbmRsZXJzID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLl9tYXlQb2ludGVyQ2FwdHVyZSA9IFtldmVudC56clgsIGV2ZW50LnpyWV07XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZWRvd24nLCBldmVudCk7XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHZhciBkb3duUG9pbnQgPSB0aGlzLl9tYXlQb2ludGVyQ2FwdHVyZTtcblxuICAgIGlmIChkb3duUG9pbnQgJiYgKGV2ZW50LnpyWCAhPT0gZG93blBvaW50WzBdIHx8IGV2ZW50LnpyWSAhPT0gZG93blBvaW50WzFdKSkge1xuICAgICAgdG9nZ2xlUG9pbnRlckNhcHR1cmUodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0b2dnbGVQb2ludGVyQ2FwdHVyZSh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZXVwJywgZXZlbnQpO1xuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBTaW1pbGFybHkgdG8gdGhlIGJyb3dzZXIgZGlkIG9uIGBkb2N1bWVudGAgYW5kIHRvdWNoIGV2ZW50LFxuICAgIC8vIGBnbG9iYWxvdXRgIHdpbGwgYmUgZGVsYXllZCB0byBmaW5hbCBwb2ludGVyIGNhdHVyZSByZWxlYXNlLlxuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJDYXB0dXJpbmcpIHtcbiAgICAgIGV2ZW50LnpyRXZlbnRDb250cm9sID0gJ25vX2dsb2JhbG91dCc7XG4gICAgfSAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgIC8vIGF0IHRoZSBzYW1lIGxldmVsIG9mIHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkgKGUuZy4sIHRvb2x0aXBcbiAgICAvLyBkb20gY3JlYXRlZCBieSBlY2hhcnRzKSwgd2hlcmUgJ2dsb2JhbG91dCcgZXZlbnQgc2hvdWxkIG5vdFxuICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAvLyBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0IHRoZSBvcmlnaW5hbCBob3ZlcmVkIGVsZW1lbnQgYXMgdXN1YWwpLlxuXG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGV2ZW50LnpySXNUb0xvY2FsRE9NID0gaXNMb2NhbEVsKHRoaXMsIGVsZW1lbnQpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gIH0sXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIERlZmF1bHQgbW91c2UgYmVoYXZpb3VyIHNob3VsZCBub3QgYmUgZGlzYWJsZWQgaGVyZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICBtYXJrVG91Y2goZXZlbnQpO1xuICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5oYW5kbGVyLnByb2Nlc3NHZXN0dXJlKGV2ZW50LCAnc3RhcnQnKTsgLy8gRm9yIGNvbnNpc3RlbnQgZXZlbnQgbGlzdGVuZXIgZm9yIGJvdGggdG91Y2ggZGV2aWNlIGFuZCBtb3VzZSBkZXZpY2UsXG4gICAgLy8gd2Ugc2ltdWxhdGUgXCJtb3VzZW92ZXItLT5tb3VzZWRvd25cIiBpbiB0b3VjaCBkZXZpY2UuIFNvIHdlIHRyaWdnZXJcbiAgICAvLyBgbW91c2Vtb3ZlYCBoZXJlICh0byB0cmlnZ2VyIGBtb3VzZW92ZXJgIGluc2lkZSksIGFuZCB0aGVuIHRyaWdnZXJcbiAgICAvLyBgbW91c2Vkb3duYC5cblxuICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9LFxuICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICBtYXJrVG91Y2goZXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlci5wcm9jZXNzR2VzdHVyZShldmVudCwgJ2NoYW5nZScpOyAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAvLyBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cbiAgICBsb2NhbERPTUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICBtYXJrVG91Y2goZXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlci5wcm9jZXNzR2VzdHVyZShldmVudCwgJ2VuZCcpO1xuICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gRG8gbm90IHRyaWdnZXIgYG1vdXNlb3V0YCBoZXJlLCBpbiBzcGl0ZSBvZiBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgaXNcbiAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgIC8vIGJ5IGxpc3RlbmluZyB0byBgbW91c2VvdmVyYCB0byBhZGQgXCJob3ZlciBzdHlsZVwiIGFuZCBsaXN0ZW5pbmcgdG8gYG1vdXNlb3V0YFxuICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgLy8gc3R5bGVcIiB3aWxsIHJlbWFpbiBmb3IgdXNlciB2aWV3KVxuICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudC4gU3lzdGVtIGNsaWNrIGNhbiBub3QgYmUgcHJldmVudGVkLlxuXG4gICAgaWYgKCtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRvdWNoTW9tZW50IDwgVE9VQ0hfQ0xJQ0tfREVMQVkpIHtcbiAgICAgIGxvY2FsRE9NSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVyZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbG9jYWxET01IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7IC8vIGlmICh1c2VNU0d1ZXN0dXJlKHRoaXMsIGV2ZW50KSkge1xuICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgIC8vIH1cbiAgfSxcbiAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgLy8gdGFwKGNsaWNrKSBvbiB0b3VjaCBzY3JlZW4sIHdoaWNoIGFmZmVjdCBzb21lIGp1ZGdlbWVudCBpblxuICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgIC8vIGRldmljZSB5ZXQuXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBsb2NhbERPTUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbG9jYWxET01IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuICB9LFxuICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwb2ludGVyb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlblxuICAgIC8vIChJRTExKy9FZGdlIG9uIE1TIFN1cmZhY2UpIGFmdGVyIGNsaWNrIGV2ZW50IHRyaWdnZXJlZCxcbiAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgLy8gaW4gdG91Y2hlbmQuIFNvIHdlIHVuaWZ5IHRoZW0uXG4gICAgLy8gKGNoZWNrIGxvY2FsRE9NSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgbG9jYWxET01IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIE90aGVyZSBET00gVUkgRXZlbnQgaGFuZGxlcnMgZm9yIHpyIGRvbS5cbiAqIEB0aGlzIHtIYW5kbGVyUHJveHl9XG4gKi9cblxuenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGxvY2FsRE9NSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuLyoqXG4gKiBET00gVUkgRXZlbnQgaGFuZGxlcnMgZm9yIGdsb2JhbCBwYWdlLlxuICpcbiAqIFtDYXV0aW9uXTpcbiAqIHRob3NlIGhhbmRsZXJzIHNob3VsZCBib3RoIHN1cHBvcnQgaW4gY2FwdHVyZSBwaGFzZSBhbmQgYnViYmxlIHBoYXNlIVxuICpcbiAqIEB0aGlzIHtIYW5kbGVyUHJveHl9XG4gKi9cblxudmFyIGdsb2JhbERPTUhhbmRsZXJzID0ge1xuICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgLy8gdXBwZXIgYXBwbGljYXRpb24uIFNvLCB3ZSBkb250IHN1cHBvcnQgbW91c2Vtb3ZlIG9uIE1TIHRvdWNoXG4gICAgLy8gZGV2aWNlIHlldC5cbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGdsb2JhbERPTUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZ2xvYmFsRE9NSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgfSxcbiAgbW91c2V1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHBvaW50ZXJDYXB0dXJlUmVsZWFzaW5nID0gdGhpcy5fcG9pbnRlckNhcHR1cmluZztcbiAgICB0b2dnbGVQb2ludGVyQ2FwdHVyZSh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZXVwJywgZXZlbnQpO1xuXG4gICAgaWYgKHBvaW50ZXJDYXB0dXJlUmVsZWFzaW5nKSB7XG4gICAgICBldmVudC56ckV2ZW50Q29udHJvbCA9ICdvbmx5X2dsb2JhbG91dCc7XG4gICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtIYW5kbGVyUHJveHl9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0RPTUhhbmRsZXJTY29wZX0gc2NvcGVcbiAqL1xuXG5mdW5jdGlvbiBtb3VudExvY2FsRE9NRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UsIHNjb3BlKSB7XG4gIHZhciBkb21IYW5kbGVycyA9IHNjb3BlLmRvbUhhbmRsZXJzO1xuXG4gIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAvLyBJRTExKy9FZGdlIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIGV2ZW50LCBidXQgdHJpZ2dlciBwb2ludGVyIGV2ZW50IGFuZCBtb3VzZSBldmVudFxuICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgLy8gc2NyZWVuLCB3aGljaCBkbyBub3Qgb2NjdXJzIGluIHBvaW50ZXIgZXZlbnQuXG4gICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgenJVdGlsLmVhY2gobG9jYWxOYXRpdmVMaXN0ZW5lck5hbWVzLnBvaW50ZXIsIGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUpIHtcbiAgICAgIG1vdW50U2luZ2xlRE9NRXZlbnRMaXN0ZW5lcihzY29wZSwgbmF0aXZlRXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gbWFya1RyaWdnZXJlZEZyb21Mb2NhbChldmVudCk7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hdGl2ZUV2ZW50TmFtZV0uY2FsbChpbnN0YW5jZSwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIEZJWE1FXG4gICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgIC8vIHpvb21lZCBpbiBidXQgdXNlIGNhbiBub3Qgem9vbSBpdCBiYWNrKS4gQW5kIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgZG9lcyBub3Qgd29yay5cbiAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG4gICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgIC8vIFdlIGRvbnQgc3VwcG9ydCB0b3VjaCBvbiBJRSBvbiB3aW43LlxuICAgIC8vIFNlZSA8aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0Myh2PXZzLjg1KS5hc3B4PlxuICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICh0aGlzLl9tc0dlc3R1cmUgPSBuZXcgTVNHZXN0dXJlKCkpLnRhcmdldCA9IGRvbTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdNU0dlc3R1cmVDaGFuZ2UnLCBvbk1TR2VzdHVyZUNoYW5nZSk7XG4gICAgLy8gfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGxvY2FsTmF0aXZlTGlzdGVuZXJOYW1lcy50b3VjaCwgZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSkge1xuICAgICAgICBtb3VudFNpbmdsZURPTUV2ZW50TGlzdGVuZXIoc2NvcGUsIG5hdGl2ZUV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgLy8gbWFya1RyaWdnZXJlZEZyb21Mb2NhbChldmVudCk7XG4gICAgICAgICAgZG9tSGFuZGxlcnNbbmF0aXZlRXZlbnROYW1lXS5jYWxsKGluc3RhbmNlLCBldmVudCk7XG4gICAgICAgICAgc2V0VG91Y2hUaW1lcihzY29wZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW91c2VvdXQnLCB0aGlzLl9tb3VzZW91dEhhbmRsZXIpO1xuICAgIH0gLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgIC8vIG1vdXNlZXZlbnQgYWZ0ZXIgdG91Y2ggZXZlbnQgdHJpZ2dlcmVkLCBzZWUgYHNldFRvdWNoVGltZXJgLlxuXG5cbiAgICB6clV0aWwuZWFjaChsb2NhbE5hdGl2ZUxpc3RlbmVyTmFtZXMubW91c2UsIGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUpIHtcbiAgICAgIG1vdW50U2luZ2xlRE9NRXZlbnRMaXN0ZW5lcihzY29wZSwgbmF0aXZlRXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQgPSBnZXROYXRpdmVFdmVudChldmVudCk7XG5cbiAgICAgICAgaWYgKCFzY29wZS50b3VjaGluZykge1xuICAgICAgICAgIC8vIG1hcmtUcmlnZ2VyZWRGcm9tTG9jYWwoZXZlbnQpO1xuICAgICAgICAgIGRvbUhhbmRsZXJzW25hdGl2ZUV2ZW50TmFtZV0uY2FsbChpbnN0YW5jZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0hhbmRsZXJQcm94eX0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RE9NSGFuZGxlclNjb3BlfSBzY29wZVxuICovXG5cblxuZnVuY3Rpb24gbW91bnRHbG9iYWxET01FdmVudExpc3RlbmVycyhpbnN0YW5jZSwgc2NvcGUpIHtcbiAgLy8gT25seSBJRTExKy9FZGdlLiBTZWUgdGhlIGNvbW1lbnQgaW4gYG1vdW50TG9jYWxET01FdmVudExpc3RlbmVyc2AuXG4gIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIHpyVXRpbC5lYWNoKGdsb2JhbE5hdGl2ZUxpc3RlbmVyTmFtZXMucG9pbnRlciwgbW91bnQpO1xuICB9IC8vIFRvdWNoIGV2ZW50IGhhcyBpbXBsZW1lbnRlZCBcImRyYWcgb3V0c2lkZVwiIHNvIHdlIGRvIG5vdCBtb3VudCBnbG9iYWwgbGlzdGVuZXIgZm9yIHRvdWNoIGV2ZW50LlxuICAvLyAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvI3RoZS10b3VjaG1vdmUtZXZlbnQpXG4gIC8vIFdlIGRvIG5vdCBjb25zaWRlciBcImJvdGgtc3VwcG9ydC10b3VjaC1hbmQtbW91c2UgZGV2aWNlXCIgZm9yIHRoaXMgZmVhdHVyZSAoc2VlIHRoZSBjb21tZW50IG9mXG4gIC8vIGBtb3VudExvY2FsRE9NRXZlbnRMaXN0ZW5lcnNgKSB0byBhdm9pZCBidWdzIHV0aWwgc29tZSByZXF1aXJlbWVudHMgY29tZS5cbiAgZWxzZSBpZiAoIWVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgenJVdGlsLmVhY2goZ2xvYmFsTmF0aXZlTGlzdGVuZXJOYW1lcy5tb3VzZSwgbW91bnQpO1xuICAgIH1cblxuICBmdW5jdGlvbiBtb3VudChuYXRpdmVFdmVudE5hbWUpIHtcbiAgICBmdW5jdGlvbiBuYXRpdmVFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBldmVudCA9IGdldE5hdGl2ZUV2ZW50KGV2ZW50KTsgLy8gU2VlIHRoZSByZWFzb24gaW4gW0RyYWcgb3V0c2lkZV0gaW4gYEhhbmRsZXIuanNgXG4gICAgICAvLyBUaGlzIGNoZWNraW5nIHN1cHBvcnRzIGJvdGggYHVzZUNhcHR1cmVgIG9yIG5vdC5cbiAgICAgIC8vIFBFTkRJTkc6IGlmIHRoZXJlIGlzIHBlcmZvcm1hbmNlIGlzc3VlIGluIHNvbWUgZGV2aWNlcyxcbiAgICAgIC8vIHdlIHByb2JhYmx5IGNhbiBub3QgdXNlIGB1c2VDYXB0dXJlYCBhbmQgY2hhbmdlIGEgZWFzaWVyXG4gICAgICAvLyB0byBqdWRlcyB3aGV0aGVyIGxvY2FsIChtYXJrKS5cblxuICAgICAgaWYgKCFpc0xvY2FsRWwoaW5zdGFuY2UsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVHbG9iYWxFdmVudChpbnN0YW5jZSwgZXZlbnQpO1xuICAgICAgICBzY29wZS5kb21IYW5kbGVyc1tuYXRpdmVFdmVudE5hbWVdLmNhbGwoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudFNpbmdsZURPTUV2ZW50TGlzdGVuZXIoc2NvcGUsIG5hdGl2ZUV2ZW50TmFtZSwgbmF0aXZlRXZlbnRMaXN0ZW5lciwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0gLy8gU2VlIFtEcmFnIE91dHNpZGVdIGluIGBIYW5kbGVyLmpzYFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTaW5nbGVET01FdmVudExpc3RlbmVyKHNjb3BlLCBuYXRpdmVFdmVudE5hbWUsIGxpc3RlbmVyLCBvcHQpIHtcbiAgc2NvcGUubW91bnRlZFtuYXRpdmVFdmVudE5hbWVdID0gbGlzdGVuZXI7XG4gIHNjb3BlLmxpc3RlbmVyT3B0c1tuYXRpdmVFdmVudE5hbWVdID0gb3B0O1xuICBhZGRFdmVudExpc3RlbmVyKHNjb3BlLmRvbVRhcmdldCwgZXZlbnROYW1lRml4KG5hdGl2ZUV2ZW50TmFtZSksIGxpc3RlbmVyLCBvcHQpO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50RE9NRXZlbnRMaXN0ZW5lcnMoc2NvcGUpIHtcbiAgdmFyIG1vdW50ZWQgPSBzY29wZS5tb3VudGVkO1xuXG4gIGZvciAodmFyIG5hdGl2ZUV2ZW50TmFtZSBpbiBtb3VudGVkKSB7XG4gICAgaWYgKG1vdW50ZWQuaGFzT3duUHJvcGVydHkobmF0aXZlRXZlbnROYW1lKSkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY29wZS5kb21UYXJnZXQsIGV2ZW50TmFtZUZpeChuYXRpdmVFdmVudE5hbWUpLCBtb3VudGVkW25hdGl2ZUV2ZW50TmFtZV0sIHNjb3BlLmxpc3RlbmVyT3B0c1tuYXRpdmVFdmVudE5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBzY29wZS5tb3VudGVkID0ge307XG59XG4vKipcbiAqIFNlZSBbRHJhZyBPdXRzaWRlXSBpbiBgSGFuZGxlci5qc2AuXG4gKiBAaW1wbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUG9pbnRlckNhcHR1cmluZyBTaG91bGQgbmV2ZXIgYmUgYG51bGxgL2B1bmRlZmluZWRgLlxuICogICAgICAgIGB0cnVlYDogc3RhcnQgdG8gY2FwdHVyZSBwb2ludGVyIGlmIGl0IGlzIG5vdCBjYXB0dXJpbmcuXG4gKiAgICAgICAgYGZhbHNlYDogZW5kIHRoZSBjYXB0dXJlIGlmIGl0IGlzIGNhcHR1cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvZ2dsZVBvaW50ZXJDYXB0dXJlKGluc3RhbmNlLCBpc1BvaW50ZXJDYXB0dXJpbmcpIHtcbiAgaW5zdGFuY2UuX21heVBvaW50ZXJDYXB0dXJlID0gbnVsbDtcblxuICBpZiAoZ2xvYmFsRXZlbnRTdXBwb3J0ZWQgJiYgaW5zdGFuY2UuX3BvaW50ZXJDYXB0dXJpbmcgXiBpc1BvaW50ZXJDYXB0dXJpbmcpIHtcbiAgICBpbnN0YW5jZS5fcG9pbnRlckNhcHR1cmluZyA9IGlzUG9pbnRlckNhcHR1cmluZztcbiAgICB2YXIgZ2xvYmFsSGFuZGxlclNjb3BlID0gaW5zdGFuY2UuX2dsb2JhbEhhbmRsZXJTY29wZTtcbiAgICBpc1BvaW50ZXJDYXB0dXJpbmcgPyBtb3VudEdsb2JhbERPTUV2ZW50TGlzdGVuZXJzKGluc3RhbmNlLCBnbG9iYWxIYW5kbGVyU2NvcGUpIDogdW5tb3VudERPTUV2ZW50TGlzdGVuZXJzKGdsb2JhbEhhbmRsZXJTY29wZSk7XG4gIH1cbn1cbi8qKlxuICogQGlubmVyXG4gKiBAY2xhc3NcbiAqL1xuXG5cbmZ1bmN0aW9uIERPTUhhbmRsZXJTY29wZShkb21UYXJnZXQsIGRvbUhhbmRsZXJzKSB7XG4gIHRoaXMuZG9tVGFyZ2V0ID0gZG9tVGFyZ2V0O1xuICB0aGlzLmRvbUhhbmRsZXJzID0gZG9tSGFuZGxlcnM7IC8vIEtleTogZXZlbnROYW1lLCB2YWx1ZTogbW91bnRlZCBoYW5kbGVyIGZ1bmNpdG9ucy5cbiAgLy8gVXNlZCBmb3IgdW5tb3VudC5cblxuICB0aGlzLm1vdW50ZWQgPSB7fTtcbiAgdGhpcy5saXN0ZW5lck9wdHMgPSB7fTtcbiAgdGhpcy50b3VjaFRpbWVyID0gbnVsbDtcbiAgdGhpcy50b3VjaGluZyA9IGZhbHNlO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqL1xuXG5cbmZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20sIHBhaW50ZXJSb290KSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG4gIHRoaXMuX2xvY2FsSGFuZGxlclNjb3BlID0gbmV3IERPTUhhbmRsZXJTY29wZShkb20sIGxvY2FsRE9NSGFuZGxlcnMpO1xuXG4gIGlmIChnbG9iYWxFdmVudFN1cHBvcnRlZCkge1xuICAgIHRoaXMuX2dsb2JhbEhhbmRsZXJTY29wZSA9IG5ldyBET01IYW5kbGVyU2NvcGUoZG9jdW1lbnQsIGdsb2JhbERPTUhhbmRsZXJzKTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgdGhpcy5fcG9pbnRlckNhcHR1cmluZyA9IGZhbHNlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSBbeCwgeV0gb3IgbnVsbC5cbiAgICovXG5cbiAgdGhpcy5fbWF5UG9pbnRlckNhcHR1cmUgPSBudWxsO1xuICBtb3VudExvY2FsRE9NRXZlbnRMaXN0ZW5lcnModGhpcywgdGhpcy5fbG9jYWxIYW5kbGVyU2NvcGUpO1xufVxuXG52YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB1bm1vdW50RE9NRXZlbnRMaXN0ZW5lcnModGhpcy5fbG9jYWxIYW5kbGVyU2NvcGUpO1xuXG4gIGlmIChnbG9iYWxFdmVudFN1cHBvcnRlZCkge1xuICAgIHVubW91bnRET01FdmVudExpc3RlbmVycyh0aGlzLl9nbG9iYWxIYW5kbGVyU2NvcGUpO1xuICB9XG59O1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgdGhpcy5kb20uc3R5bGUgJiYgKHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0Jyk7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyRG9tUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbmV4cG9ydHMudXRpbCA9IHpyVXRpbDtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvcmUvbWF0cml4XCIpO1xuXG5leHBvcnRzLm1hdHJpeCA9IG1hdHJpeDtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCIuL2NvcmUvdmVjdG9yXCIpO1xuXG5leHBvcnRzLnZlY3RvciA9IHZlY3RvcjtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCIuL3Rvb2wvY29sb3JcIik7XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvclRvb2w7XG5cbnZhciBwYXRoVG9vbCA9IHJlcXVpcmUoXCIuL3Rvb2wvcGF0aFwiKTtcblxuZXhwb3J0cy5wYXRoID0gcGF0aFRvb2w7XG5cbnZhciBfcGFyc2VTVkcgPSByZXF1aXJlKFwiLi90b29sL3BhcnNlU1ZHXCIpO1xuXG52YXIgcGFyc2VTVkcgPSBfcGFyc2VTVkcucGFyc2VTVkc7XG5leHBvcnRzLnBhcnNlU1ZHID0gX3BhcnNlU1ZHLnBhcnNlU1ZHO1xuXG52YXIgX0dyb3VwID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0dyb3VwXCIpO1xuXG5leHBvcnRzLkdyb3VwID0gX0dyb3VwO1xuXG52YXIgX1BhdGggPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdGhcIik7XG5cbmV4cG9ydHMuUGF0aCA9IF9QYXRoO1xuXG52YXIgX0ltYWdlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9JbWFnZVwiKTtcblxuZXhwb3J0cy5JbWFnZSA9IF9JbWFnZTtcblxudmFyIF9Db21wb3VuZFBhdGggPSByZXF1aXJlKFwiLi9ncmFwaGljL0NvbXBvdW5kUGF0aFwiKTtcblxuZXhwb3J0cy5Db21wb3VuZFBhdGggPSBfQ29tcG91bmRQYXRoO1xuXG52YXIgX1RleHQgPSByZXF1aXJlKFwiLi9ncmFwaGljL1RleHRcIik7XG5cbmV4cG9ydHMuVGV4dCA9IF9UZXh0O1xuXG52YXIgX0luY3JlbWVudGFsRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9ncmFwaGljL0luY3JlbWVudGFsRGlzcGxheWFibGVcIik7XG5cbmV4cG9ydHMuSW5jcmVtZW50YWxEaXNwbGF5YWJsZSA9IF9JbmNyZW1lbnRhbERpc3BsYXlhYmxlO1xuXG52YXIgX0FyYyA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvQXJjXCIpO1xuXG5leHBvcnRzLkFyYyA9IF9BcmM7XG5cbnZhciBfQmV6aWVyQ3VydmUgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlXCIpO1xuXG5leHBvcnRzLkJlemllckN1cnZlID0gX0JlemllckN1cnZlO1xuXG52YXIgX0NpcmNsZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvQ2lyY2xlXCIpO1xuXG5leHBvcnRzLkNpcmNsZSA9IF9DaXJjbGU7XG5cbnZhciBfRHJvcGxldCA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvRHJvcGxldFwiKTtcblxuZXhwb3J0cy5Ecm9wbGV0ID0gX0Ryb3BsZXQ7XG5cbnZhciBfRWxsaXBzZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvRWxsaXBzZVwiKTtcblxuZXhwb3J0cy5FbGxpcHNlID0gX0VsbGlwc2U7XG5cbnZhciBfSGVhcnQgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL0hlYXJ0XCIpO1xuXG5leHBvcnRzLkhlYXJ0ID0gX0hlYXJ0O1xuXG52YXIgX0lzb2dvbiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvSXNvZ29uXCIpO1xuXG5leHBvcnRzLklzb2dvbiA9IF9Jc29nb247XG5cbnZhciBfTGluZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvTGluZVwiKTtcblxuZXhwb3J0cy5MaW5lID0gX0xpbmU7XG5cbnZhciBfUG9seWdvbiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvUG9seWdvblwiKTtcblxuZXhwb3J0cy5Qb2x5Z29uID0gX1BvbHlnb247XG5cbnZhciBfUG9seWxpbmUgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXCIpO1xuXG5leHBvcnRzLlBvbHlsaW5lID0gX1BvbHlsaW5lO1xuXG52YXIgX1JlY3QgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL1JlY3RcIik7XG5cbmV4cG9ydHMuUmVjdCA9IF9SZWN0O1xuXG52YXIgX1JpbmcgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL1JpbmdcIik7XG5cbmV4cG9ydHMuUmluZyA9IF9SaW5nO1xuXG52YXIgX1Jvc2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL1Jvc2VcIik7XG5cbmV4cG9ydHMuUm9zZSA9IF9Sb3NlO1xuXG52YXIgX1NlY3RvciA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvU2VjdG9yXCIpO1xuXG5leHBvcnRzLlNlY3RvciA9IF9TZWN0b3I7XG5cbnZhciBfU3RhciA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvc2hhcGUvU3RhclwiKTtcblxuZXhwb3J0cy5TdGFyID0gX1N0YXI7XG5cbnZhciBfVHJvY2hvaWQgPSByZXF1aXJlKFwiLi9ncmFwaGljL3NoYXBlL1Ryb2Nob2lkXCIpO1xuXG5leHBvcnRzLlRyb2Nob2lkID0gX1Ryb2Nob2lkO1xuXG52YXIgX0xpbmVhckdyYWRpZW50ID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9MaW5lYXJHcmFkaWVudFwiKTtcblxuZXhwb3J0cy5MaW5lYXJHcmFkaWVudCA9IF9MaW5lYXJHcmFkaWVudDtcblxudmFyIF9SYWRpYWxHcmFkaWVudCA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvUmFkaWFsR3JhZGllbnRcIik7XG5cbmV4cG9ydHMuUmFkaWFsR3JhZGllbnQgPSBfUmFkaWFsR3JhZGllbnQ7XG5cbnZhciBfUGF0dGVybiA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvUGF0dGVyblwiKTtcblxuZXhwb3J0cy5QYXR0ZXJuID0gX1BhdHRlcm47XG5cbnZhciBfQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbmV4cG9ydHMuQm91bmRpbmdSZWN0ID0gX0JvdW5kaW5nUmVjdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5cbi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjb21wb3VuZCcsXG4gIHNoYXBlOiB7XG4gICAgcGF0aHM6IG51bGxcbiAgfSxcbiAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHkgfHwgZGlydHlQYXRoO1xuICB9LFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7IC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXBhdGhzW2ldLnBhdGgpIHtcbiAgICAgICAgcGF0aHNbaV0uY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhzW2ldLnBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdLCBwYXRoc1tpXS5zZWdtZW50SWdub3JlVGhyZXNob2xkKTtcbiAgICB9XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhzW2ldLmJ1aWxkUGF0aChjdHgsIHBhdGhzW2ldLnNoYXBlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuL21peGluL1JlY3RUZXh0XCIpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gKi9cbmZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTsgLy8gRXh0ZW5kIHByb3BlcnRpZXNcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgKi9cblxuXG4gIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG4gIHRoaXMuX3JlY3QgPSBudWxsOyAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gIC8vIENhbiBvbmx5IGJlIGBudWxsYC9gdW5kZWZpbmVkYCBvciBhbiBub24tZW1wdHkgYXJyYXksIE1VU1QgTk9UIGJlIGFuIGVtcHR5IGFycmF5LlxuICAvLyBiZWNhdXNlIGl0IGlzIGVhc3kgdG8gb25seSB1c2luZyBudWxsIHRvIGNoZWNrIHdoZXRoZXIgY2xpcFBhdGhzIGNoYW5nZWQuXG5cbiAgdGhpcy5fX2NsaXBQYXRocyA9IG51bGw7IC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGxheWFibGUsXG4gIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgLyoqXG4gICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaC5cbiAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX19kaXJ0eTogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZGlzcGxheWFibGUgb2JqZWN0IGlzIHZpc2libGUuIHdoZW4gaXQgaXMgdHJ1ZSwgdGhlIGRpc3BsYXlhYmxlIG9iamVjdFxuICAgKiBpcyBub3QgZHJhd24sIGJ1dCB0aGUgbW91c2UgZXZlbnQgY2FuIHN0aWxsIHRyaWdnZXIgdGhlIG9iamVjdC5cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjaW52aXNpYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW52aXNpYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6OiAwLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHoyOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgeiBsZXZlbCBkZXRlcm1pbmVzIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QgY2FuIGJlIGRyYXduIGluIHdoaWNoIGxheWVyIGNhbnZhcy5cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjemxldmVsXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHpsZXZlbDogMCxcblxuICAvKipcbiAgICogV2hldGhlciBpdCBjYW4gYmUgZHJhZ2dlZC5cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBpcyBpdCBkcmFnZ2luZy5cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzLlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBlbmFibGUgY3VsbGluZ1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGN1bGxpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBNb3VzZSBjdXJzb3Igd2hlbiBob3ZlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2N1cnNvclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgY3Vyc29yOiAncG9pbnRlcicsXG5cbiAgLyoqXG4gICAqIElmIGhvdmVyIGFyZWEgaXMgYm91bmRpbmcgcmVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNyZWN0SG92ZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHJlY3RIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZWxlbWVudCBwcm9ncmVzc2l2ZWx5IHdoZW4gdGhlIHZhbHVlID49IDAsXG4gICAqIHVzZWZ1bGwgZm9yIGxhcmdlIGRhdGEuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGluY3JlbWVudGFsOiBmYWxzZSxcblxuICAvKipcbiAgICogU2NhbGUgcmF0aW8gZm9yIGdsb2JhbCBzY2FsZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnbG9iYWxTY2FsZVJhdGlvOiAxLFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gIC8qKlxuICAgKiBHcmFwaGljIGRyYXdpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBib3VuZGluZyBib3guXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICovXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdGhpcy5fX2RpcnR5VGV4dCA9IHRydWU7XG4gICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBUT0RPLCBldmVudHMgYm91bmQgYnkgYmluZFxuICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAvLyAgICAgcmV0dXJuICEoXG4gIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgLy8gICAgICk7XG4gIC8vIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgKi9cbiAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gIH0sXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICovXG4gIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvYmosIHRoaXMpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHZhbHVlIG9mIGB0ZXh0UG9zaXRpb25gIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gYSByZWFsIHBvc3Rpb24uXG4gICAqIEZvciBleGFtcGxlLCBgJ2luc2lkZSdgIGlzIGNhbGN1bGF0ZWQgdG8gYFtyZWN0LndpZHRoLzIsIHJlY3QuaGVpZ2h0LzJdYFxuICAgKiBieSBkZWZhdWx0LiBTZWUgYGNvbnRhaW4vdGV4dC5qcyNjYWxjdWxhdGVUZXh0UG9zaXRpb25gIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEJ1dCBzb21lIGNvdXRvbSBzaGFwZXMgbGlrZSBcInBpblwiLCBcImZsYWdcIiBoYXZlIGNlbnRlciB0aGF0IGlzIG5vdCBleGFjdGx5XG4gICAqIGBbd2lkdGgvMiwgaGVpZ2h0LzJdYC4gU28gd2UgcHJvdmlkZSB0aGlzIGhvb2sgdG8gY3VzdG9taXplIHRoZSBjYWxjdWxhdGlvblxuICAgKiBmb3IgdGhvc2Ugc2hhcGVzLiBJdCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgYHN0eWxlLnRleHRQb3NpdGlvbmAgaXMgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7T2JlamN0fSBbb3V0XSBQcmVwYXJlZCBvdXQgb2JqZWN0LiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHNob3VsZFxuICAgKiAgICAgICAgYmUgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIG9uZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAgICogQHJldHVybiB7T2JlamN0fSBvdXQgVGhlIHNhbWUgYXMgdGhlIGlucHV0IG91dC5cbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICAgIHg6IG51bWJlci4gbWFuZGF0b3J5LlxuICAgKiAgICAgICAgICAgICB5OiBudW1iZXIuIG1hbmRhdG9yeS5cbiAgICogICAgICAgICAgICAgdGV4dEFsaWduOiBzdHJpbmcuIG9wdGlvbmFsLiB1c2Ugc3R5bGUudGV4dEFsaWduIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBzdHJpbmcuIG9wdGlvbmFsLiB1c2Ugc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gYnkgZGVmYXVsdC5cbiAgICogICAgICAgICB9XG4gICAqL1xuICBjYWxjdWxhdGVUZXh0UG9zaXRpb246IG51bGxcbn07XG56clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuenJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBSZWN0VGV4dCk7IC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG52YXIgX2RlZmF1bHQgPSBEaXNwbGF5YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwiLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKi9cbnZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG4gIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG59O1xuXG5HcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcbiAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gLy8gRHJhdyByZWN0IHRleHRcblxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgLy8gT25seSByZXN0b3JlIHRyYW5zZm9ybSB3aGVuIG5lZWRzIGRyYXcgdGV4dC5cbiAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpbmhlcml0cyA9IF91dGlsLmluaGVyaXRzO1xuXG52YXIgRGlzcGxheWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIERpc3BsYXlhYmxlIGZvciBpbmNyZW1lbnRhbCByZW5kZXJpbmcuIEl0IHdpbGwgYmUgcmVuZGVyZWQgaW4gYSBzZXBhcmF0ZSBsYXllclxuICogSW5jcmVtZW50YWxEaXNwbGF5IGhhdmUgdHdvIG1haW4gbWV0aG9kcy4gYGNsZWFyRGlzcGxheWFibGVzYCBhbmQgYGFkZERpc3BsYXlhYmxlc2BcbiAqIGFkZERpc3BsYXlhYmxlcyB3aWxsIHJlbmRlciB0aGUgYWRkZWQgZGlzcGxheWFibGVzIGluY3JlbWV0YWxseS5cbiAqXG4gKiBJdCB1c2UgYSBub3QgY2xlYXJGbGFnIHRvIHRlbGwgdGhlIHBhaW50ZXIgZG9uJ3QgY2xlYXIgdGhlIGxheWVyIGlmIGl0J3MgdGhlIGZpcnN0IGVsZW1lbnQuXG4gKi9cbi8vIFRPRE8gU3R5bGUgb3ZlcnJpZGUgP1xuZnVuY3Rpb24gSW5jcmVtZW50YWxEaXNwbGF5YmxlKG9wdHMpIHtcbiAgRGlzcGxheWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLl9kaXNwbGF5YWJsZXMgPSBbXTtcbiAgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzID0gW107XG4gIHRoaXMuX2N1cnNvciA9IDA7XG4gIHRoaXMubm90Q2xlYXIgPSB0cnVlO1xufVxuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmluY3JlbWVudGFsID0gdHJ1ZTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5jbGVhckRpc3BsYXlibGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kaXNwbGF5YWJsZXMgPSBbXTtcbiAgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzID0gW107XG4gIHRoaXMuX2N1cnNvciA9IDA7XG4gIHRoaXMuZGlydHkoKTtcbiAgdGhpcy5ub3RDbGVhciA9IGZhbHNlO1xufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5hZGREaXNwbGF5YWJsZSA9IGZ1bmN0aW9uIChkaXNwbGF5YWJsZSwgbm90UGVyc2lzdGVudCkge1xuICBpZiAobm90UGVyc2lzdGVudCkge1xuICAgIHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcy5wdXNoKGRpc3BsYXlhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMucHVzaChkaXNwbGF5YWJsZSk7XG4gIH1cblxuICB0aGlzLmRpcnR5KCk7XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmFkZERpc3BsYXlhYmxlcyA9IGZ1bmN0aW9uIChkaXNwbGF5YWJsZXMsIG5vdFBlcnNpc3RlbnQpIHtcbiAgbm90UGVyc2lzdGVudCA9IG5vdFBlcnNpc3RlbnQgfHwgZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmFkZERpc3BsYXlhYmxlKGRpc3BsYXlhYmxlc1tpXSwgbm90UGVyc2lzdGVudCk7XG4gIH1cbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuZWFjaFBlbmRpbmdEaXNwbGF5YWJsZSA9IGZ1bmN0aW9uIChjYikge1xuICBmb3IgKHZhciBpID0gdGhpcy5fY3Vyc29yOyBpIDwgdGhpcy5fZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgJiYgY2IodGhpcy5fZGlzcGxheWFibGVzW2ldKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgJiYgY2IodGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzW2ldKTtcbiAgfVxufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMuX2N1cnNvcjsgaSA8IHRoaXMuX2Rpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX2Rpc3BsYXlhYmxlc1tpXTsgLy8gUEVORElOR1xuXG4gICAgZGlzcGxheWFibGUucGFyZW50ID0gdGhpcztcbiAgICBkaXNwbGF5YWJsZS51cGRhdGUoKTtcbiAgICBkaXNwbGF5YWJsZS5wYXJlbnQgPSBudWxsO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXNbaV07IC8vIFBFTkRJTkdcblxuICAgIGRpc3BsYXlhYmxlLnBhcmVudCA9IHRoaXM7XG4gICAgZGlzcGxheWFibGUudXBkYXRlKCk7XG4gICAgZGlzcGxheWFibGUucGFyZW50ID0gbnVsbDtcbiAgfVxufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5icnVzaCA9IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAvLyBSZW5kZXIgcGVyc2lzdGFudCBkaXNwbGF5YWJsZXMuXG4gIGZvciAodmFyIGkgPSB0aGlzLl9jdXJzb3I7IGkgPCB0aGlzLl9kaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl9kaXNwbGF5YWJsZXNbaV07XG4gICAgZGlzcGxheWFibGUuYmVmb3JlQnJ1c2ggJiYgZGlzcGxheWFibGUuYmVmb3JlQnJ1c2goY3R4KTtcbiAgICBkaXNwbGF5YWJsZS5icnVzaChjdHgsIGkgPT09IHRoaXMuX2N1cnNvciA/IG51bGwgOiB0aGlzLl9kaXNwbGF5YWJsZXNbaSAtIDFdKTtcbiAgICBkaXNwbGF5YWJsZS5hZnRlckJydXNoICYmIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2goY3R4KTtcbiAgfVxuXG4gIHRoaXMuX2N1cnNvciA9IGk7IC8vIFJlbmRlciB0ZW1wb3JhcnkgZGlzcGxheWFibGVzLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzW2ldO1xuICAgIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoICYmIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoKGN0eCk7XG4gICAgZGlzcGxheWFibGUuYnJ1c2goY3R4LCBpID09PSAwID8gbnVsbCA6IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlc1tpIC0gMV0pO1xuICAgIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2ggJiYgZGlzcGxheWFibGUuYWZ0ZXJCcnVzaChjdHgpO1xuICB9XG5cbiAgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzID0gW107XG4gIHRoaXMubm90Q2xlYXIgPSB0cnVlO1xufTtcblxudmFyIG0gPSBbXTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fcmVjdCkge1xuICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl9kaXNwbGF5YWJsZXNbaV07XG4gICAgICB2YXIgY2hpbGRSZWN0ID0gZGlzcGxheWFibGUuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcblxuICAgICAgaWYgKGRpc3BsYXlhYmxlLm5lZWRMb2NhbFRyYW5zZm9ybSgpKSB7XG4gICAgICAgIGNoaWxkUmVjdC5hcHBseVRyYW5zZm9ybShkaXNwbGF5YWJsZS5nZXRMb2NhbFRyYW5zZm9ybShtKSk7XG4gICAgICB9XG5cbiAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9yZWN0O1xufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5jb250YWluID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcblxuICBpZiAocmVjdC5jb250YWluKGxvY2FsUG9zWzBdLCBsb2NhbFBvc1sxXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fZGlzcGxheWFibGVzW2ldO1xuXG4gICAgICBpZiAoZGlzcGxheWFibGUuY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5pbmhlcml0cyhJbmNyZW1lbnRhbERpc3BsYXlibGUsIERpc3BsYXlibGUpO1xudmFyIF9kZWZhdWx0ID0gSW5jcmVtZW50YWxEaXNwbGF5YmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcbiAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAnbGluZWFyJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5MaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gTGluZWFyR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIHBhdGhDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vcGF0aFwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9QYXR0ZXJuXCIpO1xuXG52YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcGF0aFByb3h5Rm9yRHJhdyA9IG5ldyBQYXRoUHJveHkodHJ1ZSk7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGhcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuXG5mdW5jdGlvbiBQYXRoKG9wdHMpIHtcbiAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuXG4gIHRoaXMucGF0aCA9IG51bGw7XG59XG5cblBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgdHlwZTogJ3BhdGgnLFxuICBfX2RpcnR5UGF0aDogdHJ1ZSxcbiAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogNSxcbiAgLy8gVGhpcyBpdGVtIGRlZmF1bHQgdG8gYmUgZmFsc2UuIEJ1dCBpbiBtYXAgc2VyaWVzIGluIGVjaGFydHMsXG4gIC8vIGluIG9yZGVyIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSxcbiAgLy8gc28gdGhlIHNob3J0eSBzZWdtZW50IHdvbid0IGRyYXcuXG4gIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQ6IDAsXG5cbiAgLyoqXG4gICAqIFNlZSBgbW9kdWxlOnpyZW5kZXIvc3JjL2dyYXBoaWMvaGVscGVyL3N1YlBpeGVsT3B0aW1pemVgLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN1YlBpeGVsT3B0aW1pemU6IGZhbHNlLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCBwYXRoUHJveHlGb3JEcmF3O1xuICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIWZpbGwuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISFzdHJva2UuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhZmlsbC5pbWFnZTtcbiAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5pbWFnZTtcbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgdmFyIHJlY3Q7IC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcblxuICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICB9XG4gICAgfSAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cblxuXG4gICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoZmlsbCwgY3R4KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZUdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcbiAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDsgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG5cbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0sIHRoaXMuc2VnbWVudElnbm9yZVRocmVzaG9sZCk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgaWYgKHN0eWxlLmZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsR2xvYmFsQWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLmZpbGxPcGFjaXR5ICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcGF0aC5maWxsKGN0eCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsR2xvYmFsQWxwaGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLmZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3Ryb2tlKSB7XG4gICAgICBpZiAoc3R5bGUuc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEdsb2JhbEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5zdHJva2VPcGFjaXR5ICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcGF0aC5zdHJva2UoY3R4KTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxHbG9iYWxBbHBoYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGguc3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICAvLyBSZW1vdmUgbGluZURhc2hcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfSAvLyBEcmF3IHJlY3QgdGV4dFxuXG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAvLyBPbmx5IHJlc3RvcmUgdHJhbnNmb3JtIHdoZW4gbmVlZHMgZHJhdyB0ZXh0LlxuICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAvLyBMaWtlIGluIGNpcmNsZVxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnLCBpbkJ1bmRsZSkge30sXG4gIGNyZWF0ZVBhdGhQcm94eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuXG4gICAgaWYgKG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAvLyBDcmVhdGUgcGF0aCBvbiBkZW1hbmQuXG4gICAgICAgIHBhdGggPSB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAvLyAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuXG4gICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpOyAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuXG4gICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoOyAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcblxuICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxOyAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuXG4gICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgfSAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLndpZHRoICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS55IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG5cblxuICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLnBhdGguZGF0YTtcblxuICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbi5jb250YWluKHBhdGhEYXRhLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGRpcnR5UGF0aFxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uIChkaXJ0eVBhdGgpIHtcbiAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgfSAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG5cblxuICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHlUZXh0ID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTsgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcblxuICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgdGhpcy5fX2NsaXBUYXJnZXQuZGlydHkoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgKi9cbiAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3NoYXBlJywgbG9vcCk7XG4gIH0sXG4gIC8vIE92ZXJ3cml0ZSBhdHRyS1ZcbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIEZJWE1FXG4gICAgaWYgKGtleSA9PT0gJ3NoYXBlJykge1xuICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICB0aGlzLl9fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRTaGFwZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlOyAvLyBQYXRoIGZyb20gc3RyaW5nIG1heSBub3QgaGF2ZSBzaGFwZVxuXG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTsgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgIC8vIERldGVybWluYW50IG9mIGBtYCBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgLy8gZm9yIHdpZHRoLlxuXG4gICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMCA/IE1hdGguc3FydChhYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSkpIDogMTtcbiAgfVxufTtcbi8qKlxuICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gKiBFeHRlbmQgYSBwYXRoIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCBPdmVyd3JpdGUgYnVpbGRQYXRoIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc2hhcGVdIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXG4gKi9cblxuUGF0aC5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgdmFyIFN1YiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgaWYgKGRlZmF1bHRzLnN0eWxlKSB7XG4gICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgdGhpcy5zdHlsZS5leHRlbmRGcm9tKGRlZmF1bHRzLnN0eWxlLCBmYWxzZSk7XG4gICAgfSAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuXG5cbiAgICB2YXIgZGVmYXVsdFNoYXBlID0gZGVmYXVsdHMuc2hhcGU7XG5cbiAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XG4gICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcbiAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRTaGFwZSkge1xuICAgICAgICBpZiAoIXRoaXNTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZhdWx0cy5pbml0ICYmIGRlZmF1bHRzLmluaXQuY2FsbCh0aGlzLCBvcHRzKTtcbiAgfTtcblxuICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTsgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXG5cbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgIC8vIEV4dGVuZGluZyBwcm90b3R5cGUgdmFsdWVzIGFuZCBtZXRob2RzXG4gICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdWI7XG59O1xuXG56clV0aWwuaW5oZXJpdHMoUGF0aCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gUGF0aDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnJlcGVhdCA9IHJlcGVhdDsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBQYXR0ZXJuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ3JhZGlhbCcsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcbiAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdyYWRpYWwnOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cblJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBSYWRpYWxHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIGZpeFNoYWRvdyA9IHJlcXVpcmUoXCIuL2hlbHBlci9maXhTaGFkb3dcIik7XG5cbnZhciBfY29uc3RhbnQgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcblxudmFyIENvbnRleHRDYWNoZWRCeSA9IF9jb25zdGFudC5Db250ZXh0Q2FjaGVkQnk7XG52YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXV07IC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4vLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdGhpcy5leHRlbmRGcm9tKG9wdHMsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgdmFyIHgyID0gb2JqLngyID09IG51bGwgPyAxIDogb2JqLngyO1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gIH0gLy8gRml4IE5hTiB3aGVuIHJlY3QgaXMgSW5maW5pdHlcblxuXG4gIHggPSBpc05hTih4KSA/IDAgOiB4O1xuICB4MiA9IGlzTmFOKHgyKSA/IDEgOiB4MjtcbiAgeSA9IGlzTmFOKHkpID8gMCA6IHk7XG4gIHkyID0gaXNOYU4oeTIpID8gMCA6IHkyO1xuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgIHIgPSByICogbWluO1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3BhY2l0eTogMSxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGZpbGxPcGFjaXR5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3Ryb2tlT3BhY2l0eTogbnVsbCxcblxuICAvKipcbiAgICogYHRydWVgIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIGBmYWxzZWAvYG51bGxgL2B1bmRlZmluZWRgIGFyZSB0aGUgc2FtZS5cbiAgICogYGZhbHNlYCBpcyB1c2VkIHRvIHJlbW92ZSBsaW5lRGFzaCBpbiBzb21lXG4gICAqIGNhc2UgdGhhdCBgbnVsbGAvYHVuZGVmaW5lZGAgY2FuIG5vdCBiZSBzZXQuXG4gICAqIChlLmcuLCBlbXBoYXNpcy5saW5lU3R5bGUgaW4gZWNoYXJ0cylcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fGJvb2xlYW59XG4gICAqL1xuICBsaW5lRGFzaDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZVdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG4gIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dDogbnVsbCxcblxuICAvKipcbiAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udDogbnVsbCxcblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRTdHlsZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFdlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmb250U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseTogbnVsbCxcblxuICAvKipcbiAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VGFnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICogW3gsIHldXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICovXG4gIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgLyoqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRleHRSZWN0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBbeCwgeV1cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9mZnNldDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dERpc3RhbmNlOiA1LFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgKiBPbmx5IGF2YWlsYWJsZSBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50LFxuICAgKiB3aGVyZSB0aGUgdGV4dCBpcyBjYWxsZWQgYXMgYFJlY3RUZXh0YC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0cmFuc2Zvcm1UZXh0OiBmYWxzZSxcblxuICAvKipcbiAgICogVGV4dCByb3RhdGUgYXJvdW5kIHBvc2l0aW9uIG9mIFBhdGggb3IgSW1hZ2UuXG4gICAqIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uIGNhbiBiZSBzcGVjaWZpZWQgYnkgYHRleHRPcmlnaW5gLlxuICAgKiBPbmx5IGF2YWlsYWJsZSBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50LFxuICAgKiB3aGVyZSB0aGUgdGV4dCBpcyBjYWxsZWQgYXMgYFJlY3RUZXh0YC5cbiAgICovXG4gIHRleHRSb3RhdGlvbjogMCxcblxuICAvKipcbiAgICogVGV4dCBvcmlnaW4gb2YgdGV4dCByb3RhdGlvbi5cbiAgICogVXNlZnVsIGluIHRoZSBjYXNlIGxpa2UgbGFiZWwgcm90YXRpb24gb2YgY2lyY3VsYXIgc3ltYm9sLlxuICAgKiBPbmx5IGF2YWlsYWJsZSBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50LCB3aGVyZSB0aGUgdGV4dCBpcyBjYWxsZWRcbiAgICogYXMgYFJlY3RUZXh0YCBhbmQgdGhlIGVsZW1lbnQgaXMgY2FsbGVkIGFzIFwiaG9zdCBlbGVtZW50XCIuXG4gICAqIFRoZSB2YWx1ZSBjYW4gYmU6XG4gICAqICsgSWYgc3BlY2lmaWVkIGFzIGEgY29vcmRpbmF0ZSBsaWtlIGBbMTAsIDQwXWAsIGl0IGlzIHRoZSBgW3gsIHldYFxuICAgKiBiYXNlIG9uIHRoZSBsZWZ0LXRvcCBjb3JuZXIgb2YgdGhlIHJlY3Qgb2YgaXRzIGhvc3QgZWxlbWVudC5cbiAgICogKyBJZiBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgYGNlbnRlcmAsIGl0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIHJlY3Qgb2ZcbiAgICogaXRzIGhvc3QgZWxlbWVudC5cbiAgICogKyBCeSBkZWZhdWx0LCB0aGlzIG9yaWdpbiBpcyB0aGUgYHRleHRQb3NpdGlvbmAuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgLyoqXG4gICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcmljaDogbnVsbCxcblxuICAvKipcbiAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0cnVuY2F0ZTogbnVsbCxcblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJsZW5kOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTsgLy8gSWYgbm8gcHJldlN0eWxlLCBpdCBtZWFucyBmaXJzdCBkcmF3LlxuICAgIC8vIE9ubHkgYXBwbHkgY2FjaGUgaWYgdGhlIGxhc3QgdGltZSBjYWNoY2VkIGJ5IHRoaXMgZnVuY3Rpb24uXG5cbiAgICB2YXIgbm90Q2hlY2tDYWNoZSA9ICFwcmV2U3R5bGUgfHwgY3R4Ll9fYXR0ckNhY2hlZEJ5ICE9PSBDb250ZXh0Q2FjaGVkQnkuU1RZTEVfQklORDtcbiAgICBjdHguX19hdHRyQ2FjaGVkQnkgPSBDb250ZXh0Q2FjaGVkQnkuU1RZTEVfQklORDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICBpZiAobm90Q2hlY2tDYWNoZSB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgIGN0eFtzdHlsZU5hbWVdID0gZml4U2hhZG93KGN0eCwgc3R5bGVOYW1lLCBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3RDaGVja0NhY2hlIHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICB9XG5cbiAgICBpZiAobm90Q2hlY2tDYWNoZSB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB9XG5cbiAgICBpZiAobm90Q2hlY2tDYWNoZSB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKG5vdENoZWNrQ2FjaGUgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkge1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDEpO1xuICAgIH1cbiAgfSxcbiAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICB9LFxuICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgfSxcblxuICAvKipcbiAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGUgdHJ1ZTogb3ZlcndyaXJ0ZSBhbnkgd2F5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTogb3ZlcndyaXRlIG9ubHkgd2hlbiAhdGFyZ2V0Lmhhc093blByb3BlcnR5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyczogb3ZlcndyaXRlIHdoZW4gcHJvcGVydHkgaXMgbm90IG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSB8fCAob3ZlcndyaXRlID09PSBmYWxzZSA/ICF0aGlzLmhhc093blByb3BlcnR5KG5hbWUpIDogb3RoZXJTdHlsZVtuYW1lXSAhPSBudWxsKSkpIHtcbiAgICAgICAgICB0aGlzW25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICovXG4gIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lXG4gICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ld1N0eWxlO1xuICB9LFxuICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIG1ldGhvZCA9IG9iai50eXBlID09PSAncmFkaWFsJyA/IGNyZWF0ZVJhZGlhbEdyYWRpZW50IDogY3JlYXRlTGluZWFyR3JhZGllbnQ7XG4gICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgfVxufTtcbnZhciBzdHlsZVByb3RvID0gU3R5bGUucHJvdG90eXBlO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcblxuICBpZiAoIShwcm9wWzBdIGluIHN0eWxlUHJvdG8pKSB7XG4gICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gIH1cbn0gLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG5cblxuU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xudmFyIF9kZWZhdWx0ID0gU3R5bGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvdGV4dFwiKTtcblxudmFyIF9jb25zdGFudCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuXG52YXIgQ29udGV4dENhY2hlZEJ5ID0gX2NvbnN0YW50LkNvbnRleHRDYWNoZWRCeTtcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xudmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn07XG5cblRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGV4dCxcbiAgdHlwZTogJ3RleHQnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTsgLy8gVXNlIHByb3BzIHdpdGggcHJlZml4ICd0ZXh0Jy5cblxuICAgIHN0eWxlLmZpbGwgPSBzdHlsZS5zdHJva2UgPSBzdHlsZS5zaGFkb3dCbHVyID0gc3R5bGUuc2hhZG93Q29sb3IgPSBzdHlsZS5zaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTsgLy8gRG8gbm90IGFwcGx5IHN0eWxlLmJpbmQgaW4gVGV4dCBub2RlLiBCZWNhdXNlIHRoZSByZWFsIGJpbmQgam9iXG4gICAgLy8gaXMgaW4gdGV4dEhlbHBlci5yZW5kZXJUZXh0LCBhbmQgcGVyZm9ybWFuY2Ugb2YgdGV4dCByZW5kZXIgc2hvdWxkXG4gICAgLy8gYmUgY29uc2lkZXJlZC5cbiAgICAvLyBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCBlbC5zdHlsZSBpcyBub3QgYXBwbGllZFxuICAgICAgLy8gYW5kIHNob3VsZCBub3QgYmUgdXNlZCBhcyBjYWNoZS5cbiAgICAgIGN0eC5fX2F0dHJDYWNoZWRCeSA9IENvbnRleHRDYWNoZWRCeS5OT05FO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIG51bGwsIHByZXZFbCk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS50ZXh0TGluZUhlaWdodCwgc3R5bGUucmljaCk7XG4gICAgICByZWN0LnggKz0gc3R5bGUueCB8fCAwO1xuICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcblxuICAgICAgaWYgKHRleHRIZWxwZXIuZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHN0eWxlLnRleHRTdHJva2VXaWR0aCkpIHtcbiAgICAgICAgdmFyIHcgPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgIHJlY3QueCAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC55IC09IHcgLyAyO1xuICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgIHJlY3QuaGVpZ2h0ICs9IHc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBDb250ZXh0Q2FjaGVkQnkgPSB7XG4gIE5PTkU6IDAsXG4gIFNUWUxFX0JJTkQ6IDEsXG4gIFBMQUlOX1RFWFQ6IDJcbn07IC8vIEF2b2lkIGNvbmZ1c2VkIHdpdGggMC9mYWxzZS5cblxudmFyIFdJTExfQkVfUkVTVE9SRUQgPSA5O1xuZXhwb3J0cy5Db250ZXh0Q2FjaGVkQnkgPSBDb250ZXh0Q2FjaGVkQnk7XG5leHBvcnRzLldJTExfQkVfUkVTVE9SRUQgPSBXSUxMX0JFX1JFU1RPUkVEOyIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBTSEFET1dfUFJPUFMgPSB7XG4gICdzaGFkb3dCbHVyJzogMSxcbiAgJ3NoYWRvd09mZnNldFgnOiAxLFxuICAnc2hhZG93T2Zmc2V0WSc6IDEsXG4gICd0ZXh0U2hhZG93Qmx1cic6IDEsXG4gICd0ZXh0U2hhZG93T2Zmc2V0WCc6IDEsXG4gICd0ZXh0U2hhZG93T2Zmc2V0WSc6IDEsXG4gICd0ZXh0Qm94U2hhZG93Qmx1cic6IDEsXG4gICd0ZXh0Qm94U2hhZG93T2Zmc2V0WCc6IDEsXG4gICd0ZXh0Qm94U2hhZG93T2Zmc2V0WSc6IDFcbn07XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGN0eCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGlmIChTSEFET1dfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICo9IGN0eC5kcHI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIExSVSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0xSVVwiKTtcblxudmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICByZXR1cm4gY2FjaGVkSW1nT2JqICYmIGNhY2hlZEltZ09iai5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgfVxufVxuLyoqXG4gKiBDYXV0aW9uOiBVc2VyIHNob3VsZCBjYWNoZSBsb2FkZWQgaW1hZ2VzLCBidXQgbm90IGp1c3QgY291bnQgb24gTFJVLlxuICogQ29uc2lkZXIgaWYgcmVxdWlyZWQgaW1hZ2VzIG1vcmUgdGhhbiBMUlUgc2l6ZSwgd2lsbCBkZWFkIGxvb3Agb2NjdXI/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlIEV4aXN0ZW50IGltYWdlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBwYXJhbXM6IChpbWFnZSwgY2JQYXlsb2FkKVxuICogQHBhcmFtIHtPYmplY3R9IFtjYlBheWxvYWRdIFBheWxvYWQgb24gY2IgY2FsbGluZy5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJbWFnZShuZXdJbWFnZU9yU3JjLCBpbWFnZSwgaG9zdEVsLCBjYiwgY2JQYXlsb2FkKSB7XG4gIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgIHJldHVybiBpbWFnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbWFnZSBzaG91bGQgbm90IGJlIGxvYWRlZCByZXBlYXRseS5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuX196ckltYWdlU3JjID09PSBuZXdJbWFnZU9yU3JjIHx8ICFob3N0RWwpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuXG5cbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0ge1xuICAgICAgaG9zdEVsOiBob3N0RWwsXG4gICAgICBjYjogY2IsXG4gICAgICBjYlBheWxvYWQ6IGNiUGF5bG9hZFxuICAgIH07XG5cbiAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5vbmVycm9yID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5OyIsInZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKFwiLi9zbW9vdGhTcGxpbmVcIik7XG5cbnZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKFwiLi9zbW9vdGhCZXppZXJcIik7XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcblxuICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDsiLCIvKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZVxuICogQHBhcmFtIHtudW1iZXJ9IHNoYXBlLnhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFwZS55XG4gKiBAcGFyYW0ge251bWJlcn0gc2hhcGUud2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFwZS5oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFwZS5yXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlKSB7XG4gIHZhciB4ID0gc2hhcGUueDtcbiAgdmFyIHkgPSBzaGFwZS55O1xuICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgdmFyIHIgPSBzaGFwZS5yO1xuICB2YXIgcjE7XG4gIHZhciByMjtcbiAgdmFyIHIzO1xuICB2YXIgcjQ7IC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuXG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICByMSA9IHIzID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgICByNCA9IHJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgfVxuXG4gIHZhciB0b3RhbDtcblxuICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMSArIHIyO1xuICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gIHIyICE9PSAwICYmIGN0eC5hcmMoeCArIHdpZHRoIC0gcjIsIHkgKyByMiwgcjIsIC1NYXRoLlBJIC8gMiwgMCk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICByMyAhPT0gMCAmJiBjdHguYXJjKHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0IC0gcjMsIHIzLCAwLCBNYXRoLlBJIC8gMik7XG4gIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgcjQgIT09IDAgJiYgY3R4LmFyYyh4ICsgcjQsIHkgKyBoZWlnaHQgLSByNCwgcjQsIE1hdGguUEkgLyAyLCBNYXRoLlBJKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICByMSAhPT0gMCAmJiBjdHguYXJjKHggKyByMSwgeSArIHIxLCByMSwgTWF0aC5QSSwgTWF0aC5QSSAqIDEuNSk7XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoOyIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJNaW4gPSBfdmVjdG9yLm1pbjtcbnZhciB2Mk1heCA9IF92ZWN0b3IubWF4O1xudmFyIHYyU2NhbGUgPSBfdmVjdG9yLnNjYWxlO1xudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xudmFyIHYyQWRkID0gX3ZlY3Rvci5hZGQ7XG52YXIgdjJDbG9uZSA9IF92ZWN0b3IuY2xvbmU7XG52YXIgdjJTdWIgPSBfdmVjdG9yLnN1YjtcblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciB2ID0gW107XG4gIHZhciB2MSA9IFtdO1xuICB2YXIgdjIgPSBbXTtcbiAgdmFyIHByZXZQb2ludDtcbiAgdmFyIG5leHRQb2ludDtcbiAgdmFyIG1pbjtcbiAgdmFyIG1heDtcblxuICBpZiAoY29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgIH0gLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG5cblxuICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKHYyQ2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2MlN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7IC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcblxuICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIGlzTG9vcCkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXN0YW5jZSArPSB2MkRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gIH1cblxuICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG4gICAgdmFyIHcgPSBwb3MgLSBpZHg7XG4gICAgdmFyIHAwO1xuICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgIH1cblxuICAgIHZhciB3MiA9IHcgKiB3O1xuICAgIHZhciB3MyA9IHcgKiB3MjtcbiAgICByZXQucHVzaChbaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsIi8qKlxuICogU3ViLXBpeGVsIG9wdGltaXplIGZvciBjYW52YXMgcmVuZGVyaW5nLCBwcmV2ZW50IGZyb20gYmx1clxuICogd2hlbiByZW5kZXJpbmcgYSB0aGluIHZlcnRpY2FsL2hvcml6b250YWwgbGluZS5cbiAqL1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbi8qKlxuICogU3ViIHBpeGVsIG9wdGltaXplIGxpbmUgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXRTaGFwZSBUaGUgbW9kaWZpY2F0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIG9uIGBvdXRwdXRTaGFwZWAuXG4gKiAgICAgICAgICAgICAgICAgYG91dHB1dFNoYXBlYCBhbmQgYGlucHV0U2hhcGVgIGNhbiBiZSB0aGUgc2FtZSBvYmplY3QuXG4gKiAgICAgICAgICAgICAgICAgYG91dHB1dFNoYXBlYCBvYmplY3QgY2FuIGJlIHVzZWQgcmVwZWF0bHksIGJlY2F1c2UgYWxsIG9mXG4gKiAgICAgICAgICAgICAgICAgdGhlIGB4MWAsIGB4MmAsIGB5MWAsIGB5MmAgd2lsbCBiZSBhc3NpZ25lZCBpbiB0aGlzIG1ldGhvZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5wdXRTaGFwZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS54MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS55MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS54Ml1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmxpbmVXaWR0aF0gSWYgYG51bGxgL2B1bmRlZmluZWRgL2AwYCwgZG8gbm90IG9wdGltaXplLlxuICovXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVMaW5lKG91dHB1dFNoYXBlLCBpbnB1dFNoYXBlLCBzdHlsZSkge1xuICBpZiAoIWlucHV0U2hhcGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgeDEgPSBpbnB1dFNoYXBlLngxO1xuICB2YXIgeDIgPSBpbnB1dFNoYXBlLngyO1xuICB2YXIgeTEgPSBpbnB1dFNoYXBlLnkxO1xuICB2YXIgeTIgPSBpbnB1dFNoYXBlLnkyO1xuICBvdXRwdXRTaGFwZS54MSA9IHgxO1xuICBvdXRwdXRTaGFwZS54MiA9IHgyO1xuICBvdXRwdXRTaGFwZS55MSA9IHkxO1xuICBvdXRwdXRTaGFwZS55MiA9IHkyO1xuICB2YXIgbGluZVdpZHRoID0gc3R5bGUgJiYgc3R5bGUubGluZVdpZHRoO1xuXG4gIGlmICghbGluZVdpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJvdW5kKHgxICogMikgPT09IHJvdW5kKHgyICogMikpIHtcbiAgICBvdXRwdXRTaGFwZS54MSA9IG91dHB1dFNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZSh4MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChyb3VuZCh5MSAqIDIpID09PSByb3VuZCh5MiAqIDIpKSB7XG4gICAgb3V0cHV0U2hhcGUueTEgPSBvdXRwdXRTaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoeTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIH1cbn1cbi8qKlxuICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXRTaGFwZSBUaGUgbW9kaWZpY2F0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIG9uIGBvdXRwdXRTaGFwZWAuXG4gKiAgICAgICAgICAgICAgICAgYG91dHB1dFNoYXBlYCBhbmQgYGlucHV0U2hhcGVgIGNhbiBiZSB0aGUgc2FtZSBvYmplY3QuXG4gKiAgICAgICAgICAgICAgICAgYG91dHB1dFNoYXBlYCBvYmplY3QgY2FuIGJlIHVzZWQgcmVwZWF0bHksIGJlY2F1c2UgYWxsIG9mXG4gKiAgICAgICAgICAgICAgICAgdGhlIGB4YCwgYHlgLCBgd2lkdGhgLCBgaGVpZ2h0YCB3aWxsIGJlIGFzc2lnbmVkIGluIHRoaXMgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IFtpbnB1dFNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLnhdXG4gKiBAcGFyYW0ge251bWJlcn0gW2lucHV0U2hhcGUueV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS53aWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS5oZWlnaHRdXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5saW5lV2lkdGhdIElmIGBudWxsYC9gdW5kZWZpbmVkYC9gMGAsIGRvIG5vdCBvcHRpbWl6ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVSZWN0KG91dHB1dFNoYXBlLCBpbnB1dFNoYXBlLCBzdHlsZSkge1xuICBpZiAoIWlucHV0U2hhcGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3JpZ2luWCA9IGlucHV0U2hhcGUueDtcbiAgdmFyIG9yaWdpblkgPSBpbnB1dFNoYXBlLnk7XG4gIHZhciBvcmlnaW5XaWR0aCA9IGlucHV0U2hhcGUud2lkdGg7XG4gIHZhciBvcmlnaW5IZWlnaHQgPSBpbnB1dFNoYXBlLmhlaWdodDtcbiAgb3V0cHV0U2hhcGUueCA9IG9yaWdpblg7XG4gIG91dHB1dFNoYXBlLnkgPSBvcmlnaW5ZO1xuICBvdXRwdXRTaGFwZS53aWR0aCA9IG9yaWdpbldpZHRoO1xuICBvdXRwdXRTaGFwZS5oZWlnaHQgPSBvcmlnaW5IZWlnaHQ7XG4gIHZhciBsaW5lV2lkdGggPSBzdHlsZSAmJiBzdHlsZS5saW5lV2lkdGg7XG5cbiAgaWYgKCFsaW5lV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXRwdXRTaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YLCBsaW5lV2lkdGgsIHRydWUpO1xuICBvdXRwdXRTaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZLCBsaW5lV2lkdGgsIHRydWUpO1xuICBvdXRwdXRTaGFwZS53aWR0aCA9IE1hdGgubWF4KHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIG91dHB1dFNoYXBlLngsIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDEpO1xuICBvdXRwdXRTaGFwZS5oZWlnaHQgPSBNYXRoLm1heChzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gb3V0cHV0U2hhcGUueSwgb3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IDEpO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggSWYgYG51bGxgL2B1bmRlZmluZWRgL2AwYCwgZG8gbm90IG9wdGltaXplLlxuICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZShwb3NpdGlvbiwgbGluZVdpZHRoLCBwb3NpdGl2ZU9yTmVnYXRpdmUpIHtcbiAgaWYgKCFsaW5lV2lkdGgpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXG4gIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxuXG5cbiAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XG4gIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwID8gZG91YmxlZFBvc2l0aW9uIC8gMiA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xufVxuXG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gc3ViUGl4ZWxPcHRpbWl6ZUxpbmU7XG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gc3ViUGl4ZWxPcHRpbWl6ZVJlY3Q7XG5leHBvcnRzLnN1YlBpeGVsT3B0aW1pemUgPSBzdWJQaXhlbE9wdGltaXplOyIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxudmFyIGZpeFNoYWRvdyA9IHJlcXVpcmUoXCIuL2ZpeFNoYWRvd1wiKTtcblxudmFyIF9jb25zdGFudCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudFwiKTtcblxudmFyIENvbnRleHRDYWNoZWRCeSA9IF9jb25zdGFudC5Db250ZXh0Q2FjaGVkQnk7XG52YXIgV0lMTF9CRV9SRVNUT1JFRCA9IF9jb25zdGFudC5XSUxMX0JFX1JFU1RPUkVEO1xudmFyIERFRkFVTFRfRk9OVCA9IHRleHRDb250YWluLkRFRkFVTFRfRk9OVDsgLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG5cbnZhciBWQUxJRF9URVhUX0FMSUdOID0ge1xuICBsZWZ0OiAxLFxuICByaWdodDogMSxcbiAgY2VudGVyOiAxXG59O1xudmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7XG4gIHRvcDogMSxcbiAgYm90dG9tOiAxLFxuICBtaWRkbGU6IDFcbn07IC8vIERpZmZlcmVudCBmcm9tIGBTVFlMRV9DT01NT05fUFJPUFNgIG9mIGBncmFwaGljL1N0eWxlYCxcbi8vIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHNoYWRvd0NvbG9yIGlzIGAndHJhbnNwYXJlbnQnYC5cblxudmFyIFNIQURPV19TVFlMRV9DT01NT05fUFJPUFMgPSBbWyd0ZXh0U2hhZG93Qmx1cicsICdzaGFkb3dCbHVyJywgMF0sIFsndGV4dFNoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3RleHRTaGFkb3dPZmZzZXRZJywgJ3NoYWRvd09mZnNldFknLCAwXSwgWyd0ZXh0U2hhZG93Q29sb3InLCAnc2hhZG93Q29sb3InLCAndHJhbnNwYXJlbnQnXV07XG52YXIgX3RtcFRleHRQb3NpdGlvblJlc3VsdCA9IHt9O1xudmFyIF90bXBCb3hQb3NpdGlvblJlc3VsdCA9IHt9O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnR8bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvY29uc3RhbnQuV0lMTF9CRV9SRVNUT1JFRH0gW3ByZXZFbF0gRm9yIGN0eCBwcm9wIGNhY2hlLlxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QsIHByZXZFbCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCwgcHJldkVsKTtcbn0gLy8gQXZvaWQgc2V0dGluZyB0byBjdHggYWNjb3JkaW5nIHRvIHByZXZFbCBpZiBwb3NzaWJsZSBmb3Jcbi8vIHBlcmZvcm1hbmNlIGluIHNjZW5hcmlvcyBvZiBsYXJnZSBhbW91bnQgdGV4dC5cblxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcbiAgdmFyIHByZXZTdHlsZTtcbiAgdmFyIGNoZWNrQ2FjaGUgPSBmYWxzZTtcbiAgdmFyIGNhY2hlZEJ5TWUgPSBjdHguX19hdHRyQ2FjaGVkQnkgPT09IENvbnRleHRDYWNoZWRCeS5QTEFJTl9URVhUOyAvLyBPbmx5IHRha2UgYW5kIGNoZWNrIGNhY2hlIGZvciBgVGV4dGAgZWwsIGJ1dCBub3QgUmVjdFRleHQuXG5cbiAgaWYgKHByZXZFbCAhPT0gV0lMTF9CRV9SRVNUT1JFRCkge1xuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZTdHlsZSA9IHByZXZFbC5zdHlsZTtcbiAgICAgIGNoZWNrQ2FjaGUgPSAhbmVlZERyYXdCZyAmJiBjYWNoZWRCeU1lICYmIHByZXZTdHlsZTtcbiAgICB9IC8vIFByZXZlbnQgZnJvbSB1c2luZyBjYWNoZSBpbiBgU3R5bGU6OmJpbmRgLCBiZWNhdXNlIG9mIHRoZSBjYXNlOlxuICAgIC8vIGN0eCBwcm9wZXJ0eSBpcyBtb2RpZmllZCBieSBvdGhlciBwcm9wZXJ0aWVzIHRoYW4gYFN0eWxlOjpiaW5kYFxuICAgIC8vIHVzZWQsIGFuZCBTdHlsZTo6YmluZCBpcyBjYWxsZWQgbmV4dC5cblxuXG4gICAgY3R4Ll9fYXR0ckNhY2hlZEJ5ID0gbmVlZERyYXdCZyA/IENvbnRleHRDYWNoZWRCeS5OT05FIDogQ29udGV4dENhY2hlZEJ5LlBMQUlOX1RFWFQ7XG4gIH0gLy8gU2luY2UgdGhpcyB3aWxsIGJlIHJlc3RvcmVkLCBwcmV2ZW50IGZyb20gdXNpbmcgdGhlc2UgcHJvcHMgdG8gY2hlY2sgY2FjaGUgaW4gdGhlIG5leHRcbiAgLy8gZW50ZXJpbmcgb2YgdGhpcyBtZXRob2QuIEJ1dCBkbyBub3QgbmVlZCB0byBjbGVhciBvdGhlciBjYWNoZSBsaWtlIGBTdHlsZTo6YmluZGAuXG4gIGVsc2UgaWYgKGNhY2hlZEJ5TWUpIHtcbiAgICAgIGN0eC5fX2F0dHJDYWNoZWRCeSA9IENvbnRleHRDYWNoZWRCeS5OT05FO1xuICAgIH1cblxuICB2YXIgc3R5bGVGb250ID0gc3R5bGUuZm9udCB8fCBERUZBVUxUX0ZPTlQ7IC8vIFBFTkRJTkdcbiAgLy8gT25seSBgVGV4dGAgZWwgc2V0IGBmb250YCBhbmQga2VlcCBpdCAoYFJlY3RUZXh0YCB3aWxsIHJlc3RvcmUpLiBTbyB0aGVvcmV0aWNhbGx5XG4gIC8vIHdlIGNhbiBtYWtlIGZvbnQgY2FjaGUgb24gY3R4LCB3aGljaCBjYW4gY2FjaGUgZm9yIHRleHQgZWwgdGhhdCBhcmUgZGlzY29udGludW91cy5cbiAgLy8gQnV0IGxheWVyIHNhdmUvcmVzdG9yZSBuZWVkZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAgLy8gaWYgKHN0eWxlRm9udCAhPT0gY3R4Ll9fZm9udENhY2hlKSB7XG4gIC8vICAgICBjdHguZm9udCA9IHN0eWxlRm9udDtcbiAgLy8gICAgIGlmIChwcmV2RWwgIT09IFdJTExfQkVfUkVTVE9SRUQpIHtcbiAgLy8gICAgICAgICBjdHguX19mb250Q2FjaGUgPSBzdHlsZUZvbnQ7XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICBpZiAoIWNoZWNrQ2FjaGUgfHwgc3R5bGVGb250ICE9PSAocHJldlN0eWxlLmZvbnQgfHwgREVGQVVMVF9GT05UKSkge1xuICAgIGN0eC5mb250ID0gc3R5bGVGb250O1xuICB9IC8vIFVzZSB0aGUgZmluYWwgZm9udCBmcm9tIGNvbnRleHQtMmQsIGJlY2F1c2UgdGhlIGZpbmFsXG4gIC8vIGZvbnQgbWlnaHQgbm90IGJlIHRoZSBzdHlsZS5mb250IHdoZW4gaXQgaXMgaWxsZWdhbC5cbiAgLy8gQnV0IGdldCBgY3R4LmZvbnRgIG1pZ2h0IGJlIHRpbWUgY29uc3VtaW5nLlxuXG5cbiAgdmFyIGNvbXB1dGVkRm9udCA9IGhvc3RFbC5fX2NvbXB1dGVkRm9udDtcblxuICBpZiAoaG9zdEVsLl9fc3R5bGVGb250ICE9PSBzdHlsZUZvbnQpIHtcbiAgICBob3N0RWwuX19zdHlsZUZvbnQgPSBzdHlsZUZvbnQ7XG4gICAgY29tcHV0ZWRGb250ID0gaG9zdEVsLl9fY29tcHV0ZWRGb250ID0gY3R4LmZvbnQ7XG4gIH1cblxuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRleHRMaW5lSGVpZ2h0ID0gc3R5bGUudGV4dExpbmVIZWlnaHQ7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHlUZXh0KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgY29tcHV0ZWRGb250LCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKF90bXBCb3hQb3NpdGlvblJlc3VsdCwgaG9zdEVsLCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB0ZXh0WCA9IGJhc2VYO1xuICB2YXIgdGV4dFkgPSBib3hZO1xuXG4gIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxsIGdldFRleHRXaWR0aCB1dGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dCwgY29tcHV0ZWRGb250KTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0ZXh0UGFkZGluZyAmJiAob3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdKTtcbiAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHRleHRYID0gZ2V0VGV4dFhGb3JQYWRkaW5nKGJhc2VYLCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgIHRleHRZICs9IHRleHRQYWRkaW5nWzBdO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IHRleHRBbGlnbiBhbmQgdGV4dEJhc2UgbGluZSwgYmVjYXVzZSBpdCBpcyBkaWZmaWN1dGUgdG8gY2FsY3VsYXRlXG4gIC8vIHRleHRBbGlnbiBmcm9tIHByZXZFbCwgYW5kIHdlIGRvbnQgc3VyZSB3aGV0aGVyIHRleHRBbGlnbiB3aWxsIGJlIHJlc2V0IGlmXG4gIC8vIGZvbnQgc2V0IGhhcHBlbmVkLlxuXG5cbiAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJzsgLy8gU2V0IHRleHQgb3BhY2l0eVxuXG4gIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgfHwgMTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgU0hBRE9XX1NUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wSXRlbSA9IFNIQURPV19TVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgdmFyIHN0eWxlUHJvcCA9IHByb3BJdGVtWzBdO1xuICAgIHZhciBjdHhQcm9wID0gcHJvcEl0ZW1bMV07XG4gICAgdmFyIHZhbCA9IHN0eWxlW3N0eWxlUHJvcF07XG5cbiAgICBpZiAoIWNoZWNrQ2FjaGUgfHwgdmFsICE9PSBwcmV2U3R5bGVbc3R5bGVQcm9wXSkge1xuICAgICAgY3R4W2N0eFByb3BdID0gZml4U2hhZG93KGN0eCwgY3R4UHJvcCwgdmFsIHx8IHByb3BJdGVtWzJdKTtcbiAgICB9XG4gIH0gLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGhQcmV2ID0gY2hlY2tDYWNoZSA/IHByZXZTdHlsZS50ZXh0U3Ryb2tlV2lkdGggOiBudWxsO1xuICB2YXIgc3Ryb2tlV2lkdGhDaGFuZ2VkID0gIWNoZWNrQ2FjaGUgfHwgdGV4dFN0cm9rZVdpZHRoICE9PSB0ZXh0U3Ryb2tlV2lkdGhQcmV2O1xuICB2YXIgc3Ryb2tlQ2hhbmdlZCA9ICFjaGVja0NhY2hlIHx8IHN0cm9rZVdpZHRoQ2hhbmdlZCB8fCBzdHlsZS50ZXh0U3Ryb2tlICE9PSBwcmV2U3R5bGUudGV4dFN0cm9rZTtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbChzdHlsZS50ZXh0RmlsbCk7XG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBpZiAoc3Ryb2tlV2lkdGhDaGFuZ2VkKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGV4dFN0cm9rZVdpZHRoO1xuICAgIH1cblxuICAgIGlmIChzdHJva2VDaGFuZ2VkKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIGlmICghY2hlY2tDYWNoZSB8fCBzdHlsZS50ZXh0RmlsbCAhPT0gcHJldlN0eWxlLnRleHRGaWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgfVxuICB9IC8vIE9wdGltaXplIHNpbXBseSwgaW4gbW9zdCBjYXNlcyBvbmx5IG9uZSBsaW5lIGV4aXN0cy5cblxuXG4gIGlmICh0ZXh0TGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1swXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzWzBdLCB0ZXh0WCwgdGV4dFkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIHtcbiAgLy8gRG8gbm90IGRvIGNhY2hlIGZvciByaWNoIHRleHQgYmVjYXVzZSBvZiB0aGUgY29tcGxleGl0eS5cbiAgLy8gQnV0IGBSZWN0VGV4dGAgdGhpcyB3aWxsIGJlIHJlc3RvcmVkLCBkbyBub3QgbmVlZCB0byBjbGVhciBvdGhlciBjYWNoZSBsaWtlIGBTdHlsZTo6YmluZGAuXG4gIGlmIChwcmV2RWwgIT09IFdJTExfQkVfUkVTVE9SRUQpIHtcbiAgICBjdHguX19hdHRyQ2FjaGVkQnkgPSBDb250ZXh0Q2FjaGVkQnkuTk9ORTtcbiAgfVxuXG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHlUZXh0KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gIH1cblxuICBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKF90bXBCb3hQb3NpdGlvblJlc3VsdCwgaG9zdEVsLCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHhMZWZ0ID0gYm94WDtcbiAgdmFyIGxpbmVUb3AgPSBib3hZO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHhMZWZ0ICs9IHRleHRQYWRkaW5nWzNdO1xuICAgIGxpbmVUb3AgKz0gdGV4dFBhZGRpbmdbMF07XG4gIH1cblxuICB2YXIgeFJpZ2h0ID0geExlZnQgKyBjb250ZW50V2lkdGg7XG4gIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGNvbnRlbnRCbG9jay5saW5lc1tpXTtcbiAgICB2YXIgdG9rZW5zID0gbGluZS50b2tlbnM7XG4gICAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZS5saW5lSGVpZ2h0O1xuICAgIHZhciB1c2VkV2lkdGggPSBsaW5lLndpZHRoO1xuICAgIHZhciBsZWZ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lWExlZnQgPSB4TGVmdDtcbiAgICB2YXIgbGluZVhSaWdodCA9IHhSaWdodDtcbiAgICB2YXIgcmlnaHRJbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgIHZhciB0b2tlbjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPCB0b2tlbkNvdW50ICYmICh0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdLCAhdG9rZW4udGV4dEFsaWduIHx8IHRva2VuLnRleHRBbGlnbiA9PT0gJ2xlZnQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQsICdsZWZ0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICB3aGlsZSAocmlnaHRJbmRleCA+PSAwICYmICh0b2tlbiA9IHRva2Vuc1tyaWdodEluZGV4XSwgdG9rZW4udGV4dEFsaWduID09PSAncmlnaHQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWFJpZ2h0LCAncmlnaHQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYUmlnaHQgLT0gdG9rZW4ud2lkdGg7XG4gICAgICByaWdodEluZGV4LS07XG4gICAgfSAvLyBUaGUgb3RoZXIgdG9rZW5zIGFyZSBwbGFjZWQgYXMgdGV4dEFsaWduICdjZW50ZXInIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZS5cblxuXG4gICAgbGluZVhMZWZ0ICs9IChjb250ZW50V2lkdGggLSAobGluZVhMZWZ0IC0geExlZnQpIC0gKHhSaWdodCAtIGxpbmVYUmlnaHQpIC0gdXNlZFdpZHRoKSAvIDI7XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDw9IHJpZ2h0SW5kZXgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF07IC8vIENvbnNpZGVyIHdpZHRoIHNwZWNpZmllZCBieSB1c2VyLCB1c2UgJ2NlbnRlcicgcmF0aGVyIHRoYW4gJ2xlZnQnLlxuXG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCArIHRva2VuLndpZHRoIC8gMiwgJ2NlbnRlcicpO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIHgsIHkpIHtcbiAgLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG4gIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgIHZhciBvcmlnaW4gPSBzdHlsZS50ZXh0T3JpZ2luO1xuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgIHkgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW4pIHtcbiAgICAgIHggPSBvcmlnaW5bMF0gKyByZWN0Lng7XG4gICAgICB5ID0gb3JpZ2luWzFdICsgcmVjdC55O1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7IC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG5cbiAgICBjdHgucm90YXRlKC1zdHlsZS50ZXh0Um90YXRpb24pO1xuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIHgsIHRleHRBbGlnbikge1xuICB2YXIgdG9rZW5TdHlsZSA9IHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTtcbiAgdG9rZW5TdHlsZS50ZXh0ID0gdG9rZW4udGV4dDsgLy8gJ2N0eC50ZXh0QmFzZWxpbmUnIGlzIGFsd2F5cyBzZXQgYXMgJ21pZGRsZScsIGZvciBzYWtlIG9mXG4gIC8vIHRoZSBiaWFzIG9mIFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW4udGV4dFZlcnRpY2FsQWxpZ247XG4gIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuXG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ID0gbGluZVRvcCArIHRva2VuLmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC0gdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfVxuXG4gICF0b2tlbi5pc0xpbmVIb2xkZXIgJiYgbmVlZERyYXdCYWNrZ3JvdW5kKHRva2VuU3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCB0b2tlblN0eWxlLCB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdG9rZW4ud2lkdGggOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCAtIHRva2VuLndpZHRoIC8gMiA6IHgsIHkgLSB0b2tlbi5oZWlnaHQgLyAyLCB0b2tlbi53aWR0aCwgdG9rZW4uaGVpZ2h0KTtcbiAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmc7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeCA9IGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICB5IC09IHRva2VuLmhlaWdodCAvIDIgLSB0ZXh0UGFkZGluZ1syXSAtIHRva2VuLnRleHRIZWlnaHQgLyAyO1xuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93Qmx1ciwgc3R5bGUudGV4dFNoYWRvd0JsdXIsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgdG9rZW5TdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgMCkpO1xuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gIHNldEN0eChjdHgsICdmb250JywgdG9rZW4uZm9udCB8fCBERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZSh0b2tlblN0eWxlLnRleHRTdHJva2UgfHwgc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbCh0b2tlblN0eWxlLnRleHRGaWxsIHx8IHN0eWxlLnRleHRGaWxsKTtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTsgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICAgIGN0eC5zdHJva2VUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgICBjdHguZmlsbFRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSB7XG4gIHJldHVybiAhIShzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IpO1xufSAvLyBzdHlsZToge3RleHRCYWNrZ3JvdW5kQ29sb3IsIHRleHRCb3JkZXJXaWR0aCwgdGV4dEJvcmRlckNvbG9yLCB0ZXh0Qm9yZGVyUmFkaXVzLCB0ZXh0fVxuLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuXG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHZhciBpc1BsYWluQmcgPSBpc1N0cmluZyh0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dEJveFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gIGlmIChpc1BsYWluQmcgfHwgdGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG5cbiAgICBpZiAoIXRleHRCb3JkZXJSYWRpdXMpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cblxuICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKHN0eWxlLmZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgIHZhciBvcmlnaW5hbEdsb2JhbEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUuZmlsbE9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsR2xvYmFsQWxwaGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG5cbiAgICBpZiAoc3R5bGUuc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICB2YXIgb3JpZ2luYWxHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLnN0cm9rZU9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxHbG9iYWxBbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkJnSW1hZ2VMb2FkZWQoaW1hZ2UsIHRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgLy8gUmVwbGFjZSBpbWFnZSwgc28gdGhhdCBgY29udGFpbi90ZXh0LmpzI3BhcnNlUmljaFRleHRgXG4gIC8vIHdpbGwgZ2V0IGNvcnJlY3QgcmVzdWx0IGluIG5leHQgdGljay5cbiAgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZSA9IGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hQb3NpdGlvbihvdXQsIGhvc3RFbCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgaWYgKHJlY3QpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuXG4gICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBQZXJjZW50XG4gICAgICBiYXNlWCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgYmFzZVkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSBob3N0RWwgJiYgaG9zdEVsLmNhbGN1bGF0ZVRleHRQb3NpdGlvbiA/IGhvc3RFbC5jYWxjdWxhdGVUZXh0UG9zaXRpb24oX3RtcFRleHRQb3NpdGlvblJlc3VsdCwgc3R5bGUsIHJlY3QpIDogdGV4dENvbnRhaW4uY2FsY3VsYXRlVGV4dFBvc2l0aW9uKF90bXBUZXh0UG9zaXRpb25SZXN1bHQsIHN0eWxlLCByZWN0KTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICBvdXQgPSBvdXQgfHwge307XG4gIG91dC5iYXNlWCA9IGJhc2VYO1xuICBvdXQuYmFzZVkgPSBiYXNlWTtcbiAgb3V0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgb3V0LnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ247XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIGN0eFtwcm9wXSA9IGZpeFNoYWRvdyhjdHgsIHByb3AsIHZhbHVlKTtcbiAgcmV0dXJuIGN0eFtwcm9wXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJva2VdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHlsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3Ryb2tlKHN0cm9rZSwgbGluZVdpZHRoKSB7XG4gIHJldHVybiBzdHJva2UgPT0gbnVsbCB8fCBsaW5lV2lkdGggPD0gMCB8fCBzdHJva2UgPT09ICd0cmFuc3BhcmVudCcgfHwgc3Ryb2tlID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzID8gJyMwMDAnIDogc3Ryb2tlO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsKGZpbGwpIHtcbiAgcmV0dXJuIGZpbGwgPT0gbnVsbCB8fCBmaWxsID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogZmlsbC5pbWFnZSB8fCBmaWxsLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBmaWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkge1xuICByZXR1cm4gdGV4dCAhPSBudWxsICYmICh0ZXh0IHx8IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvciB8fCBzdHlsZS50ZXh0UGFkZGluZyk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVGV4dFN0eWxlID0gbm9ybWFsaXplVGV4dFN0eWxlO1xuZXhwb3J0cy5yZW5kZXJUZXh0ID0gcmVuZGVyVGV4dDtcbmV4cG9ydHMuZ2V0Qm94UG9zaXRpb24gPSBnZXRCb3hQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0U3Ryb2tlID0gZ2V0U3Ryb2tlO1xuZXhwb3J0cy5nZXRGaWxsID0gZ2V0RmlsbDtcbmV4cG9ydHMucGFyc2VQZXJjZW50ID0gcGFyc2VQZXJjZW50O1xuZXhwb3J0cy5uZWVkRHJhd1RleHQgPSBuZWVkRHJhd1RleHQ7IiwidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfY29uc3RhbnQgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRcIik7XG5cbnZhciBXSUxMX0JFX1JFU1RPUkVEID0gX2NvbnN0YW50LldJTExfQkVfUkVTVE9SRUQ7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcbiAgICAvLyBEbyBub3QgcHJvdmlkZSBwcmV2RWwgdG8gYHRleHRIZWxwZXIucmVuZGVyVGV4dGAgZm9yIGN0eCBwcm9wIGNhY2hlLFxuICAgIC8vIGJ1dCB1c2UgYGN0eC5zYXZlKClgIGFuZCBgY3R4LnJlc3RvcmUoKWAuIEJlY2F1c2UgdGhlIGNhY2hlIGZvciByZWN0XG4gICAgLy8gdGV4dCBwcm9wYWJseSBicmVhayB0aGUgY2FjaGUgZm9yIGl0cyBob3N0IGVsZW1lbnRzLlxuXG5cbiAgICBjdHguc2F2ZSgpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIXN0eWxlLnRyYW5zZm9ybVRleHQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIH0gLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG5cbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCwgV0lMTF9CRV9SRVNUT1JFRCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlY3RUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2FyYycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gX2N1cnZlLnF1YWRyYXRpY1N1YmRpdmlkZTtcbnZhciBjdWJpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5jdWJpY1N1YmRpdmlkZTtcbnZhciBxdWFkcmF0aWNBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNBdDtcbnZhciBjdWJpY0F0ID0gX2N1cnZlLmN1YmljQXQ7XG52YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gX2N1cnZlLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbnZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5jdWJpY0Rlcml2YXRpdmVBdDtcblxuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9CZXppZXJDdXJ2ZVxuICovXG52YXIgb3V0ID0gW107XG5cbmZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XG4gIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuXG4gIGlmIChjcHgyID09PSBudWxsIHx8IGNweTIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgyLCBzaGFwZS54MiwgdCksIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdCldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdCldO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2Jlemllci1jdXJ2ZScsXG4gIHNoYXBlOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgY3B4MTogMCxcbiAgICBjcHkxOiAwLFxuICAgIC8vIGNweDI6IDAsXG4gICAgLy8gY3B5MjogMFxuICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XG4gICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xuICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZSh4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeTEsIGNweTEsIHkyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgIH1cblxuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3B4MSwgY3B5MSwgeDIsIHkyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgIGN1YmljU3ViZGl2aWRlKHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgIGN1YmljU3ViZGl2aWRlKHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNweDEsIGNweTEsIGNweDIsIGNweTIsIHgyLCB5Mik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcbiAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NpcmNsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgfSAvLyBlbHNlIHtcbiAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuXG5cbiAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOawtOa7tOW9oueKtlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvRHJvcGxldFxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdkcm9wbGV0JyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgYSA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBiID0gc2hhcGUuaGVpZ2h0O1xuICAgIGN0eC5tb3ZlVG8oeCwgeSArIGEpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBhLCB5ICsgYSwgeCArIGEgKiAzIC8gMiwgeSAtIGEgLyAzLCB4LCB5IC0gYik7XG4gICAgY3R4LmJlemllckN1cnZlVG8oeCAtIGEgKiAzIC8gMiwgeSAtIGEgLyAzLCB4IC0gYSwgeSArIGEsIHgsIHkgKyBhKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5qSt5ZyG5b2i54q2XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9FbGxpcHNlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VsbGlwc2UnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHJ4OiAwLFxuICAgIHJ5OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgayA9IDAuNTUyMjg0ODtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIGEgPSBzaGFwZS5yeDtcbiAgICB2YXIgYiA9IHNoYXBlLnJ5O1xuICAgIHZhciBveCA9IGEgKiBrOyAvLyDmsLTlubPmjqfliLbngrnlgY/np7vph49cblxuICAgIHZhciBveSA9IGIgKiBrOyAvLyDlnoLnm7TmjqfliLbngrnlgY/np7vph49cbiAgICAvLyDku47mpK3lnIbnmoTlt6bnq6/ngrnlvIDlp4vpobrml7bpkojnu5jliLblm5vmnaHkuInmrKHotJ3loZ7lsJTmm7Lnur9cblxuICAgIGN0eC5tb3ZlVG8oeCAtIGEsIHkpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBhLCB5IC0gb3ksIHggLSBveCwgeSAtIGIsIHgsIHkgLSBiKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgb3gsIHkgLSBiLCB4ICsgYSwgeSAtIG95LCB4ICsgYSwgeSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8oeCArIGEsIHkgKyBveSwgeCArIG94LCB5ICsgYiwgeCwgeSArIGIpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBveCwgeSArIGIsIHggLSBhLCB5ICsgb3ksIHggLSBhLCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5b+D5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9IZWFydFxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdoZWFydCcsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIGEgPSBzaGFwZS53aWR0aDtcbiAgICB2YXIgYiA9IHNoYXBlLmhlaWdodDtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBhIC8gMiwgeSAtIGIgKiAyIC8gMywgeCArIGEgKiAyLCB5ICsgYiAvIDMsIHgsIHkgKyBiKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyh4IC0gYSAqIDIsIHkgKyBiIC8gMywgeCAtIGEgLyAyLCB5IC0gYiAqIDIgLyAzLCB4LCB5KTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDmraPlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Jc29nb25cbiAqL1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBjb3MgPSBNYXRoLmNvcztcblxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnaXNvZ29uJyxcbiAgc2hhcGU6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgcjogMCxcbiAgICBuOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgbiA9IHNoYXBlLm47XG5cbiAgICBpZiAoIW4gfHwgbiA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciByID0gc2hhcGUucjtcbiAgICB2YXIgZFN0ZXAgPSAyICogUEkgLyBuO1xuICAgIHZhciBkZWcgPSAtUEkgLyAyO1xuICAgIGN0eC5tb3ZlVG8oeCArIHIgKiBjb3MoZGVnKSwgeSArIHIgKiBzaW4oZGVnKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gbiAtIDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgZGVnICs9IGRTdGVwO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgciAqIGNvcyhkZWcpLCB5ICsgciAqIHNpbihkZWcpKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgX3N1YlBpeGVsT3B0aW1pemUgPSByZXF1aXJlKFwiLi4vaGVscGVyL3N1YlBpeGVsT3B0aW1pemVcIik7XG5cbnZhciBzdWJQaXhlbE9wdGltaXplTGluZSA9IF9zdWJQaXhlbE9wdGltaXplLnN1YlBpeGVsT3B0aW1pemVMaW5lO1xuXG4vKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG4vLyBBdm9pZCBjcmVhdGUgcmVwZWF0bHkuXG52YXIgc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlID0ge307XG5cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2xpbmUnLFxuICBzaGFwZToge1xuICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgLy8gRW5kIHBvaW50XG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MTtcbiAgICB2YXIgeTE7XG4gICAgdmFyIHgyO1xuICAgIHZhciB5MjtcblxuICAgIGlmICh0aGlzLnN1YlBpeGVsT3B0aW1pemUpIHtcbiAgICAgIHN1YlBpeGVsT3B0aW1pemVMaW5lKHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZSwgc2hhcGUsIHRoaXMuc3R5bGUpO1xuICAgICAgeDEgPSBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUueDE7XG4gICAgICB5MSA9IHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZS55MTtcbiAgICAgIHgyID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLngyO1xuICAgICAgeTIgPSBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUueTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxID0gc2hhcGUueDE7XG4gICAgICB5MSA9IHNoYXBlLnkxO1xuICAgICAgeDIgPSBzaGFwZS54MjtcbiAgICAgIHkyID0gc2hhcGUueTI7XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgcmV0dXJuIFtzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcF07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9yb3VuZFJlY3RcIik7XG5cbnZhciBfc3ViUGl4ZWxPcHRpbWl6ZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvc3ViUGl4ZWxPcHRpbWl6ZVwiKTtcblxudmFyIHN1YlBpeGVsT3B0aW1pemVSZWN0ID0gX3N1YlBpeGVsT3B0aW1pemUuc3ViUGl4ZWxPcHRpbWl6ZVJlY3Q7XG5cbi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cbi8vIEF2b2lkIGNyZWF0ZSByZXBlYXRseS5cbnZhciBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUgPSB7fTtcblxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncmVjdCcsXG4gIHNoYXBlOiB7XG4gICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICByOiAwLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciB3aWR0aDtcbiAgICB2YXIgaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuc3ViUGl4ZWxPcHRpbWl6ZSkge1xuICAgICAgc3ViUGl4ZWxPcHRpbWl6ZVJlY3Qoc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLCBzaGFwZSwgdGhpcy5zdHlsZSk7XG4gICAgICB4ID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLng7XG4gICAgICB5ID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLnk7XG4gICAgICB3aWR0aCA9IHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZS53aWR0aDtcbiAgICAgIGhlaWdodCA9IHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZS5oZWlnaHQ7XG4gICAgICBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUuciA9IHNoYXBlLnI7XG4gICAgICBzaGFwZSA9IHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHNoYXBlLng7XG4gICAgICB5ID0gc2hhcGUueTtcbiAgICAgIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyaW5nJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHIwOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog546r55Gw57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Sb3NlXG4gKi9cbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciByYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyb3NlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiBbXSxcbiAgICBrOiAwLFxuICAgIG46IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgUiA9IHNoYXBlLnI7XG4gICAgdmFyIHI7XG4gICAgdmFyIGsgPSBzaGFwZS5rO1xuICAgIHZhciBuID0gc2hhcGUubjtcbiAgICB2YXIgeDAgPSBzaGFwZS5jeDtcbiAgICB2YXIgeTAgPSBzaGFwZS5jeTtcbiAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgciA9IFJbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDM2MCAqIG47IGorKykge1xuICAgICAgICB4ID0gciAqIHNpbihrIC8gbiAqIGogJSAzNjAgKiByYWRpYW4pICogY29zKGogKiByYWRpYW4pICsgeDA7XG4gICAgICAgIHkgPSByICogc2luKGsgLyBuICogaiAlIDM2MCAqIHJhZGlhbikgKiBzaW4oaiAqIHJhZGlhbikgKyB5MDtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiBu6KeS5pif77yIbj4z77yJXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TdGFyXG4gKi9cbnZhciBQSSA9IE1hdGguUEk7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc2luID0gTWF0aC5zaW47XG5cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3N0YXInLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIG46IDMsXG4gICAgcjA6IG51bGwsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIG4gPSBzaGFwZS5uO1xuXG4gICAgaWYgKCFuIHx8IG4gPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByID0gc2hhcGUucjtcbiAgICB2YXIgcjAgPSBzaGFwZS5yMDsgLy8g5aaC5p6c5pyq5oyH5a6a5YaF6YOo6aG254K55aSW5o6l5ZyG5Y2K5b6E77yM5YiZ6Ieq5Yqo6K6h566XXG5cbiAgICBpZiAocjAgPT0gbnVsbCkge1xuICAgICAgcjAgPSBuID4gNCAvLyDnm7jpmpTnmoTlpJbpg6jpobbngrnnmoTov57nur/nmoTkuqTngrnvvIxcbiAgICAgIC8vIOiiq+WPluS4uuWGhemDqOS6pOeCue+8jOS7peatpOiuoeeul3IwXG4gICAgICA/IHIgKiBjb3MoMiAqIFBJIC8gbikgLyBjb3MoUEkgLyBuKSAvLyDkuozkuInlm5vop5LmmJ/nmoTnibnmrorlpITnkIZcbiAgICAgIDogciAvIDM7XG4gICAgfVxuXG4gICAgdmFyIGRTdGVwID0gUEkgLyBuO1xuICAgIHZhciBkZWcgPSAtUEkgLyAyO1xuICAgIHZhciB4U3RhcnQgPSB4ICsgciAqIGNvcyhkZWcpO1xuICAgIHZhciB5U3RhcnQgPSB5ICsgciAqIHNpbihkZWcpO1xuICAgIGRlZyArPSBkU3RlcDsgLy8g6K6w5b2V6L6555WM54K577yM55So5LqO5Yik5pataW5zaWRlXG5cbiAgICBjdHgubW92ZVRvKHhTdGFydCwgeVN0YXJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuICogMiAtIDEsIHJpOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHJpID0gaSAlIDIgPT09IDAgPyByMCA6IHI7XG4gICAgICBjdHgubGluZVRvKHggKyByaSAqIGNvcyhkZWcpLCB5ICsgcmkgKiBzaW4oZGVnKSk7XG4gICAgICBkZWcgKz0gZFN0ZXA7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWGheWkluaXi+i9ruabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvVHJvY2hvbGRcbiAqL1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICd0cm9jaG9pZCcsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICByMDogMCxcbiAgICBkOiAwLFxuICAgIGxvY2F0aW9uOiAnb3V0J1xuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MTtcbiAgICB2YXIgeTE7XG4gICAgdmFyIHgyO1xuICAgIHZhciB5MjtcbiAgICB2YXIgUiA9IHNoYXBlLnI7XG4gICAgdmFyIHIgPSBzaGFwZS5yMDtcbiAgICB2YXIgZCA9IHNoYXBlLmQ7XG4gICAgdmFyIG9mZnNldFggPSBzaGFwZS5jeDtcbiAgICB2YXIgb2Zmc2V0WSA9IHNoYXBlLmN5O1xuICAgIHZhciBkZWx0YSA9IHNoYXBlLmxvY2F0aW9uID09PSAnb3V0JyA/IDEgOiAtMTtcblxuICAgIGlmIChzaGFwZS5sb2NhdGlvbiAmJiBSIDw9IHIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtID0gMDtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHRoZXRhO1xuICAgIHgxID0gKFIgKyBkZWx0YSAqIHIpICogY29zKDApIC0gZGVsdGEgKiBkICogY29zKDApICsgb2Zmc2V0WDtcbiAgICB5MSA9IChSICsgZGVsdGEgKiByKSAqIHNpbigwKSAtIGQgKiBzaW4oMCkgKyBvZmZzZXRZO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTsgLy8g6K6h566X57uT5p2f5pe255qEaVxuXG4gICAgZG8ge1xuICAgICAgbnVtKys7XG4gICAgfSB3aGlsZSAociAqIG51bSAlIChSICsgZGVsdGEgKiByKSAhPT0gMCk7XG5cbiAgICBkbyB7XG4gICAgICB0aGV0YSA9IE1hdGguUEkgLyAxODAgKiBpO1xuICAgICAgeDIgPSAoUiArIGRlbHRhICogcikgKiBjb3ModGhldGEpIC0gZGVsdGEgKiBkICogY29zKChSIC8gciArIGRlbHRhKSAqIHRoZXRhKSArIG9mZnNldFg7XG4gICAgICB5MiA9IChSICsgZGVsdGEgKiByKSAqIHNpbih0aGV0YSkgLSBkICogc2luKChSIC8gciArIGRlbHRhKSAqIHRoZXRhKSArIG9mZnNldFk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICBpKys7XG4gICAgfSB3aGlsZSAoaSA8PSByICogbnVtIC8gKFIgKyBkZWx0YSAqIHIpICogMzYwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwidmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4uL2FuaW1hdGlvbi9BbmltYXRvclwiKTtcblxudmFyIGxvZ0Vycm9yID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gX3V0aWwuaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xufTtcblxuQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gIC8qKlxuICAgKiDliqjnlLtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZmV0Y2ggdmFsdWUgZnJvbSBvYmplY3QsIGxpa2UgJ2EuYi5jJy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKiBAZXhhbXBsZTpcbiAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICogICAgICAgICAuc3RhcnQoKVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgIHZhciBlbCA9IHRoaXM7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcHJvcCA9IGVsOyAvLyBJZiBhbmltYXRpbmcgc2hhcGVcblxuICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGVsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICBsb2dFcnJvcignUHJvcGVydHkgXCInICsgcGF0aCArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICcgKyBlbC5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcbiAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICBhbmltYXRvcnMuc3BsaWNlKGluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgIH0pO1xuICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTsgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuXG4gICAgaWYgKHpyKSB7XG4gICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAqIFNvIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gICAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmb3JjZUFuaW1hdGVdIFByZXZlbnQgc3RvcCBhbmltYXRpb24gYW5kIGNhbGxiYWNrXG4gICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICovXG4gIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlKSB7XG4gICAgYW5pbWF0ZVRvKHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgZnJvbSB0aGUgdGFyZ2V0IHN0YXRlIHRvIGN1cnJlbnQgc3RhdGUuXG4gICAqIFRoZSBwYXJhbXMgYW5kIHRoZSByZXR1cm4gdmFsdWUgYXJlIHRoZSBzYW1lIGFzIGB0aGlzLmFuaW1hdGVUb2AuXG4gICAqL1xuICBhbmltYXRlRnJvbTogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSkge1xuICAgIGFuaW1hdGVUbyh0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhbmltYXRlVG8oYW5pbWF0YWJsZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlLCByZXZlcnNlKSB7XG4gIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgZWFzaW5nID0gZGVsYXk7XG4gICAgZGVsYXkgPSAwO1xuICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgIH0gLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuXG5cbiAgYW5pbWF0YWJsZS5zdG9wQW5pbWF0aW9uKCk7XG4gIGFuaW1hdGVUb1NoYWxsb3coYW5pbWF0YWJsZSwgJycsIGFuaW1hdGFibGUsIHRhcmdldCwgdGltZSwgZGVsYXksIHJldmVyc2UpOyAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG5cbiAgdmFyIGFuaW1hdG9ycyA9IGFuaW1hdGFibGUuYW5pbWF0b3JzLnNsaWNlKCk7XG4gIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBjb3VudC0tO1xuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cblxuXG4gIGlmICghY291bnQpIHtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICB9IC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGFuaW1hdG9yc1tpXS5kb25lKGRvbmUpLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT1hbmltYXRhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gSWYgYHRydWVgLCBhbmltYXRlXG4gKiAgICAgICAgZnJvbSB0aGUgYHRhcmdldGAgdG8gY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICogIH0pXG4gKlxuICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAqICAgICAgc2hhcGU6IHtcbiAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAqICAgICAgfSxcbiAqICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gKiAgICAgIH1cbiAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gKiAgfSwgMTAwLCAxMDApXG4gKi9cblxuXG5mdW5jdGlvbiBhbmltYXRlVG9TaGFsbG93KGFuaW1hdGFibGUsIHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSwgcmV2ZXJzZSkge1xuICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICBhbmltYXRlVG9TaGFsbG93KGFuaW1hdGFibGUsIHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsIHNvdXJjZVtuYW1lXSwgdGFyZ2V0W25hbWVdLCB0aW1lLCBkZWxheSwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgICAgICAgc2V0QXR0ckJ5UGF0aChhbmltYXRhYmxlLCBwYXRoLCBuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCAmJiAhcmV2ZXJzZSkge1xuICAgICAgc2V0QXR0ckJ5UGF0aChhbmltYXRhYmxlLCBwYXRoLCBuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgIGFuaW1hdGFibGUuYW5pbWF0ZShwYXRoLCBmYWxzZSkud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KS5kZWxheShkZWxheSB8fCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyQnlQYXRoKGVsLCBwYXRoLCBuYW1lLCB2YWx1ZSkge1xuICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gIGlmICghcGF0aCkge1xuICAgIGVsLmF0dHIobmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBzZXQgc2hhcGUgb3Igc3R5bGVcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgIHByb3BzW3BhdGhdW25hbWVdID0gdmFsdWU7XG4gICAgZWwuYXR0cihwcm9wcyk7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gQW5pbWF0YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5mdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG4gIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIGBtb3N1ZW1vdmVgIGFuZCBgbW91c2V1cGAgY2FuIGJlIGNvbnRpbnVlIHRvIGZpcmUgd2hlbiBkcmFnZ2luZy5cbiAgLy8gU2VlIFtEcmFnIG91dHNpZGVdIGluIGBIYW5kbGVyLmpzYC4gU28gd2UgZG8gbm90IG5lZWQgdG8gdHJpZ2dlclxuICAvLyBgX2RyYWdFbmRgIHdoZW4gZ2xvYmFsb3V0LiBUaGF0IHdvdWxkIGJyaW5ncyBiZXR0ZXIgdXNlciBleHBlcmllbmNlLlxuICAvLyB0aGlzLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgLy8gdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgLy8gdGhpcy5feCA9IDA7XG4gIC8vIHRoaXMuX3kgPSAwO1xufVxuXG5EcmFnZ2FibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRHJhZ2dhYmxlLFxuICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0OyAvLyBGaW5kIGlmIHRoZXJlIGlzIGRyYWdnYWJsZSBpbiB0aGUgYW5jZXN0b3JcblxuICAgIHdoaWxlIChkcmFnZ2luZ1RhcmdldCAmJiAhZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICBkcmFnZ2luZ1RhcmdldCA9IGRyYWdnaW5nVGFyZ2V0LnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwiLyoqXG4gKiBFdmVudCBNaXhpblxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuLyoqXG4gKiBFdmVudCBkaXNwYXRjaGVyLlxuICpcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50UHJvY2Vzc29yXSBUaGUgb2JqZWN0IGV2ZW50UHJvY2Vzc29yIGlzIHRoZSBzY29wZSB3aGVuXG4gKiAgICAgICAgYGV2ZW50UHJvY2Vzc29yLnh4eGAgY2FsbGVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50UHJvY2Vzc29yLm5vcm1hbGl6ZVF1ZXJ5XVxuICogICAgICAgIHBhcmFtOiB7c3RyaW5nfE9iamVjdH0gUmF3IHF1ZXJ5LlxuICogICAgICAgIHJldHVybjoge3N0cmluZ3xPYmplY3R9IE5vcm1hbGl6ZWQgcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRQcm9jZXNzb3IuZmlsdGVyXSBFdmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgb25seVxuICogICAgICAgIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICogICAgICAgIHBhcmFtOiB7c3RyaW5nfSBldmVudFR5cGVcbiAqICAgICAgICBwYXJhbToge3N0cmluZ3xPYmplY3R9IHF1ZXJ5XG4gKiAgICAgICAgcmV0dXJuOiB7Ym9vbGVhbn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudFByb2Nlc3Nvci5hZnRlclRyaWdnZXJdIENhbGxlZCBhZnRlciBhbGwgaGFuZGxlcnMgY2FsbGVkLlxuICogICAgICAgIHBhcmFtOiB7c3RyaW5nfSBldmVudFR5cGVcbiAqL1xuXG52YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoZXZlbnRQcm9jZXNzb3IpIHtcbiAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gIHRoaXMuXyRldmVudFByb2Nlc3NvciA9IGV2ZW50UHJvY2Vzc29yO1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgLyoqXG4gICAqIFRoZSBoYW5kbGVyIGNhbiBvbmx5IGJlIHRyaWdnZXJlZCBvbmNlLCB0aGVuIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcXVlcnldIENvbmRpdGlvbiB1c2VkIG9uIGV2ZW50IGZpbHRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBxdWVyeSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHJldHVybiBvbih0aGlzLCBldmVudCwgcXVlcnksIGhhbmRsZXIsIGNvbnRleHQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGEgaGFuZGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtxdWVyeV0gQ29uZGl0aW9uIHVzZWQgb24gZXZlbnQgZmlsdGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50LCBxdWVyeSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHJldHVybiBvbih0aGlzLCBldmVudCwgcXVlcnksIGhhbmRsZXIsIGNvbnRleHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogV2hldGhlciBhbnkgaGFuZGxlciBoYXMgYm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbGVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgIHJldHVybiAhX2hbZXZlbnRdIHx8ICFfaFtldmVudF0ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQgYSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gICAqICAgICAgICBJZiBubyBgZXZlbnRgIGlucHV0LCBcIm9mZlwiIGFsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICogICAgICAgIElmIG5vIGBoYW5kbGVyYCBpbnB1dCwgXCJvZmZcIiBhbGwgbGlzdGVuZXJzIG9mIHRoZSBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdKSB7XG4gICAgICAgIHZhciBuZXdMaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oICE9PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IG5hbWUuXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICB2YXIgZXZlbnRQcm9jZXNzb3IgPSB0aGlzLl8kZXZlbnRQcm9jZXNzb3I7XG5cbiAgICBpZiAoX2gpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgaEl0ZW0gPSBfaFtpXTtcblxuICAgICAgICBpZiAoZXZlbnRQcm9jZXNzb3IgJiYgZXZlbnRQcm9jZXNzb3IuZmlsdGVyICYmIGhJdGVtLnF1ZXJ5ICE9IG51bGwgJiYgIWV2ZW50UHJvY2Vzc29yLmZpbHRlcih0eXBlLCBoSXRlbS5xdWVyeSkpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcblxuXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaEl0ZW0uaC5jYWxsKGhJdGVtLmN0eCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhJdGVtLmguY2FsbChoSXRlbS5jdHgsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBoSXRlbS5oLmNhbGwoaEl0ZW0uY3R4LCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBoSXRlbS5oLmFwcGx5KGhJdGVtLmN0eCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoSXRlbS5vbmUpIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBldmVudFByb2Nlc3NvciAmJiBldmVudFByb2Nlc3Nvci5hZnRlclRyaWdnZXIgJiYgZXZlbnRQcm9jZXNzb3IuYWZ0ZXJUcmlnZ2VyKHR5cGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIGV2ZW50IHdpdGggY29udGV4dCwgd2hpY2ggaXMgc3BlY2lmaWVkIGF0IHRoZSBsYXN0IHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IG5hbWUuXG4gICAqL1xuICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgIHZhciBldmVudFByb2Nlc3NvciA9IHRoaXMuXyRldmVudFByb2Nlc3NvcjtcblxuICAgIGlmIChfaCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIHZhciBoSXRlbSA9IF9oW2ldO1xuXG4gICAgICAgIGlmIChldmVudFByb2Nlc3NvciAmJiBldmVudFByb2Nlc3Nvci5maWx0ZXIgJiYgaEl0ZW0ucXVlcnkgIT0gbnVsbCAmJiAhZXZlbnRQcm9jZXNzb3IuZmlsdGVyKHR5cGUsIGhJdGVtLnF1ZXJ5KSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuXG5cbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBoSXRlbS5oLmNhbGwoY3R4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaEl0ZW0uaC5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGhJdGVtLmguY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIGhJdGVtLmguYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhJdGVtLm9uZSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50UHJvY2Vzc29yICYmIGV2ZW50UHJvY2Vzc29yLmFmdGVyVHJpZ2dlciAmJiBldmVudFByb2Nlc3Nvci5hZnRlclRyaWdnZXIodHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5KGhvc3QsIHF1ZXJ5KSB7XG4gIHZhciBldmVudFByb2Nlc3NvciA9IGhvc3QuXyRldmVudFByb2Nlc3NvcjtcblxuICBpZiAocXVlcnkgIT0gbnVsbCAmJiBldmVudFByb2Nlc3NvciAmJiBldmVudFByb2Nlc3Nvci5ub3JtYWxpemVRdWVyeSkge1xuICAgIHF1ZXJ5ID0gZXZlbnRQcm9jZXNzb3Iubm9ybWFsaXplUXVlcnkocXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5mdW5jdGlvbiBvbihldmVudGZ1bCwgZXZlbnQsIHF1ZXJ5LCBoYW5kbGVyLCBjb250ZXh0LCBpc09uY2UpIHtcbiAgdmFyIF9oID0gZXZlbnRmdWwuXyRoYW5kbGVycztcblxuICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGV4dCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IHF1ZXJ5O1xuICAgIHF1ZXJ5ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnRmdWw7XG4gIH1cblxuICBxdWVyeSA9IG5vcm1hbGl6ZVF1ZXJ5KGV2ZW50ZnVsLCBxdWVyeSk7XG5cbiAgaWYgKCFfaFtldmVudF0pIHtcbiAgICBfaFtldmVudF0gPSBbXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZXZlbnRmdWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdyYXAgPSB7XG4gICAgaDogaGFuZGxlcixcbiAgICBvbmU6IGlzT25jZSxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgY3R4OiBjb250ZXh0IHx8IGV2ZW50ZnVsLFxuICAgIC8vIEZJWE1FXG4gICAgLy8gRG8gbm90IHB1Ymxpc2ggdGhpcyBmZWF0dXJlIHV0aWwgaXQgaXMgcHJvdmVkIHRoYXQgaXQgbWFrZXMgc2Vuc2UuXG4gICAgY2FsbEF0TGFzdDogaGFuZGxlci56ckV2ZW50ZnVsQ2FsbEF0TGFzdFxuICB9O1xuICB2YXIgbGFzdEluZGV4ID0gX2hbZXZlbnRdLmxlbmd0aCAtIDE7XG4gIHZhciBsYXN0V3JhcCA9IF9oW2V2ZW50XVtsYXN0SW5kZXhdO1xuICBsYXN0V3JhcCAmJiBsYXN0V3JhcC5jYWxsQXRMYXN0ID8gX2hbZXZlbnRdLnNwbGljZShsYXN0SW5kZXgsIDAsIHdyYXApIDogX2hbZXZlbnRdLnB1c2god3JhcCk7XG4gIHJldHVybiBldmVudGZ1bDtcbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlIGV2ZW50cyBpbiB6cmVuZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cblxudmFyIF9kZWZhdWx0ID0gRXZlbnRmdWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBtYXRyaXggPSByZXF1aXJlKFwiLi4vY29yZS9tYXRyaXhcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtSWRlbnRpdHkgPSBtYXRyaXguaWRlbnRpdHk7XG52YXIgRVBTSUxPTiA9IDVlLTU7XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307IC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG5cbiAgaWYgKCFvcHRzLnBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICog5bmz56e7XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBbMCwgMF07XG4gIH1cblxuICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgLyoqXG4gICAgICog5peL6L2sXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgfVxuXG4gIGlmICghb3B0cy5zY2FsZSkge1xuICAgIC8qKlxuICAgICAqIOe8qeaUvlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICB9XG4gIC8qKlxuICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuXG5cbiAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xufTtcblxudmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG4vKipcbiAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICog5aaC5p6c5pyJ5Z2Q5qCH5Y+Y5o2iLCDliJnku45wb3NpdGlvbiwgcm90YXRpb24sIHNjYWxl5Lul5Y+K54i26IqC54K555qEdHJhbnNmb3Jt6K6h566X5Ye66Ieq6Lqr55qEdHJhbnNmb3Jt55+p6Zi1XG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzTm90QXJvdW5kWmVybyh0aGlzLnJvdGF0aW9uKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzBdIC0gMSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbn07XG5cbnZhciBzY2FsZVRtcCA9IFtdO1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH0gZWxzZSB7XG4gICAgbUlkZW50aXR5KG0pO1xuICB9IC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuXG5cbiAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcblxuXG4gIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgdmFyIGdsb2JhbFNjYWxlUmF0aW8gPSB0aGlzLmdsb2JhbFNjYWxlUmF0aW87XG5cbiAgaWYgKGdsb2JhbFNjYWxlUmF0aW8gIT0gbnVsbCAmJiBnbG9iYWxTY2FsZVJhdGlvICE9PSAxKSB7XG4gICAgdGhpcy5nZXRHbG9iYWxTY2FsZShzY2FsZVRtcCk7XG4gICAgdmFyIHJlbFggPSBzY2FsZVRtcFswXSA8IDAgPyAtMSA6IDE7XG4gICAgdmFyIHJlbFkgPSBzY2FsZVRtcFsxXSA8IDAgPyAtMSA6IDE7XG4gICAgdmFyIHN4ID0gKChzY2FsZVRtcFswXSAtIHJlbFgpICogZ2xvYmFsU2NhbGVSYXRpbyArIHJlbFgpIC8gc2NhbGVUbXBbMF0gfHwgMDtcbiAgICB2YXIgc3kgPSAoKHNjYWxlVG1wWzFdIC0gcmVsWSkgKiBnbG9iYWxTY2FsZVJhdGlvICsgcmVsWSkgLyBzY2FsZVRtcFsxXSB8fCAwO1xuICAgIG1bMF0gKj0gc3g7XG4gICAgbVsxXSAqPSBzeDtcbiAgICBtWzJdICo9IHN5O1xuICAgIG1bM10gKj0gc3k7XG4gIH1cblxuICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICByZXR1cm4gVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSh0aGlzLCBtKTtcbn07XG4vKipcbiAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG5cbiAgaWYgKG0pIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciAqIG1bMF0sIGRwciAqIG1bMV0sIGRwciAqIG1bMl0sIGRwciAqIG1bM10sIGRwciAqIG1bNF0sIGRwciAqIG1bNV0pO1xuICB9IGVsc2Uge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICB9XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ucmVzdG9yZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG59O1xuXG52YXIgdG1wVHJhbnNmb3JtID0gW107XG52YXIgb3JpZ2luVHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICBpZiAoIW0pIHtcbiAgICAvLyBUT0RPIHJldHVybiBvciBzZXQgaWRlbnRpdHk/XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gIH1cblxuICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gIH1cblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICBwb3NpdGlvblsxXSA9IG1bNV07XG4gIHNjYWxlWzBdID0gc3g7XG4gIHNjYWxlWzFdID0gc3k7XG4gIHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG59O1xuLyoqXG4gKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50cmFuc2Zvcm0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtKSB7XG4gICAgLy8gR2V0IGxvY2FsIHRyYW5zZm9ybSBhbmQgZGVjb21wb3NlIHRoZW0gdG8gcG9zaXRpb24sIHNjYWxlLCByb3RhdGlvblxuICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICBtID0gdG1wVHJhbnNmb3JtO1xuICB9XG5cbiAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gIGlmIChvcmlnaW4gJiYgKG9yaWdpblswXSB8fCBvcmlnaW5bMV0pKSB7XG4gICAgb3JpZ2luVHJhbnNmb3JtWzRdID0gb3JpZ2luWzBdO1xuICAgIG9yaWdpblRyYW5zZm9ybVs1XSA9IG9yaWdpblsxXTtcbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgbSwgb3JpZ2luVHJhbnNmb3JtKTtcbiAgICB0bXBUcmFuc2Zvcm1bNF0gLT0gb3JpZ2luWzBdO1xuICAgIHRtcFRyYW5zZm9ybVs1XSAtPSBvcmlnaW5bMV07XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHRoaXMuc2V0TG9jYWxUcmFuc2Zvcm0obSk7XG59O1xuLyoqXG4gKiBHZXQgZ2xvYmFsIHNjYWxlXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gIGlmICghbSkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgb3V0WzBdID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICBvdXRbMV0gPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgb3V0WzBdID0gLW91dFswXTtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIG91dFsxXSA9IC1vdXRbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcblxuICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5cblxuVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgbSA9IG0gfHwgW107XG4gIG1JZGVudGl0eShtKTtcbiAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gIH1cblxuICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuXG4gIGlmIChyb3RhdGlvbikge1xuICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgbVs1XSArPSBvcmlnaW5bMV07XG4gIH1cblxuICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zZm9ybWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gX2NvcmUuY3JlYXRlRWxlbWVudDtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgbG9nRXJyb3IgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgWlRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9UZXh0XCIpO1xuXG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZShcIi4uL2NvcmUvYXJyYXlEaWZmMlwiKTtcblxudmFyIEdyYWRpZW50TWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9HcmFkaWVudE1hbmFnZXJcIik7XG5cbnZhciBDbGlwcGF0aE1hbmFnZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvQ2xpcHBhdGhNYW5hZ2VyXCIpO1xuXG52YXIgU2hhZG93TWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9TaGFkb3dNYW5hZ2VyXCIpO1xuXG52YXIgX2dyYXBoaWMgPSByZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgc3ZnUGF0aCA9IF9ncmFwaGljLnBhdGg7XG52YXIgc3ZnSW1hZ2UgPSBfZ3JhcGhpYy5pbWFnZTtcbnZhciBzdmdUZXh0ID0gX2dyYXBoaWMudGV4dDtcblxuLyoqXG4gKiBTVkcgUGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL3N2Zy9QYWludGVyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3ZnUHJveHkoZWwpIHtcbiAgaWYgKGVsIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHJldHVybiBzdmdQYXRoO1xuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgWkltYWdlKSB7XG4gICAgcmV0dXJuIHN2Z0ltYWdlO1xuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgWlRleHQpIHtcbiAgICByZXR1cm4gc3ZnVGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3ZnUGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihwYXJlbnQsIGNoaWxkLCBwcmV2U2libGluZykge1xuICBpZiAoY2hlY2tQYXJlbnRBdmFpbGFibGUocGFyZW50LCBjaGlsZCkgJiYgcHJldlNpYmxpbmcpIHtcbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBwcmV2U2libGluZy5uZXh0U2libGluZztcbiAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHRTaWJsaW5nKSA6IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGVuZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSkge1xuICAgIHZhciBmaXJzdENoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGZpcnN0Q2hpbGQpIDogcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufSAvLyBmdW5jdGlvbiBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuLy8gICAgIGlmIChjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSkge1xuLy8gICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuLy8gICAgIH1cbi8vIH1cblxuXG5mdW5jdGlvbiByZW1vdmUocGFyZW50LCBjaGlsZCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFN2Z0VsZW1lbnQoZGlzcGxheWFibGUpIHtcbiAgcmV0dXJuIGRpc3BsYXlhYmxlLl9fdGV4dFN2Z0VsO1xufVxuXG5mdW5jdGlvbiBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKSB7XG4gIHJldHVybiBkaXNwbGF5YWJsZS5fX3N2Z0VsO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc3ZnL1BhaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuXG5cbnZhciBTVkdQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMsIHpySWQpIHtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG4gIHZhciBzdmdEb20gPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgnYmFzZVByb2ZpbGUnLCAnZnVsbCcpO1xuICBzdmdEb20uc3R5bGUuY3NzVGV4dCA9ICd1c2VyLXNlbGVjdDpub25lO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuICB2YXIgYmdSb290ID0gY3JlYXRlRWxlbWVudCgnZycpO1xuICBzdmdEb20uYXBwZW5kQ2hpbGQoYmdSb290KTtcbiAgdmFyIHN2Z1Jvb3QgPSBjcmVhdGVFbGVtZW50KCdnJyk7XG4gIHN2Z0RvbS5hcHBlbmRDaGlsZChzdmdSb290KTtcbiAgdGhpcy5ncmFkaWVudE1hbmFnZXIgPSBuZXcgR3JhZGllbnRNYW5hZ2VyKHpySWQsIHN2Z1Jvb3QpO1xuICB0aGlzLmNsaXBQYXRoTWFuYWdlciA9IG5ldyBDbGlwcGF0aE1hbmFnZXIoenJJZCwgc3ZnUm9vdCk7XG4gIHRoaXMuc2hhZG93TWFuYWdlciA9IG5ldyBTaGFkb3dNYW5hZ2VyKHpySWQsIHN2Z1Jvb3QpO1xuICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmUnO1xuICB0aGlzLl9zdmdEb20gPSBzdmdEb207XG4gIHRoaXMuX3N2Z1Jvb3QgPSBzdmdSb290O1xuICB0aGlzLl9iYWNrZ3JvdW5kUm9vdCA9IGJnUm9vdDtcbiAgdGhpcy5fdmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgcm9vdC5hcHBlbmRDaGlsZCh2aWV3cG9ydCk7XG4gIHZpZXdwb3J0LmFwcGVuZENoaWxkKHN2Z0RvbSk7XG4gIHRoaXMucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgdGhpcy5fdmlzaWJsZUxpc3QgPSBbXTtcbn07XG5cblNWR1BhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU1ZHUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnc3ZnJztcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICB9LFxuICBnZXRTdmdEb206IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ZnRG9tO1xuICB9LFxuICBnZXRTdmdSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z1Jvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gIH0sXG4gIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xuICAgIC8vIFRPRE8gZ3JhZGllbnRcbiAgICAvLyBJbnNlcnQgYSBiZyByZWN0IGluc3RlYWQgb2Ygc2V0dGluZyBiYWNrZ3JvdW5kIHRvIHZpZXdwb3J0LlxuICAgIC8vIE90aGVyd2lzZSwgdGhlIGV4cG9ydGVkIFNWRyBkb24ndCBoYXZlIGJhY2tncm91bmQuXG4gICAgaWYgKHRoaXMuX2JhY2tncm91bmRSb290ICYmIHRoaXMuX2JhY2tncm91bmROb2RlKSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kUm9vdC5yZW1vdmVDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGJnTm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3JlY3QnKTtcbiAgICBiZ05vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgYmdOb2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgYmdOb2RlLnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgIGJnTm9kZS5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICBiZ05vZGUuc2V0QXR0cmlidXRlKCdpZCcsIDApO1xuICAgIGJnTm9kZS5zdHlsZS5maWxsID0gYmFja2dyb3VuZENvbG9yO1xuXG4gICAgdGhpcy5fYmFja2dyb3VuZFJvb3QuYXBwZW5kQ2hpbGQoYmdOb2RlKTtcblxuICAgIHRoaXMuX2JhY2tncm91bmROb2RlID0gYmdOb2RlO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLm1hcmtBbGxVbnVzZWQoKTtcbiAgICB0aGlzLmNsaXBQYXRoTWFuYWdlci5tYXJrQWxsVW51c2VkKCk7XG4gICAgdGhpcy5zaGFkb3dNYW5hZ2VyLm1hcmtBbGxVbnVzZWQoKTtcbiAgICB2YXIgc3ZnUm9vdCA9IHRoaXMuX3N2Z1Jvb3Q7XG4gICAgdmFyIHZpc2libGVMaXN0ID0gdGhpcy5fdmlzaWJsZUxpc3Q7XG4gICAgdmFyIGxpc3RMZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgbmV3VmlzaWJsZUxpc3QgPSBbXTtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0TGVuOyBpKyspIHtcbiAgICAgIHZhciBkaXNwbGF5YWJsZSA9IGxpc3RbaV07XG4gICAgICB2YXIgc3ZnUHJveHkgPSBnZXRTdmdQcm94eShkaXNwbGF5YWJsZSk7XG4gICAgICB2YXIgc3ZnRWxlbWVudCA9IGdldFN2Z0VsZW1lbnQoZGlzcGxheWFibGUpIHx8IGdldFRleHRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcblxuICAgICAgaWYgKCFkaXNwbGF5YWJsZS5pbnZpc2libGUpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlhYmxlLl9fZGlydHkpIHtcbiAgICAgICAgICBzdmdQcm94eSAmJiBzdmdQcm94eS5icnVzaChkaXNwbGF5YWJsZSk7IC8vIFVwZGF0ZSBjbGlwUGF0aFxuXG4gICAgICAgICAgdGhpcy5jbGlwUGF0aE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlKTsgLy8gVXBkYXRlIGdyYWRpZW50IGFuZCBzaGFkb3dcblxuICAgICAgICAgIGlmIChkaXNwbGF5YWJsZS5zdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlLnN0eWxlLmZpbGwpO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlLnN0eWxlLnN0cm9rZSk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd01hbmFnZXIudXBkYXRlKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXNwbGF5YWJsZS5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdWaXNpYmxlTGlzdC5wdXNoKGRpc3BsYXlhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGFycmF5RGlmZih2aXNpYmxlTGlzdCwgbmV3VmlzaWJsZUxpc3QpO1xuICAgIHZhciBwcmV2U3ZnRWxlbWVudDsgLy8gRmlyc3QgZG8gcmVtb3ZlLCBpbiBjYXNlIGVsZW1lbnQgbW92ZWQgdG8gdGhlIGhlYWQgYW5kIGRvIHJlbW92ZVxuICAgIC8vIGFmdGVyIGFkZFxuXG4gICAgZm9yIChpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGlmZltpXTtcblxuICAgICAgaWYgKGl0ZW0ucmVtb3ZlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IHZpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgcmVtb3ZlKHN2Z1Jvb3QsIHN2Z0VsZW1lbnQpO1xuICAgICAgICAgIHJlbW92ZShzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuXG4gICAgICBpZiAoaXRlbS5hZGRlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IG5ld1Zpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgcHJldlN2Z0VsZW1lbnQgPyBpbnNlcnRBZnRlcihzdmdSb290LCBzdmdFbGVtZW50LCBwcmV2U3ZnRWxlbWVudCkgOiBwcmVwZW5kKHN2Z1Jvb3QsIHN2Z0VsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc2VydEFmdGVyKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50LCBzdmdFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTdmdFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnNlcnRBZnRlcihzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCwgcHJldlN2Z0VsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwZW5kKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50KTtcbiAgICAgICAgICB9IC8vIEluc2VydCB0ZXh0XG5cblxuICAgICAgICAgIGluc2VydEFmdGVyKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50LCBzdmdFbGVtZW50KTtcbiAgICAgICAgICBwcmV2U3ZnRWxlbWVudCA9IHRleHRTdmdFbGVtZW50IHx8IHN2Z0VsZW1lbnQgfHwgcHJldlN2Z0VsZW1lbnQ7IC8vIHpyZW5kZXIuVGV4dCBvbmx5IGNyZWF0ZSB0ZXh0U3ZnRWxlbWVudC5cblxuICAgICAgICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuc2hhZG93TWFuYWdlci5hZGRXaXRob3V0VXBkYXRlKHN2Z0VsZW1lbnQgfHwgdGV4dFN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB0aGlzLmNsaXBQYXRoTWFuYWdlci5tYXJrVXNlZChkaXNwbGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWl0ZW0ucmVtb3ZlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IG5ld1Zpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIubWFya1VzZWQoZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuc2hhZG93TWFuYWdlci5tYXJrVXNlZChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdGhpcy5zaGFkb3dNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGhNYW5hZ2VyLm1hcmtVc2VkKGRpc3BsYXlhYmxlKTtcblxuICAgICAgICAgIGlmICh0ZXh0U3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRleHQuXG4gICAgICAgICAgICBpbnNlcnRBZnRlcihzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCwgc3ZnRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlN2Z0VsZW1lbnQgPSBzdmdFbGVtZW50IHx8IHRleHRTdmdFbGVtZW50IHx8IHByZXZTdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ncmFkaWVudE1hbmFnZXIucmVtb3ZlVW51c2VkKCk7XG4gICAgdGhpcy5jbGlwUGF0aE1hbmFnZXIucmVtb3ZlVW51c2VkKCk7XG4gICAgdGhpcy5zaGFkb3dNYW5hZ2VyLnJlbW92ZVVudXNlZCgpO1xuICAgIHRoaXMuX3Zpc2libGVMaXN0ID0gbmV3VmlzaWJsZUxpc3Q7XG4gIH0sXG4gIF9nZXREZWZzOiBmdW5jdGlvbiAoaXNGb3JjZUNyZWF0aW5nKSB7XG4gICAgdmFyIHN2Z1Jvb3QgPSB0aGlzLl9zdmdEb207XG4gICAgdmFyIGRlZnMgPSBzdmdSb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJyk7XG5cbiAgICBpZiAoZGVmcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdCBleGlzdFxuICAgICAgaWYgKGlzRm9yY2VDcmVhdGluZykge1xuICAgICAgICB2YXIgZGVmcyA9IHN2Z1Jvb3QuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSwgLy8gQ3JlYXRlIG5ldyB0YWdcbiAgICAgICAgc3ZnUm9vdC5maXJzdENoaWxkIC8vIEluc2VydCBpbiB0aGUgZnJvbnQgb2Ygc3ZnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFkZWZzLmNvbnRhaW5zKSB7XG4gICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGNvbnRhaW5zIG1ldGhvZFxuICAgICAgICAgIGRlZnMuY29udGFpbnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRlZnMuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldID09PSBlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZnNbMF07XG4gICAgfVxuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7IC8vIEZJWE1FIFdoeSA/XG5cbiAgICB2aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICB2aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT09IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHZpZXdwb3J0U3R5bGUgPSB2aWV3cG9ydC5zdHlsZTtcbiAgICAgIHZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB2aWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB2YXIgc3ZnUm9vdCA9IHRoaXMuX3N2Z0RvbTsgLy8gU2V0IHdpZHRoIGJ5ICdzdmdSb290LndpZHRoID0gd2lkdGgnIGlzIGludmFsaWRcblxuICAgICAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JhY2tncm91bmROb2RlKSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTm9kZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuXG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuX3N2Z1Jvb3QgPSB0aGlzLl9iYWNrZ3JvdW5kUm9vdCA9IHRoaXMuX3N2Z0RvbSA9IHRoaXMuX2JhY2tncm91bmROb2RlID0gdGhpcy5fdmlld3BvcnQgPSB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZpZXdwb3J0KTtcbiAgICB9XG4gIH0sXG4gIHRvRGF0YVVSTDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHZhciBodG1sID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX3N2Z0RvbS5vdXRlckhUTUwucmVwbGFjZSgvPjwvZywgJz5cXG5cXHI8JykpO1xuICAgIHJldHVybiAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsJyArIGh0bWw7XG4gIH1cbn07IC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuXG5mdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxvZ0Vycm9yKCdJbiBTVkcgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfTtcbn0gLy8gVW5zdXBwb3RlZCBtZXRob2RzXG5cblxudXRpbC5lYWNoKFsnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsdGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJywgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAncGF0aFRvSW1hZ2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgU1ZHUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBTVkdQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgc3ZnVVJJID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChuYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnVVJJLCBuYW1lKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDsiLCJ2YXIgX2NvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IF9jb3JlLmNyZWF0ZUVsZW1lbnQ7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwiLi4vY29yZS9tYXRyaXhcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvaGVscGVyL3RleHRcIik7XG5cbnZhciBUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvVGV4dFwiKTtcblxuLy8gVE9ET1xuLy8gMS4gc2hhZG93XG4vLyAyLiBJbWFnZTogc3gsIHN5LCBzdywgc2hcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIGFycmF5Sm9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyIE5PTkUgPSAnbm9uZSc7XG52YXIgbWF0aFJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBkZWdyZWUgPSAxODAgLyBQSTtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gcm91bmQ0KHZhbCkge1xuICByZXR1cm4gbWF0aFJvdW5kKHZhbCAqIDFlNCkgLyAxZTQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA8IEVQU0lMT04gJiYgdmFsID4gLUVQU0lMT047XG59XG5cbmZ1bmN0aW9uIHBhdGhIYXNGaWxsKHN0eWxlLCBpc1RleHQpIHtcbiAgdmFyIGZpbGwgPSBpc1RleHQgPyBzdHlsZS50ZXh0RmlsbCA6IHN0eWxlLmZpbGw7XG4gIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gTk9ORTtcbn1cblxuZnVuY3Rpb24gcGF0aEhhc1N0cm9rZShzdHlsZSwgaXNUZXh0KSB7XG4gIHZhciBzdHJva2UgPSBpc1RleHQgPyBzdHlsZS50ZXh0U3Ryb2tlIDogc3R5bGUuc3Ryb2tlO1xuICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSBOT05FO1xufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0oc3ZnRWwsIG0pIHtcbiAgaWYgKG0pIHtcbiAgICBhdHRyKHN2Z0VsLCAndHJhbnNmb3JtJywgJ21hdHJpeCgnICsgYXJyYXlKb2luLmNhbGwobSwgJywnKSArICcpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0cihlbCwga2V5LCB2YWwpIHtcbiAgaWYgKCF2YWwgfHwgdmFsLnR5cGUgIT09ICdsaW5lYXInICYmIHZhbC50eXBlICE9PSAncmFkaWFsJykge1xuICAgIC8vIERvbid0IHNldCBhdHRyaWJ1dGUgZm9yIGdyYWRpZW50LCBzaW5jZSBpdCBuZWVkIG5ldyBkb20gbm9kZXNcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dHJYTGluayhlbCwga2V5LCB2YWwpIHtcbiAgZWwuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBrZXksIHZhbCk7XG59XG5cbmZ1bmN0aW9uIGJpbmRTdHlsZShzdmdFbCwgc3R5bGUsIGlzVGV4dCwgZWwpIHtcbiAgaWYgKHBhdGhIYXNGaWxsKHN0eWxlLCBpc1RleHQpKSB7XG4gICAgdmFyIGZpbGwgPSBpc1RleHQgPyBzdHlsZS50ZXh0RmlsbCA6IHN0eWxlLmZpbGw7XG4gICAgZmlsbCA9IGZpbGwgPT09ICd0cmFuc3BhcmVudCcgPyBOT05FIDogZmlsbDtcbiAgICBhdHRyKHN2Z0VsLCAnZmlsbCcsIGZpbGwpO1xuICAgIGF0dHIoc3ZnRWwsICdmaWxsLW9wYWNpdHknLCBzdHlsZS5maWxsT3BhY2l0eSAhPSBudWxsID8gc3R5bGUuZmlsbE9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5IDogc3R5bGUub3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgYXR0cihzdmdFbCwgJ2ZpbGwnLCBOT05FKTtcbiAgfVxuXG4gIGlmIChwYXRoSGFzU3Ryb2tlKHN0eWxlLCBpc1RleHQpKSB7XG4gICAgdmFyIHN0cm9rZSA9IGlzVGV4dCA/IHN0eWxlLnRleHRTdHJva2UgOiBzdHlsZS5zdHJva2U7XG4gICAgc3Ryb2tlID0gc3Ryb2tlID09PSAndHJhbnNwYXJlbnQnID8gTk9ORSA6IHN0cm9rZTtcbiAgICBhdHRyKHN2Z0VsLCAnc3Ryb2tlJywgc3Ryb2tlKTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSBpc1RleHQgPyBzdHlsZS50ZXh0U3Ryb2tlV2lkdGggOiBzdHlsZS5saW5lV2lkdGg7XG4gICAgdmFyIHN0cm9rZVNjYWxlID0gIWlzVGV4dCAmJiBzdHlsZS5zdHJva2VOb1NjYWxlID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgIGF0dHIoc3ZnRWwsICdzdHJva2Utd2lkdGgnLCBzdHJva2VXaWR0aCAvIHN0cm9rZVNjYWxlKTsgLy8gc3Ryb2tlIHRoZW4gZmlsbCBmb3IgdGV4dDsgZmlsbCB0aGVuIHN0cm9rZSBmb3Igb3RoZXJzXG5cbiAgICBhdHRyKHN2Z0VsLCAncGFpbnQtb3JkZXInLCBpc1RleHQgPyAnc3Ryb2tlJyA6ICdmaWxsJyk7XG4gICAgYXR0cihzdmdFbCwgJ3N0cm9rZS1vcGFjaXR5Jywgc3R5bGUuc3Ryb2tlT3BhY2l0eSAhPSBudWxsID8gc3R5bGUuc3Ryb2tlT3BhY2l0eSA6IHN0eWxlLm9wYWNpdHkpO1xuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuXG4gICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICBhdHRyKHN2Z0VsLCAnc3Ryb2tlLWRhc2hhcnJheScsIHN0eWxlLmxpbmVEYXNoLmpvaW4oJywnKSk7XG4gICAgICBhdHRyKHN2Z0VsLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCBtYXRoUm91bmQoc3R5bGUubGluZURhc2hPZmZzZXQgfHwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyKHN2Z0VsLCAnc3Ryb2tlLWRhc2hhcnJheScsICcnKTtcbiAgICB9IC8vIFBFTkRJTkdcblxuXG4gICAgc3R5bGUubGluZUNhcCAmJiBhdHRyKHN2Z0VsLCAnc3Ryb2tlLWxpbmVjYXAnLCBzdHlsZS5saW5lQ2FwKTtcbiAgICBzdHlsZS5saW5lSm9pbiAmJiBhdHRyKHN2Z0VsLCAnc3Ryb2tlLWxpbmVqb2luJywgc3R5bGUubGluZUpvaW4pO1xuICAgIHN0eWxlLm1pdGVyTGltaXQgJiYgYXR0cihzdmdFbCwgJ3N0cm9rZS1taXRlcmxpbWl0Jywgc3R5bGUubWl0ZXJMaW1pdCk7XG4gIH0gZWxzZSB7XG4gICAgYXR0cihzdmdFbCwgJ3N0cm9rZScsIE5PTkUpO1xuICB9XG59XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBQQVRIXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuZnVuY3Rpb24gcGF0aERhdGFUb1N0cmluZyhwYXRoKSB7XG4gIHZhciBzdHIgPSBbXTtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBkYXRhTGVuZ3RoID0gcGF0aC5sZW4oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMZW5ndGg7KSB7XG4gICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICB2YXIgY21kU3RyID0gJyc7XG4gICAgdmFyIG5EYXRhID0gMDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICBjbWRTdHIgPSAnTSc7XG4gICAgICAgIG5EYXRhID0gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgIGNtZFN0ciA9ICdMJztcbiAgICAgICAgbkRhdGEgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgY21kU3RyID0gJ1EnO1xuICAgICAgICBuRGF0YSA9IDQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBjbWRTdHIgPSAnQyc7XG4gICAgICAgIG5EYXRhID0gNjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY2xvY2t3aXNlID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgZFRoZXRhUG9zaXRpdmUgPSBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICB2YXIgaXNDaXJjbGUgPSBpc0Fyb3VuZFplcm8oZFRoZXRhUG9zaXRpdmUgLSBQSTIpIHx8IChjbG9ja3dpc2UgPyBkVGhldGEgPj0gUEkyIDogLWRUaGV0YSA+PSBQSTIpOyAvLyBNYXBwaW5nIHRvIDB+MlBJXG5cbiAgICAgICAgdmFyIHVuaWZpZWRUaGV0YSA9IGRUaGV0YSA+IDAgPyBkVGhldGEgJSBQSTIgOiBkVGhldGEgJSBQSTIgKyBQSTI7XG4gICAgICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Fyb3VuZFplcm8oZFRoZXRhUG9zaXRpdmUpKSB7XG4gICAgICAgICAgbGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXJnZSA9IHVuaWZpZWRUaGV0YSA+PSBQSSA9PT0gISFjbG9ja3dpc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDAgPSByb3VuZDQoY3ggKyByeCAqIG1hdGhDb3ModGhldGEpKTtcbiAgICAgICAgdmFyIHkwID0gcm91bmQ0KGN5ICsgcnkgKiBtYXRoU2luKHRoZXRhKSk7IC8vIEl0IHdpbGwgbm90IGRyYXcgaWYgc3RhcnQgcG9pbnQgYW5kIGVuZCBwb2ludCBhcmUgZXhhY3RseSB0aGUgc2FtZVxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNoaWZ0IHRoZSBlbmQgcG9pbnQgd2l0aCBhIHNtYWxsIHZhbHVlXG4gICAgICAgIC8vIEZJWE1FIEEgYmV0dGVyIHdheSB0byBkcmF3IGNpcmNsZSA/XG5cbiAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgZFRoZXRhID0gUEkyIC0gMWUtNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZFRoZXRhID0gLVBJMiArIDFlLTQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFyZ2UgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDkpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gKHgwLCB5MCkgb25seSB3aGVuIENNRC5BIGNvbWVzIGF0IHRoZVxuICAgICAgICAgICAgLy8gZmlyc3QgcG9zaXRpb24gb2YgYSBzaGFwZS5cbiAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSwgd2hlbiBkcmF3aW5nIGEgcmluZywgQ01ELkEgY29tZXNcbiAgICAgICAgICAgIC8vIGFmdGVyIENNRC5NLCBzbyBpdCdzIHVubmVjZXNzYXJ5IHRvIG1vdmUgdG9cbiAgICAgICAgICAgIC8vICh4MCwgeTApLlxuICAgICAgICAgICAgc3RyLnB1c2goJ00nLCB4MCwgeTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gcm91bmQ0KGN4ICsgcnggKiBtYXRoQ29zKHRoZXRhICsgZFRoZXRhKSk7XG4gICAgICAgIHZhciB5ID0gcm91bmQ0KGN5ICsgcnkgKiBtYXRoU2luKHRoZXRhICsgZFRoZXRhKSk7IC8vIEZJWE1FIEVsbGlwc2VcblxuICAgICAgICBzdHIucHVzaCgnQScsIHJvdW5kNChyeCksIHJvdW5kNChyeSksIG1hdGhSb3VuZChwc2kgKiBkZWdyZWUpLCArbGFyZ2UsICtjbG9ja3dpc2UsIHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgY21kU3RyID0gJ1onO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgdmFyIHggPSByb3VuZDQoZGF0YVtpKytdKTtcbiAgICAgICAgdmFyIHkgPSByb3VuZDQoZGF0YVtpKytdKTtcbiAgICAgICAgdmFyIHcgPSByb3VuZDQoZGF0YVtpKytdKTtcbiAgICAgICAgdmFyIGggPSByb3VuZDQoZGF0YVtpKytdKTtcbiAgICAgICAgc3RyLnB1c2goJ00nLCB4LCB5LCAnTCcsIHggKyB3LCB5LCAnTCcsIHggKyB3LCB5ICsgaCwgJ0wnLCB4LCB5ICsgaCwgJ0wnLCB4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY21kU3RyICYmIHN0ci5wdXNoKGNtZFN0cik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5EYXRhOyBqKyspIHtcbiAgICAgIC8vIFBFTkRJTkcgV2l0aCBzY2FsZVxuICAgICAgc3RyLnB1c2gocm91bmQ0KGRhdGFbaSsrXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHIuam9pbignICcpO1xufVxuXG52YXIgc3ZnUGF0aCA9IHt9O1xuXG5zdmdQYXRoLmJydXNoID0gZnVuY3Rpb24gKGVsKSB7XG4gIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICB2YXIgc3ZnRWwgPSBlbC5fX3N2Z0VsO1xuXG4gIGlmICghc3ZnRWwpIHtcbiAgICBzdmdFbCA9IGNyZWF0ZUVsZW1lbnQoJ3BhdGgnKTtcbiAgICBlbC5fX3N2Z0VsID0gc3ZnRWw7XG4gIH1cblxuICBpZiAoIWVsLnBhdGgpIHtcbiAgICBlbC5jcmVhdGVQYXRoUHJveHkoKTtcbiAgfVxuXG4gIHZhciBwYXRoID0gZWwucGF0aDtcblxuICBpZiAoZWwuX19kaXJ0eVBhdGgpIHtcbiAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgIHBhdGguc3ViUGl4ZWxPcHRpbWl6ZSA9IGZhbHNlO1xuICAgIGVsLmJ1aWxkUGF0aChwYXRoLCBlbC5zaGFwZSk7XG4gICAgZWwuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB2YXIgcGF0aFN0ciA9IHBhdGhEYXRhVG9TdHJpbmcocGF0aCk7XG5cbiAgICBpZiAocGF0aFN0ci5pbmRleE9mKCdOYU4nKSA8IDApIHtcbiAgICAgIC8vIElnbm9yZSBpbGxlZ2FsIHBhdGgsIHdoaWNoIG1heSBoYXBwZW4gc3VjaCBpbiBvdXQtb2YtcmFuZ2VcbiAgICAgIC8vIGRhdGEgaW4gQ2FsZW5kYXIgc2VyaWVzLlxuICAgICAgYXR0cihzdmdFbCwgJ2QnLCBwYXRoU3RyKTtcbiAgICB9XG4gIH1cblxuICBiaW5kU3R5bGUoc3ZnRWwsIHN0eWxlLCBmYWxzZSwgZWwpO1xuICBzZXRUcmFuc2Zvcm0oc3ZnRWwsIGVsLnRyYW5zZm9ybSk7XG5cbiAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgIHN2Z1RleHREcmF3UmVjdFRleHQoZWwsIGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVPbGRUZXh0Tm9kZShlbCk7XG4gIH1cbn07XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBJTUFHRVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBzdmdJbWFnZSA9IHt9O1xuXG5zdmdJbWFnZS5icnVzaCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7XG5cbiAgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG4gICAgaW1hZ2UgPSBzcmM7XG4gIH1cblxuICBpZiAoIWltYWdlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgdmFyIGRoID0gc3R5bGUuaGVpZ2h0O1xuICB2YXIgc3ZnRWwgPSBlbC5fX3N2Z0VsO1xuXG4gIGlmICghc3ZnRWwpIHtcbiAgICBzdmdFbCA9IGNyZWF0ZUVsZW1lbnQoJ2ltYWdlJyk7XG4gICAgZWwuX19zdmdFbCA9IHN2Z0VsO1xuICB9XG5cbiAgaWYgKGltYWdlICE9PSBlbC5fX2ltYWdlU3JjKSB7XG4gICAgYXR0clhMaW5rKHN2Z0VsLCAnaHJlZicsIGltYWdlKTsgLy8gQ2FjaGluZyBpbWFnZSBzcmNcblxuICAgIGVsLl9faW1hZ2VTcmMgPSBpbWFnZTtcbiAgfVxuXG4gIGF0dHIoc3ZnRWwsICd3aWR0aCcsIGR3KTtcbiAgYXR0cihzdmdFbCwgJ2hlaWdodCcsIGRoKTtcbiAgYXR0cihzdmdFbCwgJ3gnLCB4KTtcbiAgYXR0cihzdmdFbCwgJ3knLCB5KTtcbiAgc2V0VHJhbnNmb3JtKHN2Z0VsLCBlbC50cmFuc2Zvcm0pO1xuXG4gIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzdmdUZXh0RHJhd1JlY3RUZXh0KGVsLCBlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlT2xkVGV4dE5vZGUoZWwpO1xuICB9XG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogVEVYVFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBzdmdUZXh0ID0ge307XG5cbnZhciBfdG1wVGV4dEhvc3RSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgX3RtcFRleHRCb3hQb3MgPSB7fTtcbnZhciBfdG1wVGV4dFRyYW5zZm9ybSA9IFtdO1xudmFyIFRFWFRfQUxJR05fVE9fQU5DSFJPID0ge1xuICBsZWZ0OiAnc3RhcnQnLFxuICByaWdodDogJ2VuZCcsXG4gIGNlbnRlcjogJ21pZGRsZScsXG4gIG1pZGRsZTogJ21pZGRsZSdcbn07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtob3N0UmVjdF0ge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKi9cblxudmFyIHN2Z1RleHREcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAoZWwsIGhvc3RSZWN0KSB7XG4gIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICB2YXIgZWxUcmFuc2Zvcm0gPSBlbC50cmFuc2Zvcm07XG4gIHZhciBuZWVkVHJhbnNmb3JtVGV4dEJ5SG9zdEVsID0gZWwgaW5zdGFuY2VvZiBUZXh0IHx8IHN0eWxlLnRyYW5zZm9ybVRleHQ7XG4gIGVsLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyByZW5kZXIgZW1wdHkgdGV4dCBmb3Igc3ZnIGlmIG5vIHRleHQgYnV0IG5lZWQgZHJhdyB0ZXh0LlxuXG5cbiAgdGV4dCA9PSBudWxsICYmICh0ZXh0ID0gJycpOyAvLyBGb2xsb3cgdGhlIHNldHRpbmcgaW4gdGhlIGNhbnZhcyByZW5kZXJlciwgaWYgbm90IHRyYW5zZm9ybSB0aGVcbiAgLy8gdGV4dCwgdHJhbnNmb3JtIHRoZSBob3N0UmVjdCwgYnkgd2hpY2ggdGhlIHRleHQgaXMgbG9jYXRlZC5cblxuICBpZiAoIW5lZWRUcmFuc2Zvcm1UZXh0QnlIb3N0RWwgJiYgZWxUcmFuc2Zvcm0pIHtcbiAgICBfdG1wVGV4dEhvc3RSZWN0LmNvcHkoaG9zdFJlY3QpO1xuXG4gICAgX3RtcFRleHRIb3N0UmVjdC5hcHBseVRyYW5zZm9ybShlbFRyYW5zZm9ybSk7XG5cbiAgICBob3N0UmVjdCA9IF90bXBUZXh0SG9zdFJlY3Q7XG4gIH1cblxuICB2YXIgdGV4dFN2Z0VsID0gZWwuX190ZXh0U3ZnRWw7XG5cbiAgaWYgKCF0ZXh0U3ZnRWwpIHtcbiAgICB0ZXh0U3ZnRWwgPSBjcmVhdGVFbGVtZW50KCd0ZXh0Jyk7XG4gICAgZWwuX190ZXh0U3ZnRWwgPSB0ZXh0U3ZnRWw7XG4gIH0gLy8gc3R5bGUuZm9udCBoYXMgYmVlbiBub3JtYWxpemVkIGJ5IGBub3JtYWxpemVUZXh0U3R5bGVgLlxuXG5cbiAgdmFyIHRleHRTdmdFbFN0eWxlID0gdGV4dFN2Z0VsLnN0eWxlO1xuICB2YXIgZm9udCA9IHN0eWxlLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UO1xuICB2YXIgY29tcHV0ZWRGb250ID0gdGV4dFN2Z0VsLl9fY29tcHV0ZWRGb250O1xuXG4gIGlmIChmb250ICE9PSB0ZXh0U3ZnRWwuX19zdHlsZUZvbnQpIHtcbiAgICB0ZXh0U3ZnRWxTdHlsZS5mb250ID0gdGV4dFN2Z0VsLl9fc3R5bGVGb250ID0gZm9udDsgLy8gVGhlIGNvbXB1dGVkRm9udCBtaWdodCBub3QgYmUgdGhlIG9yZ2luYWwgZm9udCBpZiBpdCBpcyBpbGxlZ2FsIGZvbnQuXG5cbiAgICBjb21wdXRlZEZvbnQgPSB0ZXh0U3ZnRWwuX19jb21wdXRlZEZvbnQgPSB0ZXh0U3ZnRWxTdHlsZS5mb250O1xuICB9XG5cbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciB0ZXh0TGluZUhlaWdodCA9IHN0eWxlLnRleHRMaW5lSGVpZ2h0O1xuICB2YXIgY29udGVudEJsb2NrID0gZWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgZWwuX19kaXJ0eVRleHQpIHtcbiAgICBjb250ZW50QmxvY2sgPSBlbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUGxhaW5UZXh0KHRleHQsIGNvbXB1dGVkRm9udCwgdGV4dFBhZGRpbmcsIHRleHRMaW5lSGVpZ2h0LCBzdHlsZS50cnVuY2F0ZSk7XG4gIH1cblxuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciBsaW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHRleHRIZWxwZXIuZ2V0Qm94UG9zaXRpb24oX3RtcFRleHRCb3hQb3MsIGVsLCBzdHlsZSwgaG9zdFJlY3QpO1xuICB2YXIgYmFzZVggPSBfdG1wVGV4dEJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gX3RtcFRleHRCb3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBfdG1wVGV4dEJveFBvcy50ZXh0QWxpZ24gfHwgJ2xlZnQnO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBfdG1wVGV4dEJveFBvcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgc2V0VGV4dFRyYW5zZm9ybSh0ZXh0U3ZnRWwsIG5lZWRUcmFuc2Zvcm1UZXh0QnlIb3N0RWwsIGVsVHJhbnNmb3JtLCBzdHlsZSwgaG9zdFJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB0ZXh0WCA9IGJhc2VYO1xuICB2YXIgdGV4dFkgPSBib3hZOyAvLyBUT0RPIG5lZWREcmF3QmdcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB0ZXh0WCA9IGdldFRleHRYRm9yUGFkZGluZyhiYXNlWCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgdGV4dFkgKz0gdGV4dFBhZGRpbmdbMF07XG4gIH0gLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIGJpbmRTdHlsZSh0ZXh0U3ZnRWwsIHN0eWxlLCB0cnVlLCBlbCk7IC8vIEZJWE1FXG4gIC8vIEFkZCBhIDxzdHlsZT4gdG8gcmVzZXQgYWxsIG9mIHRoZSB0ZXh0IGZvbnQgYXMgaW5oZXJpdD9cbiAgLy8gb3RoZXJ3aXNlIHRoZSBvdXRlciA8c3R5bGU+IG1heSBzZXQgdGhlIHVuZXhwZWN0ZWQgc3R5bGUuXG4gIC8vIEZvbnQgbWF5IGFmZmVjdCBwb3NpdGlvbiBvZiBlYWNoIHRzcGFuIGVsZW1lbnRzXG5cbiAgdmFyIGNhbkNhY2hlQnlUZXh0U3RyaW5nID0gY29udGVudEJsb2NrLmNhbkNhY2hlQnlUZXh0U3RyaW5nO1xuICB2YXIgdHNwYW5MaXN0ID0gZWwuX190c3Bhbkxpc3QgfHwgKGVsLl9fdHNwYW5MaXN0ID0gW10pO1xuICB2YXIgdHNwYW5PcmlnaW5MZW4gPSB0c3Bhbkxpc3QubGVuZ3RoOyAvLyBPcHRpbWl6ZSBmb3IgbW9zdCBjYXNlcywganVzdCBjb21wYXJlIHRleHQgc3RyaW5nIHRvIGRldGVybWluZSBjaGFuZ2UuXG5cbiAgaWYgKGNhbkNhY2hlQnlUZXh0U3RyaW5nICYmIGVsLl9fY2FuQ2FjaGVCeVRleHRTdHJpbmcgJiYgZWwuX190ZXh0ID09PSB0ZXh0KSB7XG4gICAgaWYgKGVsLl9fZGlydHlUZXh0ICYmIHRzcGFuT3JpZ2luTGVuKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0c3Bhbk9yaWdpbkxlbjsgKytpZHgpIHtcbiAgICAgICAgdXBkYXRlVGV4dExvY2F0aW9uKHRzcGFuTGlzdFtpZHhdLCB0ZXh0QWxpZ24sIHRleHRYLCB0ZXh0WSArIGlkeCAqIGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbC5fX3RleHQgPSB0ZXh0O1xuICAgIGVsLl9fY2FuQ2FjaGVCeVRleHRTdHJpbmcgPSBjYW5DYWNoZUJ5VGV4dFN0cmluZztcbiAgICB2YXIgdGV4dExpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICAgIHZhciBuVGV4dExpbmVzID0gdGV4dExpbmVzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gMDtcblxuICAgIGZvciAoOyBpZHggPCBuVGV4dExpbmVzOyBpZHgrKykge1xuICAgICAgLy8gVXNpbmcgY2FjaGVkIHRzcGFuIGVsZW1lbnRzXG4gICAgICB2YXIgdHNwYW4gPSB0c3Bhbkxpc3RbaWR4XTtcbiAgICAgIHZhciBzaW5nbGVMaW5lVGV4dCA9IHRleHRMaW5lc1tpZHhdO1xuXG4gICAgICBpZiAoIXRzcGFuKSB7XG4gICAgICAgIHRzcGFuID0gdHNwYW5MaXN0W2lkeF0gPSBjcmVhdGVFbGVtZW50KCd0c3BhbicpO1xuICAgICAgICB0ZXh0U3ZnRWwuYXBwZW5kQ2hpbGQodHNwYW4pO1xuICAgICAgICB0c3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzaW5nbGVMaW5lVGV4dCkpO1xuICAgICAgfSBlbHNlIGlmICh0c3Bhbi5fX3pyVGV4dCAhPT0gc2luZ2xlTGluZVRleHQpIHtcbiAgICAgICAgdHNwYW4uaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNpbmdsZUxpbmVUZXh0KSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVRleHRMb2NhdGlvbih0c3BhbiwgdGV4dEFsaWduLCB0ZXh0WCwgdGV4dFkgKyBpZHggKiBsaW5lSGVpZ2h0KTtcbiAgICB9IC8vIFJlbW92ZSB1bnVzZWQgdHNwYW4gZWxlbWVudHNcblxuXG4gICAgaWYgKHRzcGFuT3JpZ2luTGVuID4gblRleHRMaW5lcykge1xuICAgICAgZm9yICg7IGlkeCA8IHRzcGFuT3JpZ2luTGVuOyBpZHgrKykge1xuICAgICAgICB0ZXh0U3ZnRWwucmVtb3ZlQ2hpbGQodHNwYW5MaXN0W2lkeF0pO1xuICAgICAgfVxuXG4gICAgICB0c3Bhbkxpc3QubGVuZ3RoID0gblRleHRMaW5lcztcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFRleHRUcmFuc2Zvcm0odGV4dFN2Z0VsLCBuZWVkVHJhbnNmb3JtVGV4dEJ5SG9zdEVsLCBlbFRyYW5zZm9ybSwgc3R5bGUsIGhvc3RSZWN0LCBiYXNlWCwgYmFzZVkpIHtcbiAgbWF0cml4LmlkZW50aXR5KF90bXBUZXh0VHJhbnNmb3JtKTtcblxuICBpZiAobmVlZFRyYW5zZm9ybVRleHRCeUhvc3RFbCAmJiBlbFRyYW5zZm9ybSkge1xuICAgIG1hdHJpeC5jb3B5KF90bXBUZXh0VHJhbnNmb3JtLCBlbFRyYW5zZm9ybSk7XG4gIH0gLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG5cblxuICB2YXIgdGV4dFJvdGF0aW9uID0gc3R5bGUudGV4dFJvdGF0aW9uO1xuXG4gIGlmIChob3N0UmVjdCAmJiB0ZXh0Um90YXRpb24pIHtcbiAgICB2YXIgb3JpZ2luID0gc3R5bGUudGV4dE9yaWdpbjtcblxuICAgIGlmIChvcmlnaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICBiYXNlWCA9IGhvc3RSZWN0LndpZHRoIC8gMiArIGhvc3RSZWN0Lng7XG4gICAgICBiYXNlWSA9IGhvc3RSZWN0LmhlaWdodCAvIDIgKyBob3N0UmVjdC55O1xuICAgIH0gZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICBiYXNlWCA9IG9yaWdpblswXSArIGhvc3RSZWN0Lng7XG4gICAgICBiYXNlWSA9IG9yaWdpblsxXSArIGhvc3RSZWN0Lnk7XG4gICAgfVxuXG4gICAgX3RtcFRleHRUcmFuc2Zvcm1bNF0gLT0gYmFzZVg7XG4gICAgX3RtcFRleHRUcmFuc2Zvcm1bNV0gLT0gYmFzZVk7IC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG5cbiAgICBtYXRyaXgucm90YXRlKF90bXBUZXh0VHJhbnNmb3JtLCBfdG1wVGV4dFRyYW5zZm9ybSwgdGV4dFJvdGF0aW9uKTtcbiAgICBfdG1wVGV4dFRyYW5zZm9ybVs0XSArPSBiYXNlWDtcbiAgICBfdG1wVGV4dFRyYW5zZm9ybVs1XSArPSBiYXNlWTtcbiAgfSAvLyBTZWUgdGhlIGRlZmluaXRpb24gaW4gYFN0eWxlLmpzI3RleHRPcmlnaW5gLCB0aGUgZGVmYXVsdFxuICAvLyBvcmlnaW4gaXMgZnJvbSB0aGUgcmVzdWx0IG9mIGBnZXRCb3hQb3NpdGlvbmAuXG5cblxuICBzZXRUcmFuc2Zvcm0odGV4dFN2Z0VsLCBfdG1wVGV4dFRyYW5zZm9ybSk7XG59IC8vIEZJWE1FIG1lcmdlIHRoZSBzYW1lIGNvZGUgd2l0aCBgaGVscGVyL3RleHQuanMjZ2V0VGV4dFhGb3JQYWRkaW5nYDtcblxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMb2NhdGlvbih0c3BhbiwgdGV4dEFsaWduLCB4LCB5KSB7XG4gIC8vIENvbnNpZGVyIGRpZmZlcmVudCBmb250IGRpc3BsYXkgZGlmZmVyZW50bHkgaW4gdmVydGlhbCBhbGlnbiwgd2UgYWx3YXlzXG4gIC8vIHNldCB2ZXJ0aWFsQWxpZ24gYXMgJ21pZGRsZScsIGFuZCB1c2UgJ3knIHRvIGxvY2F0ZSB0ZXh0IHZlcnRpY2FsbHkuXG4gIGF0dHIodHNwYW4sICdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKTtcbiAgYXR0cih0c3BhbiwgJ3RleHQtYW5jaG9yJywgVEVYVF9BTElHTl9UT19BTkNIUk9bdGV4dEFsaWduXSk7XG4gIGF0dHIodHNwYW4sICd4JywgeCk7XG4gIGF0dHIodHNwYW4sICd5JywgeSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9sZFRleHROb2RlKGVsKSB7XG4gIGlmIChlbCAmJiBlbC5fX3RleHRTdmdFbCkge1xuICAgIC8vIHRleHRTdmdFbCBtYXkgaGFzIG5vIHBhcmVudE5vZGUgaWYgZWwgaGFzIGJlZW4gcmVtb3ZlZCB0ZW1wb3JhcnkuXG4gICAgaWYgKGVsLl9fdGV4dFN2Z0VsLnBhcmVudE5vZGUpIHtcbiAgICAgIGVsLl9fdGV4dFN2Z0VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwuX190ZXh0U3ZnRWwpO1xuICAgIH1cblxuICAgIGVsLl9fdGV4dFN2Z0VsID0gbnVsbDtcbiAgICBlbC5fX3RzcGFuTGlzdCA9IFtdO1xuICAgIGVsLl9fdGV4dCA9IG51bGw7XG4gIH1cbn1cblxuc3ZnVGV4dC5kcmF3UmVjdFRleHQgPSBzdmdUZXh0RHJhd1JlY3RUZXh0O1xuXG5zdmdUZXh0LmJydXNoID0gZnVuY3Rpb24gKGVsKSB7XG4gIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuXG4gIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzdmdUZXh0RHJhd1JlY3RUZXh0KGVsLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlT2xkVGV4dE5vZGUoZWwpO1xuICB9XG59O1xuXG5leHBvcnRzLnBhdGggPSBzdmdQYXRoO1xuZXhwb3J0cy5pbWFnZSA9IHN2Z0ltYWdlO1xuZXhwb3J0cy50ZXh0ID0gc3ZnVGV4dDsiLCJ2YXIgRGVmaW5hYmxlID0gcmVxdWlyZShcIi4vRGVmaW5hYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNWRyBjbGlwUGF0aCBlbGVtZW50cy5cbiAqIEBhdXRob3IgWmhhbmcgV2VubGlcbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgU1ZHIGNsaXBQYXRoIGVsZW1lbnRzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRGVmaW5hYmxlXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgICAgenJJZCAgICB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcGFyYW0gICB7U1ZHRWxlbWVudH0gc3ZnUm9vdCByb290IG9mIFNWRyBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBDbGlwcGF0aE1hbmFnZXIoenJJZCwgc3ZnUm9vdCkge1xuICBEZWZpbmFibGUuY2FsbCh0aGlzLCB6cklkLCBzdmdSb290LCAnY2xpcFBhdGgnLCAnX19jbGlwcGF0aF9pbl91c2VfXycpO1xufVxuXG56clV0aWwuaW5oZXJpdHMoQ2xpcHBhdGhNYW5hZ2VyLCBEZWZpbmFibGUpO1xuLyoqXG4gKiBVcGRhdGUgY2xpcFBhdGguXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgZGlzcGxheWFibGUgZWxlbWVudFxuICovXG5cbkNsaXBwYXRoTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlKSB7XG4gIHZhciBzdmdFbCA9IHRoaXMuZ2V0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG5cbiAgaWYgKHN2Z0VsKSB7XG4gICAgdGhpcy51cGRhdGVEb20oc3ZnRWwsIGRpc3BsYXlhYmxlLl9fY2xpcFBhdGhzLCBmYWxzZSk7XG4gIH1cblxuICB2YXIgdGV4dEVsID0gdGhpcy5nZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG5cbiAgaWYgKHRleHRFbCkge1xuICAgIC8vIE1ha2UgYW5vdGhlciBjbGlwUGF0aCBmb3IgdGV4dCwgc2luY2UgaXQncyB0cmFuc2Zvcm1cbiAgICAvLyBtYXRyaXggaXMgbm90IHRoZSBzYW1lIHdpdGggc3ZnRWxlbWVudFxuICAgIHRoaXMudXBkYXRlRG9tKHRleHRFbCwgZGlzcGxheWFibGUuX19jbGlwUGF0aHMsIHRydWUpO1xuICB9XG5cbiAgdGhpcy5tYXJrVXNlZChkaXNwbGF5YWJsZSk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW4gU1ZHRWxlbWVudCBvZiBkaXNwbGF5YWJsZSBhbmQgY3JlYXRlIGEgPGNsaXBQYXRoPiBvZiBpdHNcbiAqIGNsaXBQYXRoXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gcGFyZW50RWwgIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0ge0NsaXBQYXRoW119ICBjbGlwUGF0aHMgY2xpcFBhdGhzIG9mIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBpc1RleHQgICAgaWYgcGFyZW50IGVsZW1lbnQgaXMgVGV4dFxuICovXG5cblxuQ2xpcHBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEb20gPSBmdW5jdGlvbiAocGFyZW50RWwsIGNsaXBQYXRocywgaXNUZXh0KSB7XG4gIGlmIChjbGlwUGF0aHMgJiYgY2xpcFBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBIYXMgY2xpcFBhdGgsIGNyZWF0ZSA8Y2xpcFBhdGg+IHdpdGggdGhlIGZpcnN0IGNsaXBQYXRoXG4gICAgdmFyIGRlZnMgPSB0aGlzLmdldERlZnModHJ1ZSk7XG4gICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzWzBdO1xuICAgIHZhciBjbGlwUGF0aEVsO1xuICAgIHZhciBpZDtcbiAgICB2YXIgZG9tID0gaXNUZXh0ID8gJ190ZXh0RG9tJyA6ICdfZG9tJztcblxuICAgIGlmIChjbGlwUGF0aFtkb21dKSB7XG4gICAgICAvLyBVc2UgYSBkb20gdGhhdCBpcyBhbHJlYWR5IGluIDxkZWZzPlxuICAgICAgaWQgPSBjbGlwUGF0aFtkb21dLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIGNsaXBQYXRoRWwgPSBjbGlwUGF0aFtkb21dOyAvLyBVc2UgYSBkb20gdGhhdCBpcyBhbHJlYWR5IGluIDxkZWZzPlxuXG4gICAgICBpZiAoIWRlZnMuY29udGFpbnMoY2xpcFBhdGhFbCkpIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gc2V0IG9sZCBjbGlwUGF0aCB0aGF0IGhhc1xuICAgICAgICAvLyBiZWVuIHByZXZpb3VzbHkgcmVtb3ZlZFxuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNsaXBQYXRoRWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgPGNsaXBQYXRoPlxuICAgICAgaWQgPSAnenInICsgdGhpcy5fenJJZCArICctY2xpcC0nICsgdGhpcy5uZXh0SWQ7XG4gICAgICArK3RoaXMubmV4dElkO1xuICAgICAgY2xpcFBhdGhFbCA9IHRoaXMuY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcbiAgICAgIGNsaXBQYXRoRWwuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoY2xpcFBhdGhFbCk7XG4gICAgICBjbGlwUGF0aFtkb21dID0gY2xpcFBhdGhFbDtcbiAgICB9IC8vIEJ1aWxkIHBhdGggYW5kIGFkZCB0byA8Y2xpcFBhdGg+XG5cblxuICAgIHZhciBzdmdQcm94eSA9IHRoaXMuZ2V0U3ZnUHJveHkoY2xpcFBhdGgpO1xuXG4gICAgaWYgKGNsaXBQYXRoLnRyYW5zZm9ybSAmJiBjbGlwUGF0aC5wYXJlbnQuaW52VHJhbnNmb3JtICYmICFpc1RleHQpIHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBjbGlwUGF0aCBoYXMgYSBwYXJlbnQgd2l0aCB0cmFuc2Zvcm0sIHRoZSB0cmFuc2Zvcm1cbiAgICAgICAqIG9mIHBhcmVudCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgd2hlbiBzZXR0aW5nIHRyYW5zZm9ybVxuICAgICAgICogb2YgY2xpcFBhdGguIFNvIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGJhY2sgZnJvbSBwYXJlbnQnc1xuICAgICAgICogdHJhbnNmb3JtLCB3aGljaCBpcyBkb25lIGJ5IG11bHRpcGx5aW5nIHBhcmVudCdzIGludmVyc2VcbiAgICAgICAqIHRyYW5zZm9ybS5cbiAgICAgICAqL1xuICAgICAgLy8gU3RvcmUgb2xkIHRyYW5zZm9ybVxuICAgICAgdmFyIHRyYW5zZm9ybSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNsaXBQYXRoLnRyYW5zZm9ybSk7IC8vIFRyYW5zZm9ybSBiYWNrIGZyb20gcGFyZW50LCBhbmQgYnJ1c2ggcGF0aFxuXG4gICAgICBtYXRyaXgubXVsKGNsaXBQYXRoLnRyYW5zZm9ybSwgY2xpcFBhdGgucGFyZW50LmludlRyYW5zZm9ybSwgY2xpcFBhdGgudHJhbnNmb3JtKTtcbiAgICAgIHN2Z1Byb3h5LmJydXNoKGNsaXBQYXRoKTsgLy8gU2V0IGJhY2sgdHJhbnNmb3JtIG9mIGNsaXBQYXRoXG5cbiAgICAgIGNsaXBQYXRoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnUHJveHkuYnJ1c2goY2xpcFBhdGgpO1xuICAgIH1cblxuICAgIHZhciBwYXRoRWwgPSB0aGlzLmdldFN2Z0VsZW1lbnQoY2xpcFBhdGgpO1xuICAgIGNsaXBQYXRoRWwuaW5uZXJIVE1MID0gJyc7XG4gICAgLyoqXG4gICAgICogVXNlIGBjbG9uZU5vZGUoKWAgaGVyZSB0byBhcHBlbmRDaGlsZCB0byBtdWx0aXBsZSBwYXJlbnRzLFxuICAgICAqIHdoaWNoIG1heSBoYXBwZW5kIHdoZW4gVGV4dCBhbmQgb3RoZXIgc2hhcGVzIGFyZSB1c2luZyB0aGUgc2FtZVxuICAgICAqIGNsaXBQYXRoLiBTaW5jZSBUZXh0IHdpbGwgY3JlYXRlIGFuIGV4dHJhIGNsaXBQYXRoIERPTSBkdWUgdG9cbiAgICAgKiBkaWZmZXJlbnQgdHJhbnNmb3JtIHJ1bGVzLlxuICAgICAqL1xuXG4gICAgY2xpcFBhdGhFbC5hcHBlbmRDaGlsZChwYXRoRWwuY2xvbmVOb2RlKCkpO1xuICAgIHBhcmVudEVsLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgjJyArIGlkICsgJyknKTtcblxuICAgIGlmIChjbGlwUGF0aHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gTWFrZSB0aGUgb3RoZXIgY2xpcFBhdGhzIHJlY3Vyc2l2ZWx5XG4gICAgICB0aGlzLnVwZGF0ZURvbShjbGlwUGF0aEVsLCBjbGlwUGF0aHMuc2xpY2UoMSksIGlzVGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIGNsaXBQYXRoXG4gICAgaWYgKHBhcmVudEVsKSB7XG4gICAgICBwYXJlbnRFbC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICdub25lJyk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBNYXJrIGEgc2luZ2xlIGNsaXBQYXRoIHRvIGJlIHVzZWRcbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKi9cblxuXG5DbGlwcGF0aE1hbmFnZXIucHJvdG90eXBlLm1hcmtVc2VkID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlKSB7XG4gIHZhciB0aGF0ID0gdGhpczsgLy8gZGlzcGxheWFibGUuX19jbGlwUGF0aHMgY2FuIG9ubHkgYmUgYG51bGxgL2B1bmRlZmluZWRgIG9yIGFuIG5vbi1lbXB0eSBhcnJheS5cblxuICBpZiAoZGlzcGxheWFibGUuX19jbGlwUGF0aHMpIHtcbiAgICB6clV0aWwuZWFjaChkaXNwbGF5YWJsZS5fX2NsaXBQYXRocywgZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICBpZiAoY2xpcFBhdGguX2RvbSkge1xuICAgICAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhhdCwgY2xpcFBhdGguX2RvbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGlwUGF0aC5fdGV4dERvbSkge1xuICAgICAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhhdCwgY2xpcFBhdGguX3RleHREb20pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgX2RlZmF1bHQgPSBDbGlwcGF0aE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBfY29yZSA9IHJlcXVpcmUoXCIuLi9jb3JlXCIpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IF9jb3JlLmNyZWF0ZUVsZW1lbnQ7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsXCIpO1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBaSW1hZ2UgPSByZXF1aXJlKFwiLi4vLi4vZ3JhcGhpYy9JbWFnZVwiKTtcblxudmFyIFpUZXh0ID0gcmVxdWlyZShcIi4uLy4uL2dyYXBoaWMvVGV4dFwiKTtcblxudmFyIF9ncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWNcIik7XG5cbnZhciBzdmdQYXRoID0gX2dyYXBoaWMucGF0aDtcbnZhciBzdmdJbWFnZSA9IF9ncmFwaGljLmltYWdlO1xudmFyIHN2Z1RleHQgPSBfZ3JhcGhpYy50ZXh0O1xuXG4vKipcbiAqIEBmaWxlIE1hbmFnZXMgZWxlbWVudHMgdGhhdCBjYW4gYmUgZGVmaW5lZCBpbiA8ZGVmcz4gaW4gU1ZHLFxuICogICAgICAgZS5nLiwgZ3JhZGllbnRzLCBjbGlwIHBhdGgsIGV0Yy5cbiAqIEBhdXRob3IgWmhhbmcgV2VubGlcbiAqL1xudmFyIE1BUktfVU5VU0VEID0gJzAnO1xudmFyIE1BUktfVVNFRCA9ICcxJztcbi8qKlxuICogTWFuYWdlcyBlbGVtZW50cyB0aGF0IGNhbiBiZSBkZWZpbmVkIGluIDxkZWZzPiBpbiBTVkcsXG4gKiBlLmcuLCBncmFkaWVudHMsIGNsaXAgcGF0aCwgZXRjLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgIHpySWQgICAgICB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9ICAgICAgc3ZnUm9vdCAgIHJvb3Qgb2YgU1ZHIGRvY3VtZW50XG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGFnTmFtZXMgIHBvc3NpYmxlIHRhZyBuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIG1hcmtMYWJlbCBsYWJlbCBuYW1lIHRvIG1ha2UgaWYgdGhlIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdXNlZFxuICovXG5cbmZ1bmN0aW9uIERlZmluYWJsZSh6cklkLCBzdmdSb290LCB0YWdOYW1lcywgbWFya0xhYmVsLCBkb21OYW1lKSB7XG4gIHRoaXMuX3pySWQgPSB6cklkO1xuICB0aGlzLl9zdmdSb290ID0gc3ZnUm9vdDtcbiAgdGhpcy5fdGFnTmFtZXMgPSB0eXBlb2YgdGFnTmFtZXMgPT09ICdzdHJpbmcnID8gW3RhZ05hbWVzXSA6IHRhZ05hbWVzO1xuICB0aGlzLl9tYXJrTGFiZWwgPSBtYXJrTGFiZWw7XG4gIHRoaXMuX2RvbU5hbWUgPSBkb21OYW1lIHx8ICdfZG9tJztcbiAgdGhpcy5uZXh0SWQgPSAwO1xufVxuXG5EZWZpbmFibGUucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuLyoqXG4gKiBHZXQgdGhlIDxkZWZzPiB0YWcgZm9yIHN2Z1Jvb3Q7IG9wdGlvbmFsbHkgY3JlYXRlcyBvbmUgaWYgbm90IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9yY2VDcmVhdGluZyBpZiBuZWVkIHRvIGNyZWF0ZSB3aGVuIG5vdCBleGlzdHNcbiAqIEByZXR1cm4ge1NWR0RlZnNFbGVtZW50fSBTVkcgPGRlZnM+IGVsZW1lbnQsIG51bGwgaWYgaXQgZG9lc24ndFxuICogZXhpc3QgYW5kIGlzRm9yY2VDcmVhdGluZyBpcyBmYWxzZVxuICovXG5cbkRlZmluYWJsZS5wcm90b3R5cGUuZ2V0RGVmcyA9IGZ1bmN0aW9uIChpc0ZvcmNlQ3JlYXRpbmcpIHtcbiAgdmFyIHN2Z1Jvb3QgPSB0aGlzLl9zdmdSb290O1xuXG4gIHZhciBkZWZzID0gdGhpcy5fc3ZnUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGVmcycpO1xuXG4gIGlmIChkZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vdCBleGlzdFxuICAgIGlmIChpc0ZvcmNlQ3JlYXRpbmcpIHtcbiAgICAgIGRlZnMgPSBzdmdSb290Lmluc2VydEJlZm9yZSh0aGlzLmNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSwgLy8gQ3JlYXRlIG5ldyB0YWdcbiAgICAgIHN2Z1Jvb3QuZmlyc3RDaGlsZCAvLyBJbnNlcnQgaW4gdGhlIGZyb250IG9mIHN2Z1xuICAgICAgKTtcblxuICAgICAgaWYgKCFkZWZzLmNvbnRhaW5zKSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBjb250YWlucyBtZXRob2RcbiAgICAgICAgZGVmcy5jb250YWlucyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRlZnMuY2hpbGRyZW47XG5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0gPT09IGVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmc1swXTtcbiAgfVxufTtcbi8qKlxuICogVXBkYXRlIERPTSBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGVsZW1lbnQgc3R5bGUgZWxlbWVudC4gZS5nLiwgZm9yIGdyYWRpZW50LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IG1heSBiZSAnI2NjYycgb3Ige3R5cGU6ICdsaW5lYXInLCAuLi59XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHVuZGVmaW5lZH0gb25VcGRhdGUgdXBkYXRlIGNhbGxiYWNrXG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvblVwZGF0ZSkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyhmYWxzZSk7XG5cbiAgaWYgKGVsZW1lbnRbdGhpcy5fZG9tTmFtZV0gJiYgZGVmcy5jb250YWlucyhlbGVtZW50W3RoaXMuX2RvbU5hbWVdKSkge1xuICAgIC8vIFVwZGF0ZSBET01cbiAgICBpZiAodHlwZW9mIG9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvblVwZGF0ZShlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gcHJldmlvdXMgZG9tLCBjcmVhdGUgbmV3XG4gICAgdmFyIGRvbSA9IHRoaXMuYWRkKGVsZW1lbnQpO1xuXG4gICAgaWYgKGRvbSkge1xuICAgICAgZWxlbWVudFt0aGlzLl9kb21OYW1lXSA9IGRvbTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEFkZCBncmFkaWVudCBkb20gdG8gZGVmc1xuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZG9tIERPTSB0byBiZSBhZGRlZCB0byA8ZGVmcz5cbiAqL1xuXG5cbkRlZmluYWJsZS5wcm90b3R5cGUuYWRkRG9tID0gZnVuY3Rpb24gKGRvbSkge1xuICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyh0cnVlKTtcbiAgZGVmcy5hcHBlbmRDaGlsZChkb20pO1xufTtcbi8qKlxuICogUmVtb3ZlIERPTSBvZiBhIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IGVsZW1lbnQgdG8gcmVtb3ZlIGRvbVxuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5yZW1vdmVEb20gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyhmYWxzZSk7XG5cbiAgaWYgKGRlZnMgJiYgZWxlbWVudFt0aGlzLl9kb21OYW1lXSkge1xuICAgIGRlZnMucmVtb3ZlQ2hpbGQoZWxlbWVudFt0aGlzLl9kb21OYW1lXSk7XG4gICAgZWxlbWVudFt0aGlzLl9kb21OYW1lXSA9IG51bGw7XG4gIH1cbn07XG4vKipcbiAqIEdldCBET01zIG9mIHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtIVE1MRG9tRWxlbWVudH0gZG9tcyBvZiB0aGlzIGRlZmluZWFibGUgZWxlbWVudHMgaW4gPGRlZnM+XG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLmdldERvbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZzID0gdGhpcy5nZXREZWZzKGZhbHNlKTtcblxuICBpZiAoIWRlZnMpIHtcbiAgICAvLyBObyBkb20gd2hlbiBkZWZzIGlzIG5vdCBkZWZpbmVkXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGRvbXMgPSBbXTtcbiAgenJVdGlsLmVhY2godGhpcy5fdGFnTmFtZXMsIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgdmFyIHRhZ3MgPSBkZWZzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpOyAvLyBOb3RlIHRoYXQgdGFncyBpcyBIVE1MQ29sbGVjdGlvbiwgd2hpY2ggaXMgYXJyYXktbGlrZVxuICAgIC8vIHJhdGhlciB0aGFuIHJlYWwgYXJyYXkuXG4gICAgLy8gU28gYGRvbXMuY29uY2F0KHRhZ3MpYCBhZGQgdGFncyBhcyBvbmUgb2JqZWN0LlxuXG4gICAgZG9tcyA9IGRvbXMuY29uY2F0KFtdLnNsaWNlLmNhbGwodGFncykpO1xuICB9KTtcbiAgcmV0dXJuIGRvbXM7XG59O1xuLyoqXG4gKiBNYXJrIERPTXMgdG8gYmUgdW51c2VkIGJlZm9yZSBwYWludGluZywgYW5kIGNsZWFyIHVudXNlZCBvbmVzIGF0IHRoZSBlbmRcbiAqIG9mIHRoZSBwYWludGluZy5cbiAqL1xuXG5cbkRlZmluYWJsZS5wcm90b3R5cGUubWFya0FsbFVudXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRvbXMgPSB0aGlzLmdldERvbXMoKTtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB6clV0aWwuZWFjaChkb21zLCBmdW5jdGlvbiAoZG9tKSB7XG4gICAgZG9tW3RoYXQuX21hcmtMYWJlbF0gPSBNQVJLX1VOVVNFRDtcbiAgfSk7XG59O1xuLyoqXG4gKiBNYXJrIGEgc2luZ2xlIERPTSB0byBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZG9tIERPTSB0byBtYXJrXG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkID0gZnVuY3Rpb24gKGRvbSkge1xuICBpZiAoZG9tKSB7XG4gICAgZG9tW3RoaXMuX21hcmtMYWJlbF0gPSBNQVJLX1VTRUQ7XG4gIH1cbn07XG4vKipcbiAqIFJlbW92ZSB1bnVzZWQgRE9NcyBkZWZpbmVkIGluIDxkZWZzPlxuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5yZW1vdmVVbnVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZzID0gdGhpcy5nZXREZWZzKGZhbHNlKTtcblxuICBpZiAoIWRlZnMpIHtcbiAgICAvLyBOb3RoaW5nIHRvIHJlbW92ZVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkb21zID0gdGhpcy5nZXREb21zKCk7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgenJVdGlsLmVhY2goZG9tcywgZnVuY3Rpb24gKGRvbSkge1xuICAgIGlmIChkb21bdGhhdC5fbWFya0xhYmVsXSAhPT0gTUFSS19VU0VEKSB7XG4gICAgICAvLyBSZW1vdmUgZ3JhZGllbnRcbiAgICAgIGRlZnMucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogR2V0IFNWRyBwcm94eS5cbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtQYXRofEltYWdlfFRleHR9IHN2ZyBwcm94eSBvZiBnaXZlbiBlbGVtZW50XG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLmdldFN2Z1Byb3h5ID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlKSB7XG4gIGlmIChkaXNwbGF5YWJsZSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICByZXR1cm4gc3ZnUGF0aDtcbiAgfSBlbHNlIGlmIChkaXNwbGF5YWJsZSBpbnN0YW5jZW9mIFpJbWFnZSkge1xuICAgIHJldHVybiBzdmdJbWFnZTtcbiAgfSBlbHNlIGlmIChkaXNwbGF5YWJsZSBpbnN0YW5jZW9mIFpUZXh0KSB7XG4gICAgcmV0dXJuIHN2Z1RleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN2Z1BhdGg7XG4gIH1cbn07XG4vKipcbiAqIEdldCB0ZXh0IFNWRyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IFNWRyBlbGVtZW50IG9mIHRleHRcbiAqL1xuXG5cbkRlZmluYWJsZS5wcm90b3R5cGUuZ2V0VGV4dFN2Z0VsZW1lbnQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgcmV0dXJuIGRpc3BsYXlhYmxlLl9fdGV4dFN2Z0VsO1xufTtcbi8qKlxuICogR2V0IFNWRyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IFNWRyBlbGVtZW50XG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLmdldFN2Z0VsZW1lbnQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgcmV0dXJuIGRpc3BsYXlhYmxlLl9fc3ZnRWw7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBEZWZpbmFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBEZWZpbmFibGUgPSByZXF1aXJlKFwiLi9EZWZpbmFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsXCIpO1xuXG52YXIgbG9nRXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9sb2dcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwiLi4vLi4vdG9vbC9jb2xvclwiKTtcblxuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNWRyBncmFkaWVudCBlbGVtZW50cy5cbiAqIEBhdXRob3IgWmhhbmcgV2VubGlcbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgU1ZHIGdyYWRpZW50IGVsZW1lbnRzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRGVmaW5hYmxlXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgICAgenJJZCAgICB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcGFyYW0gICB7U1ZHRWxlbWVudH0gc3ZnUm9vdCByb290IG9mIFNWRyBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBHcmFkaWVudE1hbmFnZXIoenJJZCwgc3ZnUm9vdCkge1xuICBEZWZpbmFibGUuY2FsbCh0aGlzLCB6cklkLCBzdmdSb290LCBbJ2xpbmVhckdyYWRpZW50JywgJ3JhZGlhbEdyYWRpZW50J10sICdfX2dyYWRpZW50X2luX3VzZV9fJyk7XG59XG5cbnpyVXRpbC5pbmhlcml0cyhHcmFkaWVudE1hbmFnZXIsIERlZmluYWJsZSk7XG4vKipcbiAqIENyZWF0ZSBuZXcgZ3JhZGllbnQgRE9NIGZvciBmaWxsIG9yIHN0cm9rZSBpZiBub3QgZXhpc3QsXG4gKiBidXQgd2lsbCBub3QgdXBkYXRlIGdyYWRpZW50IGlmIGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N2Z0VsZW1lbnR9ICBzdmdFbGVtZW50ICAgU1ZHIGVsZW1lbnQgdG8gcGFpbnRcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlICB6cmVuZGVyIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqL1xuXG5HcmFkaWVudE1hbmFnZXIucHJvdG90eXBlLmFkZFdpdGhvdXRVcGRhdGUgPSBmdW5jdGlvbiAoc3ZnRWxlbWVudCwgZGlzcGxheWFibGUpIHtcbiAgaWYgKGRpc3BsYXlhYmxlICYmIGRpc3BsYXlhYmxlLnN0eWxlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHpyVXRpbC5lYWNoKFsnZmlsbCcsICdzdHJva2UnXSwgZnVuY3Rpb24gKGZpbGxPclN0cm9rZSkge1xuICAgICAgaWYgKGRpc3BsYXlhYmxlLnN0eWxlW2ZpbGxPclN0cm9rZV0gJiYgKGRpc3BsYXlhYmxlLnN0eWxlW2ZpbGxPclN0cm9rZV0udHlwZSA9PT0gJ2xpbmVhcicgfHwgZGlzcGxheWFibGUuc3R5bGVbZmlsbE9yU3Ryb2tlXS50eXBlID09PSAncmFkaWFsJykpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gZGlzcGxheWFibGUuc3R5bGVbZmlsbE9yU3Ryb2tlXTtcbiAgICAgICAgdmFyIGRlZnMgPSB0aGF0LmdldERlZnModHJ1ZSk7IC8vIENyZWF0ZSBkb20gaW4gPGRlZnM+IGlmIG5vdCBleGlzdHNcblxuICAgICAgICB2YXIgZG9tO1xuXG4gICAgICAgIGlmIChncmFkaWVudC5fZG9tKSB7XG4gICAgICAgICAgLy8gR3JhZGllbnQgZXhpc3RzXG4gICAgICAgICAgZG9tID0gZ3JhZGllbnQuX2RvbTtcblxuICAgICAgICAgIGlmICghZGVmcy5jb250YWlucyhncmFkaWVudC5fZG9tKSkge1xuICAgICAgICAgICAgLy8gX2RvbSBpcyBubyBsb25nZXIgaW4gZGVmcywgcmVjcmVhdGVcbiAgICAgICAgICAgIHRoYXQuYWRkRG9tKGRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5ldyBkb21cbiAgICAgICAgICBkb20gPSB0aGF0LmFkZChncmFkaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0Lm1hcmtVc2VkKGRpc3BsYXlhYmxlKTtcbiAgICAgICAgdmFyIGlkID0gZG9tLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoZmlsbE9yU3Ryb2tlLCAndXJsKCMnICsgaWQgKyAnKScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuLyoqXG4gKiBBZGQgYSBuZXcgZ3JhZGllbnQgdGFnIGluIDxkZWZzPlxuICpcbiAqIEBwYXJhbSAgIHtHcmFkaWVudH0gZ3JhZGllbnQgenIgZ3JhZGllbnQgaW5zdGFuY2VcbiAqIEByZXR1cm4ge1NWR0xpbmVhckdyYWRpZW50RWxlbWVudCB8IFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudH1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQgRE9NXG4gKi9cblxuXG5HcmFkaWVudE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChncmFkaWVudCkge1xuICB2YXIgZG9tO1xuXG4gIGlmIChncmFkaWVudC50eXBlID09PSAnbGluZWFyJykge1xuICAgIGRvbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnbGluZWFyR3JhZGllbnQnKTtcbiAgfSBlbHNlIGlmIChncmFkaWVudC50eXBlID09PSAncmFkaWFsJykge1xuICAgIGRvbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgncmFkaWFsR3JhZGllbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dFcnJvcignSWxsZWdhbCBncmFkaWVudCB0eXBlLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFNldCBkb20gaWQgd2l0aCBncmFkaWVudCBpZCwgc2luY2UgZWFjaCBncmFkaWVudCBpbnN0YW5jZVxuICAvLyB3aWxsIGhhdmUgbm8gbW9yZSB0aGFuIG9uZSBkb20gZWxlbWVudC5cbiAgLy8gaWQgbWF5IGV4aXN0cyBiZWZvcmUgZm9yIHRob3NlIGRpcnR5IGVsZW1lbnRzLCBpbiB3aGljaCBjYXNlXG4gIC8vIGlkIHNob3VsZCByZW1haW4gdGhlIHNhbWUsIGFuZCBvdGhlciBhdHRyaWJ1dGVzIHNob3VsZCBiZVxuICAvLyB1cGRhdGVkLlxuXG5cbiAgZ3JhZGllbnQuaWQgPSBncmFkaWVudC5pZCB8fCB0aGlzLm5leHRJZCsrO1xuICBkb20uc2V0QXR0cmlidXRlKCdpZCcsICd6cicgKyB0aGlzLl96cklkICsgJy1ncmFkaWVudC0nICsgZ3JhZGllbnQuaWQpO1xuICB0aGlzLnVwZGF0ZURvbShncmFkaWVudCwgZG9tKTtcbiAgdGhpcy5hZGREb20oZG9tKTtcbiAgcmV0dXJuIGRvbTtcbn07XG4vKipcbiAqIFVwZGF0ZSBncmFkaWVudC5cbiAqXG4gKiBAcGFyYW0ge0dyYWRpZW50fSBncmFkaWVudCB6ciBncmFkaWVudCBpbnN0YW5jZVxuICovXG5cblxuR3JhZGllbnRNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZ3JhZGllbnQpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBEZWZpbmFibGUucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGdyYWRpZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSBncmFkaWVudC50eXBlO1xuICAgIHZhciB0YWdOYW1lID0gZ3JhZGllbnQuX2RvbS50YWdOYW1lO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lYXInICYmIHRhZ05hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgdHlwZSA9PT0gJ3JhZGlhbCcgJiYgdGFnTmFtZSA9PT0gJ3JhZGlhbEdyYWRpZW50Jykge1xuICAgICAgLy8gR3JhZGllbnQgdHlwZSBpcyBub3QgY2hhbmdlZCwgdXBkYXRlIGdyYWRpZW50XG4gICAgICB0aGF0LnVwZGF0ZURvbShncmFkaWVudCwgZ3JhZGllbnQuX2RvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBhbmQgcmUtY3JlYXRlIGlmIHR5cGUgaXMgY2hhbmdlZFxuICAgICAgdGhhdC5yZW1vdmVEb20oZ3JhZGllbnQpO1xuICAgICAgdGhhdC5hZGQoZ3JhZGllbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBVcGRhdGUgZ3JhZGllbnQgZG9tXG4gKlxuICogQHBhcmFtIHtHcmFkaWVudH0gZ3JhZGllbnQgenIgZ3JhZGllbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7U1ZHTGluZWFyR3JhZGllbnRFbGVtZW50IHwgU1ZHUmFkaWFsR3JhZGllbnRFbGVtZW50fSBkb21cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTSB0byB1cGRhdGVcbiAqL1xuXG5cbkdyYWRpZW50TWFuYWdlci5wcm90b3R5cGUudXBkYXRlRG9tID0gZnVuY3Rpb24gKGdyYWRpZW50LCBkb20pIHtcbiAgaWYgKGdyYWRpZW50LnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneDEnLCBncmFkaWVudC54KTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd5MScsIGdyYWRpZW50LnkpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3gyJywgZ3JhZGllbnQueDIpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3kyJywgZ3JhZGllbnQueTIpO1xuICB9IGVsc2UgaWYgKGdyYWRpZW50LnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY3gnLCBncmFkaWVudC54KTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjeScsIGdyYWRpZW50LnkpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3InLCBncmFkaWVudC5yKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dFcnJvcignSWxsZWdhbCBncmFkaWVudCB0eXBlLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChncmFkaWVudC5nbG9iYWwpIHtcbiAgICAvLyB4MSwgeDIsIHkxLCB5MiBpbiByYW5nZSBvZiAwIHRvIGNhbnZhcyB3aWR0aCBvciBoZWlnaHRcbiAgICBkb20uc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8geDEsIHgyLCB5MSwgeTIgaW4gcmFuZ2Ugb2YgMCB0byAxXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xuICB9IC8vIFJlbW92ZSBjb2xvciBzdG9wcyBpZiBleGlzdHNcblxuXG4gIGRvbS5pbm5lckhUTUwgPSAnJzsgLy8gQWRkIGNvbG9yIHN0b3BzXG5cbiAgdmFyIGNvbG9ycyA9IGdyYWRpZW50LmNvbG9yU3RvcHM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBzdG9wID0gdGhpcy5jcmVhdGVFbGVtZW50KCdzdG9wJyk7XG4gICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNvbG9yc1tpXS5vZmZzZXQgKiAxMDAgKyAnJScpO1xuICAgIHZhciBjb2xvciA9IGNvbG9yc1tpXS5jb2xvcjtcblxuICAgIGlmIChjb2xvci5pbmRleE9mKCdyZ2JhJykgPiAtMSkge1xuICAgICAgLy8gRml4IFNhZmFyaSBidWcgdGhhdCBzdG9wLWNvbG9yIG5vdCByZWNvZ25pemluZyBhbHBoYSAjOTAxNFxuICAgICAgdmFyIG9wYWNpdHkgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpWzNdO1xuICAgICAgdmFyIGhleCA9IGNvbG9yVG9vbC50b0hleChjb2xvcik7IC8vIHN0b3AtY29sb3IgY2Fubm90IGJlIGNvbG9yLCBzaW5jZTpcbiAgICAgIC8vIFRoZSBvcGFjaXR5IHZhbHVlIHVzZWQgZm9yIHRoZSBncmFkaWVudCBjYWxjdWxhdGlvbiBpcyB0aGVcbiAgICAgIC8vICpwcm9kdWN0KiBvZiB0aGUgdmFsdWUgb2Ygc3RvcC1vcGFjaXR5IGFuZCB0aGUgb3BhY2l0eSBvZiB0aGVcbiAgICAgIC8vIHZhbHVlIG9mIHN0b3AtY29sb3IuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzIvcHNlcnZlcnMuaHRtbCNTdG9wT3BhY2l0eVByb3BlcnR5XG5cbiAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJyMnICsgaGV4KTtcbiAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknLCBvcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InLCBjb2xvcnNbaV0uY29sb3IpO1xuICAgIH1cblxuICAgIGRvbS5hcHBlbmRDaGlsZChzdG9wKTtcbiAgfSAvLyBTdG9yZSBkb20gZWxlbWVudCBpbiBncmFkaWVudCwgdG8gYXZvaWQgY3JlYXRpbmcgbXVsdGlwbGVcbiAgLy8gZG9tIGluc3RhbmNlcyBmb3IgdGhlIHNhbWUgZ3JhZGllbnQgZWxlbWVudFxuXG5cbiAgZ3JhZGllbnQuX2RvbSA9IGRvbTtcbn07XG4vKipcbiAqIE1hcmsgYSBzaW5nbGUgZ3JhZGllbnQgdG8gYmUgdXNlZFxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqL1xuXG5cbkdyYWRpZW50TWFuYWdlci5wcm90b3R5cGUubWFya1VzZWQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgaWYgKGRpc3BsYXlhYmxlLnN0eWxlKSB7XG4gICAgdmFyIGdyYWRpZW50ID0gZGlzcGxheWFibGUuc3R5bGUuZmlsbDtcblxuICAgIGlmIChncmFkaWVudCAmJiBncmFkaWVudC5fZG9tKSB7XG4gICAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhpcywgZ3JhZGllbnQuX2RvbSk7XG4gICAgfVxuXG4gICAgZ3JhZGllbnQgPSBkaXNwbGF5YWJsZS5zdHlsZS5zdHJva2U7XG5cbiAgICBpZiAoZ3JhZGllbnQgJiYgZ3JhZGllbnQuX2RvbSkge1xuICAgICAgRGVmaW5hYmxlLnByb3RvdHlwZS5tYXJrVXNlZC5jYWxsKHRoaXMsIGdyYWRpZW50Ll9kb20pO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9kZWZhdWx0ID0gR3JhZGllbnRNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgRGVmaW5hYmxlID0gcmVxdWlyZShcIi4vRGVmaW5hYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNWRyBzaGFkb3cgZWxlbWVudHMuXG4gKiBAYXV0aG9yIFpoYW5nIFdlbmxpXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIFNWRyBzaGFkb3cgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBEZWZpbmFibGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgICB6cklkICAgIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEBwYXJhbSAgIHtTVkdFbGVtZW50fSBzdmdSb290IHJvb3Qgb2YgU1ZHIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIFNoYWRvd01hbmFnZXIoenJJZCwgc3ZnUm9vdCkge1xuICBEZWZpbmFibGUuY2FsbCh0aGlzLCB6cklkLCBzdmdSb290LCBbJ2ZpbHRlciddLCAnX19maWx0ZXJfaW5fdXNlX18nLCAnX3NoYWRvd0RvbScpO1xufVxuXG56clV0aWwuaW5oZXJpdHMoU2hhZG93TWFuYWdlciwgRGVmaW5hYmxlKTtcbi8qKlxuICogQ3JlYXRlIG5ldyBzaGFkb3cgRE9NIGZvciBmaWxsIG9yIHN0cm9rZSBpZiBub3QgZXhpc3QsXG4gKiBidXQgd2lsbCBub3QgdXBkYXRlIHNoYWRvdyBpZiBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdmdFbGVtZW50fSAgc3ZnRWxlbWVudCAgIFNWRyBlbGVtZW50IHRvIHBhaW50XG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSAgenJlbmRlciBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKi9cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUuYWRkV2l0aG91dFVwZGF0ZSA9IGZ1bmN0aW9uIChzdmdFbGVtZW50LCBkaXNwbGF5YWJsZSkge1xuICBpZiAoZGlzcGxheWFibGUgJiYgaGFzU2hhZG93KGRpc3BsYXlhYmxlLnN0eWxlKSkge1xuICAgIC8vIENyZWF0ZSBkb20gaW4gPGRlZnM+IGlmIG5vdCBleGlzdHNcbiAgICB2YXIgZG9tO1xuXG4gICAgaWYgKGRpc3BsYXlhYmxlLl9zaGFkb3dEb20pIHtcbiAgICAgIC8vIEdyYWRpZW50IGV4aXN0c1xuICAgICAgZG9tID0gZGlzcGxheWFibGUuX3NoYWRvd0RvbTtcbiAgICAgIHZhciBkZWZzID0gdGhpcy5nZXREZWZzKHRydWUpO1xuXG4gICAgICBpZiAoIWRlZnMuY29udGFpbnMoZGlzcGxheWFibGUuX3NoYWRvd0RvbSkpIHtcbiAgICAgICAgLy8gX3NoYWRvd0RvbSBpcyBubyBsb25nZXIgaW4gZGVmcywgcmVjcmVhdGVcbiAgICAgICAgdGhpcy5hZGREb20oZG9tKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IGRvbVxuICAgICAgZG9tID0gdGhpcy5hZGQoZGlzcGxheWFibGUpO1xuICAgIH1cblxuICAgIHRoaXMubWFya1VzZWQoZGlzcGxheWFibGUpO1xuICAgIHZhciBpZCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgc3ZnRWxlbWVudC5zdHlsZS5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gIH1cbn07XG4vKipcbiAqIEFkZCBhIG5ldyBzaGFkb3cgdGFnIGluIDxkZWZzPlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlICB6cmVuZGVyIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NWR0ZpbHRlckVsZW1lbnR9IGNyZWF0ZWQgRE9NXG4gKi9cblxuXG5TaGFkb3dNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgdmFyIGRvbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZmlsdGVyJyk7IC8vIFNldCBkb20gaWQgd2l0aCBzaGFkb3cgaWQsIHNpbmNlIGVhY2ggc2hhZG93IGluc3RhbmNlXG4gIC8vIHdpbGwgaGF2ZSBubyBtb3JlIHRoYW4gb25lIGRvbSBlbGVtZW50LlxuICAvLyBpZCBtYXkgZXhpc3RzIGJlZm9yZSBmb3IgdGhvc2UgZGlydHkgZWxlbWVudHMsIGluIHdoaWNoIGNhc2VcbiAgLy8gaWQgc2hvdWxkIHJlbWFpbiB0aGUgc2FtZSwgYW5kIG90aGVyIGF0dHJpYnV0ZXMgc2hvdWxkIGJlXG4gIC8vIHVwZGF0ZWQuXG5cbiAgZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkID0gZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkIHx8IHRoaXMubmV4dElkKys7XG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3pyJyArIHRoaXMuX3pySWQgKyAnLXNoYWRvdy0nICsgZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkKTtcbiAgdGhpcy51cGRhdGVEb20oZGlzcGxheWFibGUsIGRvbSk7XG4gIHRoaXMuYWRkRG9tKGRvbSk7XG4gIHJldHVybiBkb207XG59O1xuLyoqXG4gKiBVcGRhdGUgc2hhZG93LlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlICB6cmVuZGVyIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqL1xuXG5cblNoYWRvd01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzdmdFbGVtZW50LCBkaXNwbGF5YWJsZSkge1xuICB2YXIgc3R5bGUgPSBkaXNwbGF5YWJsZS5zdHlsZTtcblxuICBpZiAoaGFzU2hhZG93KHN0eWxlKSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBEZWZpbmFibGUucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGRpc3BsYXlhYmxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnVwZGF0ZURvbShkaXNwbGF5YWJsZSwgZGlzcGxheWFibGUuX3NoYWRvd0RvbSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVtb3ZlIHNoYWRvd1xuICAgIHRoaXMucmVtb3ZlKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgfVxufTtcbi8qKlxuICogUmVtb3ZlIERPTSBhbmQgY2xlYXIgcGFyZW50IGZpbHRlclxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKSB7XG4gIGlmIChkaXNwbGF5YWJsZS5fc2hhZG93RG9tSWQgIT0gbnVsbCkge1xuICAgIHRoaXMucmVtb3ZlRG9tKHN2Z0VsZW1lbnQpO1xuICAgIHN2Z0VsZW1lbnQuc3R5bGUuZmlsdGVyID0gJyc7XG4gIH1cbn07XG4vKipcbiAqIFVwZGF0ZSBzaGFkb3cgZG9tXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgIHpyZW5kZXIgZGlzcGxheWFibGUgZWxlbWVudFxuICogQHBhcmFtIHtTVkdGaWx0ZXJFbGVtZW50fSBkb20gRE9NIHRvIHVwZGF0ZVxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUudXBkYXRlRG9tID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlLCBkb20pIHtcbiAgdmFyIGRvbUNoaWxkID0gZG9tLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmZURyb3BTaGFkb3cnKTtcblxuICBpZiAoZG9tQ2hpbGQubGVuZ3RoID09PSAwKSB7XG4gICAgZG9tQ2hpbGQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ZlRHJvcFNoYWRvdycpO1xuICB9IGVsc2Uge1xuICAgIGRvbUNoaWxkID0gZG9tQ2hpbGRbMF07XG4gIH1cblxuICB2YXIgc3R5bGUgPSBkaXNwbGF5YWJsZS5zdHlsZTtcbiAgdmFyIHNjYWxlWCA9IGRpc3BsYXlhYmxlLnNjYWxlID8gZGlzcGxheWFibGUuc2NhbGVbMF0gfHwgMSA6IDE7XG4gIHZhciBzY2FsZVkgPSBkaXNwbGF5YWJsZS5zY2FsZSA/IGRpc3BsYXlhYmxlLnNjYWxlWzFdIHx8IDEgOiAxOyAvLyBUT0RPOiB0ZXh0Qm94U2hhZG93Qmx1ciBpcyBub3Qgc3VwcG9ydGVkIHlldFxuXG4gIHZhciBvZmZzZXRYO1xuICB2YXIgb2Zmc2V0WTtcbiAgdmFyIGJsdXI7XG4gIHZhciBjb2xvcjtcblxuICBpZiAoc3R5bGUuc2hhZG93Qmx1ciB8fCBzdHlsZS5zaGFkb3dPZmZzZXRYIHx8IHN0eWxlLnNoYWRvd09mZnNldFkpIHtcbiAgICBvZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCAwO1xuICAgIG9mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZIHx8IDA7XG4gICAgYmx1ciA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgY29sb3IgPSBzdHlsZS5zaGFkb3dDb2xvcjtcbiAgfSBlbHNlIGlmIChzdHlsZS50ZXh0U2hhZG93Qmx1cikge1xuICAgIG9mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwO1xuICAgIG9mZnNldFkgPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwO1xuICAgIGJsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICBjb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgc2hhZG93XG4gICAgdGhpcy5yZW1vdmVEb20oZG9tLCBzdHlsZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZG9tQ2hpbGQuc2V0QXR0cmlidXRlKCdkeCcsIG9mZnNldFggLyBzY2FsZVgpO1xuICBkb21DaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5Jywgb2Zmc2V0WSAvIHNjYWxlWSk7XG4gIGRvbUNoaWxkLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCBjb2xvcik7IC8vIERpdmlkZSBieSB0d28gaGVyZSBzbyB0aGF0IGl0IGxvb2tzIHRoZSBzYW1lIGFzIGluIGNhbnZhc1xuICAvLyBTZWU6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NhbnZhcy5odG1sI2RvbS1jb250ZXh0LTJkLXNoYWRvd2JsdXJcblxuICB2YXIgc3RkRHggPSBibHVyIC8gMiAvIHNjYWxlWDtcbiAgdmFyIHN0ZER5ID0gYmx1ciAvIDIgLyBzY2FsZVk7XG4gIHZhciBzdGREZXZpYXRpb24gPSBzdGREeCArICcgJyArIHN0ZER5O1xuICBkb21DaGlsZC5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHN0ZERldmlhdGlvbik7IC8vIEZpeCBmaWx0ZXIgY2xpcHBpbmcgcHJvYmxlbVxuXG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcbiAgZG9tLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICBkb20uc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGguY2VpbChibHVyIC8gMiAqIDIwMCkgKyAnJScpO1xuICBkb20uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLmNlaWwoYmx1ciAvIDIgKiAyMDApICsgJyUnKTtcbiAgZG9tLmFwcGVuZENoaWxkKGRvbUNoaWxkKTsgLy8gU3RvcmUgZG9tIGVsZW1lbnQgaW4gc2hhZG93LCB0byBhdm9pZCBjcmVhdGluZyBtdWx0aXBsZVxuICAvLyBkb20gaW5zdGFuY2VzIGZvciB0aGUgc2FtZSBzaGFkb3cgZWxlbWVudFxuXG4gIGRpc3BsYXlhYmxlLl9zaGFkb3dEb20gPSBkb207XG59O1xuLyoqXG4gKiBNYXJrIGEgc2luZ2xlIHNoYWRvdyB0byBiZSB1c2VkXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgZGlzcGxheWFibGUgZWxlbWVudFxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUubWFya1VzZWQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgaWYgKGRpc3BsYXlhYmxlLl9zaGFkb3dEb20pIHtcbiAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhpcywgZGlzcGxheWFibGUuX3NoYWRvd0RvbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhc1NoYWRvdyhzdHlsZSkge1xuICAvLyBUT0RPOiB0ZXh0Qm94U2hhZG93Qmx1ciBpcyBub3Qgc3VwcG9ydGVkIHlldFxuICByZXR1cm4gc3R5bGUgJiYgKHN0eWxlLnNoYWRvd0JsdXIgfHwgc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCBzdHlsZS5zaGFkb3dPZmZzZXRZIHx8IHN0eWxlLnRleHRTaGFkb3dCbHVyIHx8IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gU2hhZG93TWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7IiwicmVxdWlyZShcIi4vZ3JhcGhpY1wiKTtcblxudmFyIF96cmVuZGVyID0gcmVxdWlyZShcIi4uL3pyZW5kZXJcIik7XG5cbnZhciByZWdpc3RlclBhaW50ZXIgPSBfenJlbmRlci5yZWdpc3RlclBhaW50ZXI7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxucmVnaXN0ZXJQYWludGVyKCdzdmcnLCBQYWludGVyKTsiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uL2NvcmUvTFJVXCIpO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICd0cmFuc3BhcmVudCc6IFswLCAwLCAwLCAwXSxcbiAgJ2FsaWNlYmx1ZSc6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgJ2FxdWEnOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAnYmVpZ2UnOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICdiaXNxdWUnOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICdibGFjayc6IFswLCAwLCAwLCAxXSxcbiAgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLFxuICAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAnYnJvd24nOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAnYnVybHl3b29kJzogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAnY2FkZXRibHVlJzogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICdjaGFydHJldXNlJzogWzEyNywgMjU1LCAwLCAxXSxcbiAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAnY29ybnNpbGsnOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICdjcmltc29uJzogWzIyMCwgMjAsIDYwLCAxXSxcbiAgJ2N5YW4nOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgJ2RhcmtncmF5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2dyZWVuJzogWzAsIDEwMCwgMCwgMV0sXG4gICdkYXJrZ3JleSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgJ2RhcmtvcmFuZ2UnOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAnZGFya29yY2hpZCc6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAnZGFya3JlZCc6IFsxMzksIDAsIDAsIDFdLFxuICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsIDYxLCAxMzksIDFdLFxuICAnZGFya3NsYXRlZ3JheSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrdHVycXVvaXNlJzogWzAsIDIwNiwgMjA5LCAxXSxcbiAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgJ2RlZXBza3libHVlJzogWzAsIDE5MSwgMjU1LCAxXSxcbiAgJ2RpbWdyYXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkaW1ncmV5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZG9kZ2VyYmx1ZSc6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSxcbiAgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAnZm9yZXN0Z3JlZW4nOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAnZnVjaHNpYSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdnYWluc2Jvcm8nOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICdnaG9zdHdoaXRlJzogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgJ2dyYXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdncmVlbic6IFswLCAxMjgsIDAsIDFdLFxuICAnZ3JlZW55ZWxsb3cnOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgJ2dyZXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICdpbmRpYW5yZWQnOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAnaW5kaWdvJzogWzc1LCAwLCAxMzAsIDFdLFxuICAnaXZvcnknOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICdraGFraSc6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgJ2xhd25ncmVlbic6IFsxMjQsIDI1MiwgMCwgMV0sXG4gICdsZW1vbmNoaWZmb24nOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICdsaWdodGJsdWUnOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICdsaWdodGNvcmFsJzogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICdsaWdodGdyYXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodGdyZWVuJzogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAnbGlnaHRncmV5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRwaW5rJzogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICdsaWdodHNreWJsdWUnOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICdsaWdodHNsYXRlZ3JheSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgJ2xpbWVncmVlbic6IFs1MCwgMjA1LCA1MCwgMV0sXG4gICdsaW5lbic6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgJ21hZ2VudGEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnbWFyb29uJzogWzEyOCwgMCwgMCwgMV0sXG4gICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAnbWVkaXVtb3JjaGlkJzogWzE4NiwgODUsIDIxMSwgMV0sXG4gICdtZWRpdW1wdXJwbGUnOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICdtZWRpdW1zZWFncmVlbic6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwgMjUsIDExMiwgMV0sXG4gICdtaW50Y3JlYW0nOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICdtaXN0eXJvc2UnOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAnbmF2eSc6IFswLCAwLCAxMjgsIDFdLFxuICAnb2xkbGFjZSc6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgJ29saXZlJzogWzEyOCwgMTI4LCAwLCAxXSxcbiAgJ29saXZlZHJhYic6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSxcbiAgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgJ29yY2hpZCc6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICdwYWxlZ3JlZW4nOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICdwYWxldHVycXVvaXNlJzogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICdwZWFjaHB1ZmYnOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICdwZXJ1JzogWzIwNSwgMTMzLCA2MywgMV0sXG4gICdwaW5rJzogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAncGx1bSc6IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAncmVkJzogWzI1NSwgMCwgMCwgMV0sXG4gICdyb3N5YnJvd24nOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICdyb3lhbGJsdWUnOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgJ3NhZGRsZWJyb3duJzogWzEzOSwgNjksIDE5LCAxXSxcbiAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgJ3NlYWdyZWVuJzogWzQ2LCAxMzksIDg3LCAxXSxcbiAgJ3NlYXNoZWxsJzogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAnc2llbm5hJzogWzE2MCwgODIsIDQ1LCAxXSxcbiAgJ3NpbHZlcic6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgJ3NsYXRlZ3JheSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3NsYXRlZ3JleSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3Nub3cnOiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICdzcHJpbmdncmVlbic6IFswLCAyNTUsIDEyNywgMV0sXG4gICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgJ3RlYWwnOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAndGhpc3RsZSc6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgJ3RvbWF0byc6IFsyNTUsIDk5LCA3MSwgMV0sXG4gICd0dXJxdW9pc2UnOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAnd2hpdGUnOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICd3aGl0ZXNtb2tlJzogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAneWVsbG93JzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgJ3llbGxvd2dyZWVuJzogWzE1NCwgMjA1LCA1MCwgMV1cbn07XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikge1xuICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikge1xuICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDE7XG4gIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICBoIC09IDE7XG4gIH1cblxuICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIH1cblxuICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgaWYgKGggKiAzIDwgMikge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgfVxuXG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gIG91dFswXSA9IHI7XG4gIG91dFsxXSA9IGc7XG4gIG91dFsyXSA9IGI7XG4gIG91dFszXSA9IGE7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgfVxuXG4gIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IHJnYmFBcnIuc2xpY2UoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICB9IC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG5cblxuICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7IC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuXG4gIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgIHJldHVybiByZ2JhQXJyO1xuICB9IC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG5cbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGZmMDAwMCkgPj4gMTYsIChpdiAmIDB4ZmYwMCkgPj4gOCwgaXYgJiAweGZmLCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKTtcbiAgdmFyIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBhbHBoYSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICovXG5cblxuZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgdmFyIGggPSAocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuXG4gIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgcmdiYSA9IHJnYmEgfHwgW107XG4gIHNldFJnYmEocmdiYSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIDEpO1xuXG4gIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cblxuXG5mdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICBpZiAoIXJnYmEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUkdCIGZyb20gMCB0byAyNTVcblxuXG4gIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG4gIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgdmFyIEg7XG4gIHZhciBTOyAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIEggPSAwO1xuICAgIFMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChMIDwgMC41KSB7XG4gICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFSID0gKCh2TWF4IC0gUikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUcgPSAoKHZNYXggLSBHKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhQiA9ICgodk1heCAtIEIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcblxuICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgIH0gZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgSCA9IDEgLyAzICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgIH0gZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgSCA9IDIgLyAzICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgIH1cblxuICAgIGlmIChIIDwgMCkge1xuICAgICAgSCArPSAxO1xuICAgIH1cblxuICAgIGlmIChIID4gMSkge1xuICAgICAgSCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gIH1cblxuICByZXR1cm4gaHNsYTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0gfCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3JBcnJbaV0gPiAyNTUpIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAyNTU7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yW2ldIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyArY29sb3JBcnJbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgfVxufVxuLyoqXG4gKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICovXG5cblxuZnVuY3Rpb24gZmFzdExlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXQgPSBvdXQgfHwgW107XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLCBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXSwgJ3JnYmEnKTtcbiAgcmV0dXJuIGZ1bGxPdXRwdXQgPyB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0gOiBjb2xvcjtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBtYXBUb0NvbG9yID0gbGVycDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcblxuICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLmZhc3RMZXJwID0gZmFzdExlcnA7XG5leHBvcnRzLmZhc3RNYXBUb0NvbG9yID0gZmFzdE1hcFRvQ29sb3I7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXBUb0NvbG9yID0gbWFwVG9Db2xvcjtcbmV4cG9ydHMubW9kaWZ5SFNMID0gbW9kaWZ5SFNMO1xuZXhwb3J0cy5tb2RpZnlBbHBoYSA9IG1vZGlmeUFscGhhO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7IiwidmFyIEdyb3VwID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1RleHRcIik7XG5cbnZhciBDaXJjbGUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9DaXJjbGVcIik7XG5cbnZhciBSZWN0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvc2hhcGUvUmVjdFwiKTtcblxudmFyIEVsbGlwc2UgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9FbGxpcHNlXCIpO1xuXG52YXIgTGluZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL3NoYXBlL0xpbmVcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBvbHlnb24gPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uXCIpO1xuXG52YXIgUG9seWxpbmUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVwiKTtcblxudmFyIExpbmVhckdyYWRpZW50ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvTGluZWFyR3JhZGllbnRcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1N0eWxlXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xuXG52YXIgY3JlYXRlRnJvbVN0cmluZyA9IF9wYXRoLmNyZWF0ZUZyb21TdHJpbmc7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciBkZWZhdWx0cyA9IF91dGlsLmRlZmF1bHRzO1xudmFyIHRyaW0gPSBfdXRpbC50cmltO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuLy8gaW1wb3J0IFJhZGlhbEdyYWRpZW50IGZyb20gJy4uL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQnO1xuLy8gaW1wb3J0IFBhdHRlcm4gZnJvbSAnLi4vZ3JhcGhpYy9QYXR0ZXJuJztcbi8vIGltcG9ydCAqIGFzIHZlY3RvciBmcm9tICcuLi9jb3JlL3ZlY3Rvcic7XG4vLyBNb3N0IG9mIHRoZSB2YWx1ZXMgY2FuIGJlIHNlcGFyYXRlZCBieSBjb21tYSBhbmQvb3Igd2hpdGUgc3BhY2UuXG52YXIgRElMSU1JVEVSX1JFRyA9IC9bXFxzLF0rLztcbi8qKlxuICogRm9yIGJpZyBzdmcgc3RyaW5nLCB0aGlzIG1ldGhvZCBtaWdodCBiZSB0aW1lIGNvbnN1bWluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ZnIHhtbCBzdHJpbmdcbiAqIEByZXR1cm4ge09iamVjdH0geG1sIHJvb3QuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VYTUwoc3ZnKSB7XG4gIGlmIChpc1N0cmluZyhzdmcpKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBzdmcgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2ZywgJ3RleHQveG1sJyk7XG4gIH0gLy8gRG9jdW1lbnQgbm9kZS4gSWYgdXNpbmcgJC5nZXQsIGRvYyBub2RlIG1heSBiZSBpbnB1dC5cblxuXG4gIGlmIChzdmcubm9kZVR5cGUgPT09IDkpIHtcbiAgICBzdmcgPSBzdmcuZmlyc3RDaGlsZDtcbiAgfSAvLyBub2RlTmFtZSBvZiA8IURPQ1RZUEUgc3ZnPiBpcyBhbHNvICdzdmcnLlxuXG5cbiAgd2hpbGUgKHN2Zy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJyB8fCBzdmcubm9kZVR5cGUgIT09IDEpIHtcbiAgICBzdmcgPSBzdmcubmV4dFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gc3ZnO1xufVxuXG5mdW5jdGlvbiBTVkdQYXJzZXIoKSB7XG4gIHRoaXMuX2RlZnMgPSB7fTtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX2lzRGVmaW5lID0gZmFsc2U7XG4gIHRoaXMuX2lzVGV4dCA9IGZhbHNlO1xufVxuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhtbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHN2ZyA9IHBhcnNlWE1MKHhtbCk7XG5cbiAgaWYgKCFzdmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc3ZnJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IG5ldyBHcm91cCgpO1xuICB0aGlzLl9yb290ID0gcm9vdDsgLy8gcGFyc2UgdmlldyBwb3J0XG5cbiAgdmFyIHZpZXdCb3ggPSBzdmcuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJyc7IC8vIElmIHdpZHRoL2hlaWdodCBub3Qgc3BlY2lmaWVkLCBtZWFucyBcIjEwMCVcIiBvZiBgb3B0LndpZHRoL2hlaWdodGAuXG4gIC8vIFRPRE86IE90aGVyIHBlcmNlbnQgdmFsdWUgbm90IHN1cHBvcnRlZCB5ZXQuXG5cbiAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IG9wdC53aWR0aCk7XG4gIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IG9wdC5oZWlnaHQpOyAvLyBJZiB3aWR0aC9oZWlnaHQgbm90IHNwZWNpZmllZCwgc2V0IGFzIG51bGwgZm9yIG91dHB1dC5cblxuICBpc05hTih3aWR0aCkgJiYgKHdpZHRoID0gbnVsbCk7XG4gIGlzTmFOKGhlaWdodCkgJiYgKGhlaWdodCA9IG51bGwpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGUgb24gc3ZnIGVsZW1lbnQuXG5cbiAgcGFyc2VBdHRyaWJ1dGVzKHN2Zywgcm9vdCwgbnVsbCwgdHJ1ZSk7XG4gIHZhciBjaGlsZCA9IHN2Zy5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHRoaXMuX3BhcnNlTm9kZShjaGlsZCwgcm9vdCk7XG5cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIHZpZXdCb3hSZWN0O1xuICB2YXIgdmlld0JveFRyYW5zZm9ybTtcblxuICBpZiAodmlld0JveCkge1xuICAgIHZhciB2aWV3Qm94QXJyID0gdHJpbSh2aWV3Qm94KS5zcGxpdChESUxJTUlURVJfUkVHKTsgLy8gU29tZSBpbnZhbGlkIGNhc2UgbGlrZSB2aWV3Qm94OiAnbm9uZScuXG5cbiAgICBpZiAodmlld0JveEFyci5sZW5ndGggPj0gNCkge1xuICAgICAgdmlld0JveFJlY3QgPSB7XG4gICAgICAgIHg6IHBhcnNlRmxvYXQodmlld0JveEFyclswXSB8fCAwKSxcbiAgICAgICAgeTogcGFyc2VGbG9hdCh2aWV3Qm94QXJyWzFdIHx8IDApLFxuICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh2aWV3Qm94QXJyWzJdKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hBcnJbM10pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmICh2aWV3Qm94UmVjdCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtKHZpZXdCb3hSZWN0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmICghb3B0Lmlnbm9yZVZpZXdCb3gpIHtcbiAgICAgIC8vIElmIHNldCB0cmFuc2Zvcm0gb24gdGhlIG91dHB1dCBncm91cCwgaXQgcHJvYmFibHkgYnJpbmcgdHJvdWJsZSB3aGVuXG4gICAgICAvLyBzb21lIHVzZXJzIG9ubHkgaW50ZW5kIHRvIHNob3cgdGhlIGNsaXBwZWQgY29udGVudCBpbnNpZGUgdGhlIHZpZXdCb3gsXG4gICAgICAvLyBidXQgbm90IGludGVuZCB0byB0cmFuc2Zvcm0gdGhlIG91dHB1dCBncm91cC4gU28gd2Uga2VlcCB0aGUgb3V0cHV0XG4gICAgICAvLyBncm91cCBubyB0cmFuc2Zvcm0uIElmIHRoZSB1c2VyIGludGVuZCB0byB1c2UgdGhlIHZpZXdCb3ggYXMgYVxuICAgICAgLy8gY2FtZXJhLCBqdXN0IHNldCBgb3B0Lmlnbm9yZVZpZXdCb3hgIGFzIGB0cnVlYCBhbmQgc2V0IHRyYW5zZnJvbVxuICAgICAgLy8gbWFudWFsbHkgYWNjb3JkaW5nIHRvIHRoZSB2aWV3Qm94IGluZm8gaW4gdGhlIG91dHB1dCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgIHZhciBlbFJvb3QgPSByb290O1xuICAgICAgcm9vdCA9IG5ldyBHcm91cCgpO1xuICAgICAgcm9vdC5hZGQoZWxSb290KTtcbiAgICAgIGVsUm9vdC5zY2FsZSA9IHZpZXdCb3hUcmFuc2Zvcm0uc2NhbGUuc2xpY2UoKTtcbiAgICAgIGVsUm9vdC5wb3NpdGlvbiA9IHZpZXdCb3hUcmFuc2Zvcm0ucG9zaXRpb24uc2xpY2UoKTtcbiAgICB9XG4gIH0gLy8gU29tZSBzaGFwZXMgbWlnaHQgYmUgb3ZlcmZsb3cgdGhlIHZpZXdwb3J0LCB3aGljaCBzaG91bGQgYmVcbiAgLy8gY2xpcHBlZCBkZXNwaXRlIHdoZXRoZXIgdGhlIHZpZXdCb3ggaXMgdXNlZCwgYXMgdGhlIFNWRyBkb2VzLlxuXG5cbiAgaWYgKCFvcHQuaWdub3JlUm9vdENsaXAgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHJvb3Quc2V0Q2xpcFBhdGgobmV3IFJlY3Qoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfVxuICAgIH0pKTtcbiAgfSAvLyBTZXQgd2lkdGgvaGVpZ2h0IG9uIGdyb3VwIGp1c3QgZm9yIG91dHB1dCB0aGUgdmlld3BvcnQgc2l6ZS5cblxuXG4gIHJldHVybiB7XG4gICAgcm9vdDogcm9vdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmlld0JveFJlY3Q6IHZpZXdCb3hSZWN0LFxuICAgIHZpZXdCb3hUcmFuc2Zvcm06IHZpZXdCb3hUcmFuc2Zvcm1cbiAgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlTm9kZSA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICB2YXIgbm9kZU5hbWUgPSB4bWxOb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vIFRPRE9cbiAgLy8gc3VwcG9ydCA8c3R5bGU+Li4uPC9zdHlsZT4gaW4gc3ZnLCB3aGVyZSBub2RlTmFtZSBpcyAnc3R5bGUnLFxuICAvLyBDU1MgY2xhc3NlcyBpcyBkZWZpbmVkIGdsb2JhbGx5IHdoZXJldmVyIHRoZSBzdHlsZSB0YWdzIGFyZSBkZWNsYXJlZC5cblxuICBpZiAobm9kZU5hbWUgPT09ICdkZWZzJykge1xuICAgIC8vIGRlZmluZSBmbGFnXG4gICAgdGhpcy5faXNEZWZpbmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAndGV4dCcpIHtcbiAgICB0aGlzLl9pc1RleHQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVsO1xuXG4gIGlmICh0aGlzLl9pc0RlZmluZSkge1xuICAgIHZhciBwYXJzZXIgPSBkZWZpbmVQYXJzZXJzW25vZGVOYW1lXTtcblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHZhciBkZWYgPSBwYXJzZXIuY2FsbCh0aGlzLCB4bWxOb2RlKTtcbiAgICAgIHZhciBpZCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgdGhpcy5fZGVmc1tpZF0gPSBkZWY7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZXIgPSBub2RlUGFyc2Vyc1tub2RlTmFtZV07XG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBlbCA9IHBhcnNlci5jYWxsKHRoaXMsIHhtbE5vZGUsIHBhcmVudEdyb3VwKTtcbiAgICAgIHBhcmVudEdyb3VwLmFkZChlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0geG1sTm9kZS5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgdGhpcy5fcGFyc2VOb2RlKGNoaWxkLCBlbCk7XG4gICAgfSAvLyBJcyB0ZXh0XG5cblxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiB0aGlzLl9pc1RleHQpIHtcbiAgICAgIHRoaXMuX3BhcnNlVGV4dChjaGlsZCwgZWwpO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gIH0gLy8gUXVpdCBkZWZpbmVcblxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2RlZnMnKSB7XG4gICAgdGhpcy5faXNEZWZpbmUgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3RleHQnKSB7XG4gICAgdGhpcy5faXNUZXh0ID0gZmFsc2U7XG4gIH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGV4dCA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICBpZiAoeG1sTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHZhciBkeCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeCcpIHx8IDA7XG4gICAgdmFyIGR5ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R5JykgfHwgMDtcbiAgICB0aGlzLl90ZXh0WCArPSBwYXJzZUZsb2F0KGR4KTtcbiAgICB0aGlzLl90ZXh0WSArPSBwYXJzZUZsb2F0KGR5KTtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gbmV3IFRleHQoe1xuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0OiB4bWxOb2RlLnRleHRDb250ZW50LFxuICAgICAgdHJhbnNmb3JtVGV4dDogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpb246IFt0aGlzLl90ZXh0WCB8fCAwLCB0aGlzLl90ZXh0WSB8fCAwXVxuICB9KTtcbiAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCB0ZXh0KTtcbiAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHRleHQsIHRoaXMuX2RlZnMpO1xuICB2YXIgZm9udFNpemUgPSB0ZXh0LnN0eWxlLmZvbnRTaXplO1xuXG4gIGlmIChmb250U2l6ZSAmJiBmb250U2l6ZSA8IDkpIHtcbiAgICAvLyBQRU5ESU5HXG4gICAgdGV4dC5zdHlsZS5mb250U2l6ZSA9IDk7XG4gICAgdGV4dC5zY2FsZSA9IHRleHQuc2NhbGUgfHwgWzEsIDFdO1xuICAgIHRleHQuc2NhbGVbMF0gKj0gZm9udFNpemUgLyA5O1xuICAgIHRleHQuc2NhbGVbMV0gKj0gZm9udFNpemUgLyA5O1xuICB9XG5cbiAgdmFyIHJlY3QgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpO1xuICB0aGlzLl90ZXh0WCArPSByZWN0LndpZHRoO1xuICBwYXJlbnRHcm91cC5hZGQodGV4dCk7XG4gIHJldHVybiB0ZXh0O1xufTtcblxudmFyIG5vZGVQYXJzZXJzID0ge1xuICAnZyc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIGc7XG4gIH0sXG4gICdyZWN0JzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHJlY3QgPSBuZXcgUmVjdCgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgcmVjdCk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHJlY3QsIHRoaXMuX2RlZnMpO1xuICAgIHJlY3Quc2V0U2hhcGUoe1xuICAgICAgeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneCcpIHx8IDApLFxuICAgICAgeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneScpIHx8IDApLFxuICAgICAgd2lkdGg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IDApXG4gICAgfSk7IC8vIGNvbnNvbGUubG9nKHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG4gICAgLy8gY29uc29sZS5sb2cocmVjdC50cmFuc2Zvcm0pO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gICdjaXJjbGUnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICB2YXIgY2lyY2xlID0gbmV3IENpcmNsZSgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgY2lyY2xlKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgY2lyY2xlLCB0aGlzLl9kZWZzKTtcbiAgICBjaXJjbGUuc2V0U2hhcGUoe1xuICAgICAgY3g6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgMCksXG4gICAgICBjeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAwKSxcbiAgICAgIHI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBjaXJjbGU7XG4gIH0sXG4gICdsaW5lJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIGxpbmUgPSBuZXcgTGluZSgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgbGluZSk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGxpbmUsIHRoaXMuX2RlZnMpO1xuICAgIGxpbmUuc2V0U2hhcGUoe1xuICAgICAgeDE6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCksXG4gICAgICB5MTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwKSxcbiAgICAgIHgyOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MicpIHx8IDApLFxuICAgICAgeTI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZTtcbiAgfSxcbiAgJ2VsbGlwc2UnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICB2YXIgZWxsaXBzZSA9IG5ldyBFbGxpcHNlKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBlbGxpcHNlKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZWxsaXBzZSwgdGhpcy5fZGVmcyk7XG4gICAgZWxsaXBzZS5zZXRTaGFwZSh7XG4gICAgICBjeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAwKSxcbiAgICAgIGN5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeScpIHx8IDApLFxuICAgICAgcng6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykgfHwgMCksXG4gICAgICByeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgncnknKSB8fCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBlbGxpcHNlO1xuICB9LFxuICAncG9seWdvbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciBwb2ludHMgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJyk7XG5cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBwb2ludHMgPSBwYXJzZVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMgfHwgW11cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIHBvbHlnb24pO1xuICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBwb2x5Z29uLCB0aGlzLl9kZWZzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfSxcbiAgJ3BvbHlsaW5lJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHBhdGggPSBuZXcgUGF0aCgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgcGF0aCk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHBhdGgsIHRoaXMuX2RlZnMpO1xuICAgIHZhciBwb2ludHMgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJyk7XG5cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBwb2ludHMgPSBwYXJzZVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5bGluZSA9IG5ldyBQb2x5bGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50cyB8fCBbXVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb2x5bGluZTtcbiAgfSxcbiAgJ2ltYWdlJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIGltZyA9IG5ldyBaSW1hZ2UoKTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGltZyk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGltZywgdGhpcy5fZGVmcyk7XG4gICAgaW1nLnNldFN0eWxlKHtcbiAgICAgIGltYWdlOiB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpLFxuICAgICAgeDogeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgIHk6IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5JyksXG4gICAgICB3aWR0aDogeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgIH0pO1xuICAgIHJldHVybiBpbWc7XG4gIH0sXG4gICd0ZXh0JzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneCcpIHx8IDA7XG4gICAgdmFyIHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneScpIHx8IDA7XG4gICAgdmFyIGR4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R4JykgfHwgMDtcbiAgICB2YXIgZHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHknKSB8fCAwO1xuICAgIHRoaXMuX3RleHRYID0gcGFyc2VGbG9hdCh4KSArIHBhcnNlRmxvYXQoZHgpO1xuICAgIHRoaXMuX3RleHRZID0gcGFyc2VGbG9hdCh5KSArIHBhcnNlRmxvYXQoZHkpO1xuICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIGc7XG4gIH0sXG4gICd0c3Bhbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciB4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAvLyBuZXcgb2Zmc2V0IHhcbiAgICAgIHRoaXMuX3RleHRYID0gcGFyc2VGbG9hdCh4KTtcbiAgICB9XG5cbiAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAvLyBuZXcgb2Zmc2V0IHlcbiAgICAgIHRoaXMuX3RleHRZID0gcGFyc2VGbG9hdCh5KTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHgnKSB8fCAwO1xuICAgIHZhciBkeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeScpIHx8IDA7XG4gICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGcpO1xuICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBnLCB0aGlzLl9kZWZzKTtcbiAgICB0aGlzLl90ZXh0WCArPSBkeDtcbiAgICB0aGlzLl90ZXh0WSArPSBkeTtcbiAgICByZXR1cm4gZztcbiAgfSxcbiAgJ3BhdGgnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAvLyBUT0RPIHN2ZyBmaWxsIHJ1bGVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZVxuICAgIC8vIHBhdGguc3R5bGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3hvcic7XG4gICAgdmFyIGQgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZCcpIHx8ICcnOyAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG5cbiAgICB2YXIgcGF0aCA9IGNyZWF0ZUZyb21TdHJpbmcoZCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBwYXRoKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcGF0aCwgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG52YXIgZGVmaW5lUGFyc2VycyA9IHtcbiAgJ2xpbmVhcmdyYWRpZW50JzogZnVuY3Rpb24gKHhtbE5vZGUpIHtcbiAgICB2YXIgeDEgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLCAxMCk7XG4gICAgdmFyIHkxID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCwgMTApO1xuICAgIHZhciB4MiA9IHBhcnNlSW50KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MicpIHx8IDEwLCAxMCk7XG4gICAgdmFyIHkyID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMCwgMTApO1xuICAgIHZhciBncmFkaWVudCA9IG5ldyBMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBfcGFyc2VHcmFkaWVudENvbG9yU3RvcHMoeG1sTm9kZSwgZ3JhZGllbnQpO1xuXG4gICAgcmV0dXJuIGdyYWRpZW50O1xuICB9LFxuICAncmFkaWFsZ3JhZGllbnQnOiBmdW5jdGlvbiAoeG1sTm9kZSkge31cbn07XG5cbmZ1bmN0aW9uIF9wYXJzZUdyYWRpZW50Q29sb3JTdG9wcyh4bWxOb2RlLCBncmFkaWVudCkge1xuICB2YXIgc3RvcCA9IHhtbE5vZGUuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoc3RvcCkge1xuICAgIGlmIChzdG9wLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RvcC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xuXG4gICAgICBpZiAob2Zmc2V0LmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgLy8gcGVyY2VudGFnZVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUludChvZmZzZXQsIDEwKSAvIDEwMDtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0KSB7XG4gICAgICAgIC8vIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcENvbG9yID0gc3RvcC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAnIzAwMDAwMCc7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBzdG9wQ29sb3IpO1xuICAgIH1cblxuICAgIHN0b3AgPSBzdG9wLm5leHRTaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRTdHlsZShwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICBpZiAoIWNoaWxkLl9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICAgIGNoaWxkLl9faW5oZXJpdGVkU3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBkZWZhdWx0cyhjaGlsZC5fX2luaGVyaXRlZFN0eWxlLCBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gdHJpbShwb2ludHNTdHJpbmcpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGxpc3RbaV0pO1xuICAgIHZhciB5ID0gcGFyc2VGbG9hdChsaXN0W2kgKyAxXSk7XG4gICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbnZhciBhdHRyaWJ1dGVzTWFwID0ge1xuICAnZmlsbCc6ICdmaWxsJyxcbiAgJ3N0cm9rZSc6ICdzdHJva2UnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ2xpbmVXaWR0aCcsXG4gICdvcGFjaXR5JzogJ29wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdsaW5lRGFzaCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdsaW5lRGFzaE9mZnNldCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdsaW5lQ2FwJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdsaW5lSm9pbicsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdtaXRlckxpbWl0JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICAndGV4dC1hbGlnbic6ICd0ZXh0QWxpZ24nLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ3RleHRCYXNlbGluZSdcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBlbCwgZGVmcywgb25seUlubGluZVN0eWxlKSB7XG4gIHZhciB6clN0eWxlID0gZWwuX19pbmhlcml0ZWRTdHlsZSB8fCB7fTtcbiAgdmFyIGlzVGV4dEVsID0gZWwudHlwZSA9PT0gJ3RleHQnOyAvLyBUT0RPIFNoYWRvd1xuXG4gIGlmICh4bWxOb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgcGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoeG1sTm9kZSwgZWwpO1xuICAgIGV4dGVuZCh6clN0eWxlLCBwYXJzZVN0eWxlQXR0cmlidXRlKHhtbE5vZGUpKTtcblxuICAgIGlmICghb25seUlubGluZVN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBzdmdBdHRyTmFtZSBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzTWFwLmhhc093blByb3BlcnR5KHN2Z0F0dHJOYW1lKSkge1xuICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZShzdmdBdHRyTmFtZSk7XG5cbiAgICAgICAgICBpZiAoYXR0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHpyU3R5bGVbYXR0cmlidXRlc01hcFtzdmdBdHRyTmFtZV1dID0gYXR0clZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbEZpbGxQcm9wID0gaXNUZXh0RWwgPyAndGV4dEZpbGwnIDogJ2ZpbGwnO1xuICB2YXIgZWxTdHJva2VQcm9wID0gaXNUZXh0RWwgPyAndGV4dFN0cm9rZScgOiAnc3Ryb2tlJztcbiAgZWwuc3R5bGUgPSBlbC5zdHlsZSB8fCBuZXcgU3R5bGUoKTtcbiAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgenJTdHlsZS5maWxsICE9IG51bGwgJiYgZWxTdHlsZS5zZXQoZWxGaWxsUHJvcCwgZ2V0UGFpbnQoenJTdHlsZS5maWxsLCBkZWZzKSk7XG4gIHpyU3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgZWxTdHlsZS5zZXQoZWxTdHJva2VQcm9wLCBnZXRQYWludCh6clN0eWxlLnN0cm9rZSwgZGVmcykpO1xuICBlYWNoKFsnbGluZVdpZHRoJywgJ29wYWNpdHknLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsICdtaXRlckxpbWl0JywgJ2ZvbnRTaXplJ10sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHZhciBlbFByb3BOYW1lID0gcHJvcE5hbWUgPT09ICdsaW5lV2lkdGgnICYmIGlzVGV4dEVsID8gJ3RleHRTdHJva2VXaWR0aCcgOiBwcm9wTmFtZTtcbiAgICB6clN0eWxlW3Byb3BOYW1lXSAhPSBudWxsICYmIGVsU3R5bGUuc2V0KGVsUHJvcE5hbWUsIHBhcnNlRmxvYXQoenJTdHlsZVtwcm9wTmFtZV0pKTtcbiAgfSk7XG5cbiAgaWYgKCF6clN0eWxlLnRleHRCYXNlbGluZSB8fCB6clN0eWxlLnRleHRCYXNlbGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgenJTdHlsZS50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gIH1cblxuICBpZiAoenJTdHlsZS50ZXh0QmFzZWxpbmUgPT09ICdhbHBoYWJldGljJykge1xuICAgIHpyU3R5bGUudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cblxuICBpZiAoenJTdHlsZS50ZXh0QWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgfVxuXG4gIGlmICh6clN0eWxlLnRleHRBbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBlYWNoKFsnbGluZURhc2hPZmZzZXQnLCAnbGluZUNhcCcsICdsaW5lSm9pbicsICdmb250V2VpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnZm9udFN0eWxlJywgJ3RleHRBbGlnbicsICd0ZXh0QmFzZWxpbmUnXSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgenJTdHlsZVtwcm9wTmFtZV0gIT0gbnVsbCAmJiBlbFN0eWxlLnNldChwcm9wTmFtZSwgenJTdHlsZVtwcm9wTmFtZV0pO1xuICB9KTtcblxuICBpZiAoenJTdHlsZS5saW5lRGFzaCkge1xuICAgIGVsLnN0eWxlLmxpbmVEYXNoID0gdHJpbSh6clN0eWxlLmxpbmVEYXNoKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgfVxuXG4gIGlmIChlbFN0eWxlW2VsU3Ryb2tlUHJvcF0gJiYgZWxTdHlsZVtlbFN0cm9rZVByb3BdICE9PSAnbm9uZScpIHtcbiAgICAvLyBlbmFibGUgc3Ryb2tlXG4gICAgZWxbZWxTdHJva2VQcm9wXSA9IHRydWU7XG4gIH1cblxuICBlbC5fX2luaGVyaXRlZFN0eWxlID0genJTdHlsZTtcbn1cblxudmFyIHVybFJlZ2V4ID0gL3VybFxcKFxccyojKC4qPylcXCkvO1xuXG5mdW5jdGlvbiBnZXRQYWludChzdHIsIGRlZnMpIHtcbiAgLy8gaWYgKHN0ciA9PT0gJ25vbmUnKSB7XG4gIC8vICAgICByZXR1cm47XG4gIC8vIH1cbiAgdmFyIHVybE1hdGNoID0gZGVmcyAmJiBzdHIgJiYgc3RyLm1hdGNoKHVybFJlZ2V4KTtcblxuICBpZiAodXJsTWF0Y2gpIHtcbiAgICB2YXIgdXJsID0gdHJpbSh1cmxNYXRjaFsxXSk7XG4gICAgdmFyIGRlZiA9IGRlZnNbdXJsXTtcbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIHRyYW5zZm9ybVJlZ2V4ID0gLyh0cmFuc2xhdGV8c2NhbGV8cm90YXRlfHNrZXdYfHNrZXdZfG1hdHJpeClcXCgoW1xcLVxcczAtOVxcLmUsXSopXFwpL2c7XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHhtbE5vZGUsIG5vZGUpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnJlcGxhY2UoLywvZywgJyAnKTtcbiAgICB2YXIgbSA9IG51bGw7XG4gICAgdmFyIHRyYW5zZm9ybU9wcyA9IFtdO1xuICAgIHRyYW5zZm9ybS5yZXBsYWNlKHRyYW5zZm9ybVJlZ2V4LCBmdW5jdGlvbiAoc3RyLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgdHJhbnNmb3JtT3BzLnB1c2godHlwZSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IHRyYW5zZm9ybU9wcy5sZW5ndGggLSAxOyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1PcHNbaV07XG4gICAgICB2YXIgdHlwZSA9IHRyYW5zZm9ybU9wc1tpIC0gMV07XG4gICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgIHZhbHVlID0gdHJpbSh2YWx1ZSkuc3BsaXQoRElMSU1JVEVSX1JFRyk7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbcGFyc2VGbG9hdCh2YWx1ZVswXSksIHBhcnNlRmxvYXQodmFsdWVbMV0gfHwgMCldKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgdmFsdWUgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3BhcnNlRmxvYXQodmFsdWVbMF0pLCBwYXJzZUZsb2F0KHZhbHVlWzFdIHx8IHZhbHVlWzBdKV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgdmFsdWUgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICBtYXRyaXgucm90YXRlKG0sIG0sIHBhcnNlRmxvYXQodmFsdWVbMF0pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdza2V3JzpcbiAgICAgICAgICB2YWx1ZSA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignU2tldyB0cmFuc2Zvcm0gaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgIHZhciB2YWx1ZSA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgIG1bMF0gPSBwYXJzZUZsb2F0KHZhbHVlWzBdKTtcbiAgICAgICAgICBtWzFdID0gcGFyc2VGbG9hdCh2YWx1ZVsxXSk7XG4gICAgICAgICAgbVsyXSA9IHBhcnNlRmxvYXQodmFsdWVbMl0pO1xuICAgICAgICAgIG1bM10gPSBwYXJzZUZsb2F0KHZhbHVlWzNdKTtcbiAgICAgICAgICBtWzRdID0gcGFyc2VGbG9hdCh2YWx1ZVs0XSk7XG4gICAgICAgICAgbVs1XSA9IHBhcnNlRmxvYXQodmFsdWVbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH1cbn0gLy8gVmFsdWUgbWF5IGNvbnRhaW4gc3BhY2UuXG5cblxudmFyIHN0eWxlUmVnZXggPSAvKFteXFxzOjtdKylcXHMqOlxccyooW146O10rKS9nO1xuXG5mdW5jdGlvbiBwYXJzZVN0eWxlQXR0cmlidXRlKHhtbE5vZGUpIHtcbiAgdmFyIHN0eWxlID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBzdHlsZUxpc3QgPSB7fTtcbiAgc3R5bGVSZWdleC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3R5bGVSZWdSZXN1bHQ7XG5cbiAgd2hpbGUgKChzdHlsZVJlZ1Jlc3VsdCA9IHN0eWxlUmVnZXguZXhlYyhzdHlsZSkpICE9IG51bGwpIHtcbiAgICBzdHlsZUxpc3Rbc3R5bGVSZWdSZXN1bHRbMV1dID0gc3R5bGVSZWdSZXN1bHRbMl07XG4gIH1cblxuICBmb3IgKHZhciBzdmdBdHRyTmFtZSBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXNNYXAuaGFzT3duUHJvcGVydHkoc3ZnQXR0ck5hbWUpICYmIHN0eWxlTGlzdFtzdmdBdHRyTmFtZV0gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZXNNYXBbc3ZnQXR0ck5hbWVdXSA9IHN0eWxlTGlzdFtzdmdBdHRyTmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmlld0JveFJlY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7T2JqZWN0fSB7c2NhbGUsIHBvc2l0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gdmlld0JveFJlY3Qud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBoZWlnaHQgLyB2aWV3Qm94UmVjdC5oZWlnaHQ7XG4gIHZhciBzY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTsgLy8gcHJlc2VydmVBc3BlY3RSYXRpbyAneE1pZFlNaWQnXG5cbiAgdmFyIHZpZXdCb3hTY2FsZSA9IFtzY2FsZSwgc2NhbGVdO1xuICB2YXIgdmlld0JveFBvc2l0aW9uID0gWy0odmlld0JveFJlY3QueCArIHZpZXdCb3hSZWN0LndpZHRoIC8gMikgKiBzY2FsZSArIHdpZHRoIC8gMiwgLSh2aWV3Qm94UmVjdC55ICsgdmlld0JveFJlY3QuaGVpZ2h0IC8gMikgKiBzY2FsZSArIGhlaWdodCAvIDJdO1xuICByZXR1cm4ge1xuICAgIHNjYWxlOiB2aWV3Qm94U2NhbGUsXG4gICAgcG9zaXRpb246IHZpZXdCb3hQb3NpdGlvblxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xYTUxFbGVtZW50fSB4bWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQud2lkdGhdIERlZmF1bHQgd2lkdGggaWYgc3ZnIHdpZHRoIG5vdCBzcGVjaWZpZWQgb3IgaXMgYSBwZXJjZW50IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuaGVpZ2h0XSBEZWZhdWx0IGhlaWdodCBpZiBzdmcgaGVpZ2h0IG5vdCBzcGVjaWZpZWQgb3IgaXMgYSBwZXJjZW50IHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0Lmlnbm9yZVZpZXdCb3hdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuaWdub3JlUm9vdENsaXBdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdDpcbiAqIHtcbiAqICAgICByb290OiBHcm91cCwgVGhlIHJvb3Qgb2YgdGhlIHRoZSByZXN1bHQgdHJlZSBvZiB6cmVuZGVyIHNoYXBlcyxcbiAqICAgICB3aWR0aDogbnVtYmVyLCB0aGUgdmlld3BvcnQgd2lkdGggb2YgdGhlIFNWRyxcbiAqICAgICBoZWlnaHQ6IG51bWJlciwgdGhlIHZpZXdwb3J0IGhlaWdodCBvZiB0aGUgU1ZHLFxuICogICAgIHZpZXdCb3hSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH0sIHRoZSBkZWNsYXJlZCB2aWV3Qm94IHJlY3Qgb2YgdGhlIFNWRywgaWYgZXhpc3RzLFxuICogICAgIHZpZXdCb3hUcmFuc2Zvcm06IHRoZSB7c2NhbGUsIHBvc2l0aW9ufSBjYWxjdWxhdGVkIGJ5IHZpZXdCb3ggYW5kIHZpZXdwb3J0LCBpcyBleGlzdHMuXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVNWRyh4bWwsIG9wdCkge1xuICB2YXIgcGFyc2VyID0gbmV3IFNWR1BhcnNlcigpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHhtbCwgb3B0KTtcbn1cblxuZXhwb3J0cy5wYXJzZVhNTCA9IHBhcnNlWE1MO1xuZXhwb3J0cy5tYWtlVmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtO1xuZXhwb3J0cy5wYXJzZVNWRyA9IHBhcnNlU1ZHOyIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1QYXRoXCIpO1xuXG4vLyBjb21tYW5kIGNoYXJzXG4vLyB2YXIgY2MgPSBbXG4vLyAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuLy8gICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xuLy8gXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxudmFyIGNvbW1hbmRSZWcgPSAvKFttbHZoemNxdHNhXSkoW15tbHZoemNxdHNhXSopL2lnOyAvLyBDb25zaWRlciBjYXNlOlxuLy8gKDEpIGRlbGltaXRlciBjYW4gYmUgY29tbWEgb3Igc3BhY2UsIHdoZXJlIGNvbnRpbnVvdXMgY29tbWFzXG4vLyBvciBzcGFjZXMgc2hvdWxkIGJlIHNlZW4gYXMgb25lIGNvbW1hLlxuLy8gKDIpIHZhbHVlIGNhbiBiZSBsaWtlOlxuLy8gJzJlLTQnLCAnbC41LjknIChpZ25vcmUgMCksICdNLTEwLTEwJywgJ2wtMi40M2UtMSwzNC45OTgzJyxcbi8vICdsLS41RTEsNTQnLCAnMTIxLTIzLTQ0LTExJyAobm8gZGVsaW1pdGVyKVxuXG52YXIgbnVtYmVyUmVnID0gLy0/KFswLTldKlxcLik/WzAtOV0rKFtlRV0tP1swLTldKyk/L2c7IC8vIHZhciB2YWx1ZVNwbGl0UmVnID0gL1tcXHMsXSsvO1xuXG5mdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRoUHJveHkoKTtcbiAgfSAvLyB2YXIgZGF0YSA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKVxuICAvLyAgICAgLnJlcGxhY2UoLyAgL2csICcgJylcbiAgLy8gICAgIC5yZXBsYWNlKC8gL2csICcsJylcbiAgLy8gICAgIC5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuICAvLyB2YXIgbjtcbiAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gIC8vIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAvLyAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgLy8gfVxuICAvLyBkYXRhID0gZGF0YS5yZXBsYWNlKC8tL2csICcsLScpO1xuICAvLyBjcmVhdGUgYXJyYXlcbiAgLy8gdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gIC8vIGluaXQgY29udGV4dCBwb2ludFxuXG5cbiAgdmFyIGNweCA9IDA7XG4gIHZhciBjcHkgPSAwO1xuICB2YXIgc3VicGF0aFggPSBjcHg7XG4gIHZhciBzdWJwYXRoWSA9IGNweTtcbiAgdmFyIHByZXZDbWQ7XG4gIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDsgLy8gY29tbWFuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAvLyB2YXIgY21kUmVzdWx0O1xuICAvLyB3aGlsZSAoKGNtZFJlc3VsdCA9IGNvbW1hbmRSZWcuZXhlYyhkYXRhKSkgIT0gbnVsbCkge1xuICAvLyAgICAgdmFyIGNtZFN0ciA9IGNtZFJlc3VsdFsxXTtcbiAgLy8gICAgIHZhciBjbWRDb250ZW50ID0gY21kUmVzdWx0WzJdO1xuXG4gIHZhciBjbWRMaXN0ID0gZGF0YS5tYXRjaChjb21tYW5kUmVnKTtcblxuICBmb3IgKHZhciBsID0gMDsgbCA8IGNtZExpc3QubGVuZ3RoOyBsKyspIHtcbiAgICB2YXIgY21kVGV4dCA9IGNtZExpc3RbbF07XG4gICAgdmFyIGNtZFN0ciA9IGNtZFRleHQuY2hhckF0KDApO1xuICAgIHZhciBjbWQ7IC8vIFN0cmluZyNzcGxpdCBpcyBmYXN0ZXIgYSBsaXR0bGUgYml0IHRoYW4gU3RyaW5nI3JlcGxhY2Ugb3IgUmVnRXhwI2V4ZWMuXG4gICAgLy8gdmFyIHAgPSBjbWRDb250ZW50LnNwbGl0KHZhbHVlU3BsaXRSZWcpO1xuICAgIC8vIHZhciBwTGVuID0gMDtcbiAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgLy8gJycgYW5kIG90aGVyIGludmFsaWQgc3RyID0+IE5hTlxuICAgIC8vICAgICB2YXIgdmFsID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAvLyAgICAgIWlzTmFOKHZhbCkgJiYgKHBbcExlbisrXSA9IHZhbCk7XG4gICAgLy8gfVxuXG4gICAgdmFyIHAgPSBjbWRUZXh0Lm1hdGNoKG51bWJlclJlZykgfHwgW107XG4gICAgdmFyIHBMZW4gPSBwLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgb2ZmID0gMDtcblxuICAgIHdoaWxlIChvZmYgPCBwTGVuKSB7XG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGNtZFN0cikge1xuICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgc3VicGF0aFggPSBjcHg7XG4gICAgICAgICAgc3VicGF0aFkgPSBjcHk7XG4gICAgICAgICAgY21kU3RyID0gJ2wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBzdWJwYXRoWCA9IGNweDtcbiAgICAgICAgICBzdWJwYXRoWSA9IGNweTtcbiAgICAgICAgICBjbWRTdHIgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY21kU3RyID09PSAneicgfHwgY21kU3RyID09PSAnWicpIHtcbiAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgcGF0aC5hZGREYXRhKGNtZCk7IC8vIHogbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhdGguXG5cbiAgICAgIGNweCA9IHN1YnBhdGhYO1xuICAgICAgY3B5ID0gc3VicGF0aFk7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHBhdGgudG9TdGF0aWMoKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7IC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuXG4gICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cbiAgfTtcblxuICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG4gICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21TdHJpbmcoc3RyLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICovXG4vLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuLy8gVE9ETyBzdHJva2UgZGFzaFxuLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIG1lcmdlUGF0aChwYXRoRWxzLCBvcHRzKSB7XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuXG4gICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gIH1cblxuICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpOyAvLyBOZWVkIHBhdGggcHJveHkuXG5cbiAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcblxuICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXRoQnVuZGxlO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21TdHJpbmcgPSBjcmVhdGVGcm9tU3RyaW5nO1xuZXhwb3J0cy5leHRlbmRGcm9tU3RyaW5nID0gZXh0ZW5kRnJvbVN0cmluZztcbmV4cG9ydHMubWVyZ2VQYXRoID0gbWVyZ2VQYXRoOyIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcblxuZnVuY3Rpb24gX2RlZmF1bHQocGF0aCwgbSkge1xuICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgdmFyIGNtZDtcbiAgdmFyIG5Qb2ludDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgaztcbiAgdmFyIHA7XG4gIHZhciBNID0gQ01ELk07XG4gIHZhciBDID0gQ01ELkM7XG4gIHZhciBMID0gQ01ELkw7XG4gIHZhciBSID0gQ01ELlI7XG4gIHZhciBBID0gQ01ELkE7XG4gIHZhciBRID0gQ01ELlE7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICBjbWQgPSBkYXRhW2krK107XG4gICAgaiA9IGk7XG4gICAgblBvaW50ID0gMDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIE06XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEw6XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEM6XG4gICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFE6XG4gICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEE6XG4gICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpOyAvLyBjeFxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSArPSB4OyAvLyBjeVxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgIGRhdGFbaSsrXSArPSB5OyAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcblxuICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeTsgLy8gU3RhcnQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIGVuZCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gRklYTUUgcHNpXG5cbiAgICAgICAgaSArPSAyO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUjpcbiAgICAgICAgLy8geDAsIHkwXG4gICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07IC8vIHgxLCB5MVxuXG4gICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pOyAvLyBXcml0ZSBiYWNrXG5cbiAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyIsInZhciBsb2dFcnJvciA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbi8qKlxuICogVk1MIFBhaW50ZXIuXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cblxuXG5mdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcbiAgdm1sQ29yZS5pbml0Vk1MKCk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHZhciB2bWxWaWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgdm1sUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcbiAgdm1sUm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuICByb290LmFwcGVuZENoaWxkKHZtbFZpZXdwb3J0KTtcbiAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG4gIHRoaXMucmVzaXplKCk7IC8vIE1vZGlmeSBzdG9yYWdlXG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwub25SZW1vdmUgJiYgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgLy8gRGlzcGxheWFibGUgYWxyZWFkeSBoYXMgYSB2bWwgbm9kZVxuICAgIGVsLm9uQWRkICYmIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgfTtcblxuICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbn1cblxuVk1MUGFpbnRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBWTUxQYWludGVyLFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICd2bWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92bWxWaWV3cG9ydDtcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIt+aWsFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUsIHRydWUpO1xuXG4gICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QpO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciB2bWxSb290ID0gdGhpcy5fdm1sUm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcblxuICAgICAgaWYgKGVsLmludmlzaWJsZSB8fCBlbC5pZ25vcmUpIHtcbiAgICAgICAgaWYgKCFlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgIH0gLy8gU2V0IGFzIGFscmVhZHkgaW52aXNpYmxlXG5cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25BZGQodm1sUm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaCgpO1xuICAgICAgICAgIChlbC5icnVzaFZNTCB8fCBlbC5icnVzaCkuY2FsbChlbCwgdm1sUm9vdCk7XG4gICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdFBhaW50KSB7XG4gICAgICAvLyBEZXRhY2hlZCBmcm9tIGRvY3VtZW50IGF0IGZpcnN0IHRpbWVcbiAgICAgIC8vIHRvIGF2b2lkIHBhZ2UgcmVmcmVzaGluZyB0b28gbWFueSB0aW1lc1xuICAgICAgLy8gRklYTUUg5aaC5p6c5q+P5qyh6YO95YWIIHJlbW92ZUNoaWxkIOWPr+iDveS8muWvvOiHtOS4gOS6m+Whq+WFheWSjOaPj+i+ueeahOaViOaenOaUueWPmFxuICAgICAgdGhpcy5fdm1sVmlld3BvcnQuYXBwZW5kQ2hpbGQodm1sUm9vdCk7XG5cbiAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgd2lkdGggPSB3aWR0aCA9PSBudWxsID8gdGhpcy5fZ2V0V2lkdGgoKSA6IHdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuX2dldEhlaWdodCgpIDogaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuX3dpZHRoICE9PSB3aWR0aCB8fCB0aGlzLl9oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciB2bWxWaWV3cG9ydFN0eWxlID0gdGhpcy5fdm1sVmlld3BvcnQuc3R5bGU7XG4gICAgICB2bWxWaWV3cG9ydFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgdm1sVmlld3BvcnRTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLl92bWxSb290ID0gdGhpcy5fdm1sVmlld3BvcnQgPSB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfSxcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdm1sVmlld3BvcnQpIHtcbiAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZCh0aGlzLl92bWxWaWV3cG9ydCk7XG4gICAgfVxuICB9LFxuICBfZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG4gICAgcmV0dXJuIChyb290LmNsaWVudFdpZHRoIHx8IHBhcnNlSW50MTAoc3RsLndpZHRoKSkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nTGVmdCkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHwgMDtcbiAgfSxcbiAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcbiAgICByZXR1cm4gKHJvb3QuY2xpZW50SGVpZ2h0IHx8IHBhcnNlSW50MTAoc3RsLmhlaWdodCkpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nQm90dG9tKSB8IDA7XG4gIH1cbn07IC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuXG5mdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxvZ0Vycm9yKCdJbiBJRTguMCBWTUwgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfTtcbn0gLy8gVW5zdXBwb3J0ZWQgbWV0aG9kc1xuXG5cbmVhY2goWydnZXRMYXllcicsICdpbnNlcnRMYXllcicsICdlYWNoTGF5ZXInLCAnZWFjaEJ1aWx0aW5MYXllcicsICdlYWNoT3RoZXJMYXllcicsICdnZXRMYXllcnMnLCAnbW9kTGF5ZXInLCAnZGVsTGF5ZXInLCAnY2xlYXJMYXllcicsICd0b0RhdGFVUkwnLCAncGF0aFRvSW1hZ2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgVk1MUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBWTUxQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgdXJuID0gJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG52YXIgdm1sSW5pdGVkID0gZmFsc2U7XG52YXIgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh0YWdOYW1lKSB7XG4gIHJldHVybiBkb0NyZWF0ZU5vZGUodGFnTmFtZSk7XG59IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cblxudmFyIGRvQ3JlYXRlTm9kZTtcblxuaWYgKGRvYyAmJiAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB0cnkge1xuICAgICFkb2MubmFtZXNwYWNlcy56cnZtbCAmJiBkb2MubmFtZXNwYWNlcy5hZGQoJ3pydm1sJywgdXJuKTtcblxuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzx6cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XCJ6cnZtbFwiPicpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkb0NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfVxufSAvLyBGcm9tIHJhcGhhZWxcblxuXG5mdW5jdGlvbiBpbml0Vk1MKCkge1xuICBpZiAodm1sSW5pdGVkIHx8ICFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2bWxJbml0ZWQgPSB0cnVlO1xuICB2YXIgc3R5bGVTaGVldHMgPSBkb2Muc3R5bGVTaGVldHM7XG5cbiAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5kb2MgPSBkb2M7XG5leHBvcnRzLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuZXhwb3J0cy5pbml0Vk1MID0gaW5pdFZNTDsiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIGFwcGx5VHJhbnNmb3JtID0gX3ZlY3Rvci5hcHBseVRyYW5zZm9ybTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCIuLi90b29sL2NvbG9yXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci90ZXh0XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFwiKTtcblxudmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvRGlzcGxheWFibGVcIik7XG5cbnZhciBaSW1hZ2UgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9JbWFnZVwiKTtcblxudmFyIFRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9UZXh0XCIpO1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0dyYWRpZW50XCIpO1xuXG52YXIgdm1sQ29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtVk1MXG4vLyBUT0RPIFVzZSBwcm94eSBsaWtlIHN2ZyBpbnN0ZWFkIG9mIG92ZXJ3cml0ZSBicnVzaCBtZXRob2RzXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbmlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB2YXIgY29tbWEgPSAnLCc7XG4gIHZhciBpbWFnZVRyYW5zZm9ybVByZWZpeCA9ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnO1xuICB2YXIgWiA9IDIxNjAwO1xuICB2YXIgWjIgPSBaIC8gMjtcbiAgdmFyIFpMRVZFTF9CQVNFID0gMTAwMDAwO1xuICB2YXIgWl9CQVNFID0gMTAwMDtcblxuICB2YXIgaW5pdFJvb3RFbFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgICBlbC5jb29yZHNpemUgPSBaICsgJywnICsgWjtcbiAgICBlbC5jb29yZG9yaWdpbiA9ICcwLDAnO1xuICB9O1xuXG4gIHZhciBlbmNvZGVIdG1sQXR0cmlidXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICB9O1xuXG4gIHZhciByZ2IyU3RyID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gJ3JnYignICsgW3IsIGcsIGJdLmpvaW4oJywnKSArICcpJztcbiAgfTtcblxuICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRaSW5kZXggPSBmdW5jdGlvbiAoemxldmVsLCB6LCB6Mikge1xuICAgIC8vIHog55qE5Y+W5YC86IyD5Zu05Li6IFswLCAxMDAwXVxuICAgIHJldHVybiAocGFyc2VGbG9hdCh6bGV2ZWwpIHx8IDApICogWkxFVkVMX0JBU0UgKyAocGFyc2VGbG9hdCh6KSB8fCAwKSAqIFpfQkFTRSArIHoyO1xuICB9O1xuXG4gIHZhciBwYXJzZVBlcmNlbnQgPSB0ZXh0SGVscGVyLnBhcnNlUGVyY2VudDtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQQVRIXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgc2V0Q29sb3JBbmRPcGFjaXR5ID0gZnVuY3Rpb24gKGVsLCBjb2xvciwgb3BhY2l0eSkge1xuICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgb3BhY2l0eSA9ICtvcGFjaXR5O1xuXG4gICAgaWYgKGlzTmFOKG9wYWNpdHkpKSB7XG4gICAgICBvcGFjaXR5ID0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgIGVsLmNvbG9yID0gcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKTtcbiAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5ICogY29sb3JBcnJbM107XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRDb2xvckFuZEFscGhhID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICByZXR1cm4gW3JnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSksIGNvbG9yQXJyWzNdXTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRmlsbE5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCB6ckVsKSB7XG4gICAgLy8gVE9ETyBwYXR0ZXJuXG4gICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuXG4gICAgaWYgKGZpbGwgIT0gbnVsbCkge1xuICAgICAgLy8gTW9kaWZpZWQgZnJvbSBleGNhbnZhc1xuICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICB2YXIgZ3JhZGllbnRUeXBlO1xuICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICB2YXIgZm9jdXMgPSBbMCwgMF07IC8vIGFkZGl0aW9uYWwgb2Zmc2V0XG5cbiAgICAgICAgdmFyIHNoaWZ0ID0gMDsgLy8gc2NhbGUgZmFjdG9yIGZvciBvZmZzZXRcblxuICAgICAgICB2YXIgZXhwYW5zaW9uID0gMTtcbiAgICAgICAgdmFyIHJlY3QgPSB6ckVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcblxuICAgICAgICBpZiAoZmlsbC50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudCc7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgIHZhciBwMSA9IFtmaWxsLngyICogcmVjdFdpZHRoLCBmaWxsLnkyICogcmVjdEhlaWdodF07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGR4ID0gcDFbMF0gLSBwMFswXTtcbiAgICAgICAgICB2YXIgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTsgLy8gVGhlIGFuZ2xlIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG5cbiAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgICAgICAgfSAvLyBWZXJ5IHNtYWxsIGFuZ2xlcyBwcm9kdWNlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cblxuXG4gICAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnRyYWRpYWwnO1xuICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB6ckVsLnNjYWxlO1xuICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3RXaWR0aDtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdEhlaWdodDtcbiAgICAgICAgICBmb2N1cyA9IFsvLyBQZXJjZW50IGluIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICAocDBbMF0gLSByZWN0LngpIC8gd2lkdGgsIChwMFsxXSAtIHJlY3QueSkgLyBoZWlnaHRdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpZHRoIC89IHNjYWxlWzBdICogWjtcbiAgICAgICAgICBoZWlnaHQgLz0gc2NhbGVbMV0gKiBaO1xuICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBtYXRoTWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIHNoaWZ0ID0gMiAqIDAgLyBkaW1lbnNpb247XG4gICAgICAgICAgZXhwYW5zaW9uID0gMiAqIGZpbGwuciAvIGRpbWVuc2lvbiAtIHNoaWZ0O1xuICAgICAgICB9IC8vIFdlIG5lZWQgdG8gc29ydCB0aGUgY29sb3Igc3RvcHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IG9mZnNldCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIElFIHdvbid0IGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cblxuICAgICAgICB2YXIgc3RvcHMgPSBmaWxsLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgICAgc3RvcHMuc29ydChmdW5jdGlvbiAoY3MxLCBjczIpIHtcbiAgICAgICAgICByZXR1cm4gY3MxLm9mZnNldCAtIGNzMi5vZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RvcHMubGVuZ3RoOyAvLyBDb2xvciBhbmQgYWxwaGEgbGlzdCBvZiBmaXJzdCBhbmQgbGFzdCBzdG9wXG5cbiAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGFMaXN0ID0gW107XG4gICAgICAgIHZhciBjb2xvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICB2YXIgY29sb3JBbmRBbHBoYSA9IGdldENvbG9yQW5kQWxwaGEoc3RvcC5jb2xvcik7XG4gICAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIGNvbG9yQW5kQWxwaGFbMF0pO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29sb3JBbmRBbHBoYUxpc3QucHVzaChjb2xvckFuZEFscGhhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB2YXIgY29sb3IxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMF07XG4gICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzBdO1xuICAgICAgICAgIHZhciBvcGFjaXR5MSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICB2YXIgb3BhY2l0eTIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgZWwudHlwZSA9IGdyYWRpZW50VHlwZTtcbiAgICAgICAgICBlbC5tZXRob2QgPSAnbm9uZSc7XG4gICAgICAgICAgZWwuZm9jdXMgPSAnMTAwJSc7XG4gICAgICAgICAgZWwuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBlbC5jb2xvciA9IGNvbG9yMTtcbiAgICAgICAgICBlbC5jb2xvcjIgPSBjb2xvcjI7XG4gICAgICAgICAgZWwuY29sb3JzID0gY29sb3JzLmpvaW4oJywnKTsgLy8gV2hlbiBjb2xvcnMgYXR0cmlidXRlIGlzIHVzZWQsIHRoZSBtZWFuaW5ncyBvZiBvcGFjaXR5IGFuZCBvOm9wYWNpdHkyXG4gICAgICAgICAgLy8gYXJlIHJldmVyc2VkLlxuXG4gICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkyOyAvLyBGSVhNRSBnX29fOm9wYWNpdHkgP1xuXG4gICAgICAgICAgZWwub3BhY2l0eTIgPSBvcGFjaXR5MTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFkaWVudFR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgICAgZWwuZm9jdXNwb3NpdGlvbiA9IGZvY3VzLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRklYTUUgQ2hhbmdlIGZyb20gR3JhZGllbnQgZmlsbCB0byBjb2xvciBmaWxsXG4gICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgZmlsbCwgc3R5bGUub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVTdHJva2VOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIC8vIGlmIChzdHlsZS5saW5lSm9pbiAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLmpvaW5zdHlsZSA9IHN0eWxlLmxpbmVKb2luO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoc3R5bGUubWl0ZXJMaW1pdCAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLm1pdGVybGltaXQgPSBzdHlsZS5taXRlckxpbWl0ICogWjtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHN0eWxlLmxpbmVDYXAgIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5lbmRjYXAgPSBzdHlsZS5saW5lQ2FwO1xuICAgIC8vIH1cbiAgICBpZiAoc3R5bGUubGluZURhc2gpIHtcbiAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAodm1sRWwsIHR5cGUsIHN0eWxlLCB6ckVsKSB7XG4gICAgdmFyIGlzRmlsbCA9IHR5cGUgPT09ICdmaWxsJztcbiAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTsgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcblxuICAgIGlmIChzdHlsZVt0eXBlXSAhPSBudWxsICYmIHN0eWxlW3R5cGVdICE9PSAnbm9uZScgJiYgKGlzRmlsbCB8fCAhaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpIHtcbiAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICd0cnVlJzsgLy8gRklYTUUgUmVtb3ZlIGJlZm9yZSB1cGRhdGluZywgb3Igc2V0IGBjb2xvcnNgIHdpbGwgdGhyb3cgZXJyb3JcblxuICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlzRmlsbCA/IHVwZGF0ZUZpbGxOb2RlKGVsLCBzdHlsZSwgenJFbCkgOiB1cGRhdGVTdHJva2VOb2RlKGVsLCBzdHlsZSk7XG4gICAgICBhcHBlbmQodm1sRWwsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuXG4gIHZhciBwYXRoRGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKHBhdGgsIG0pIHtcbiAgICB2YXIgTSA9IENNRC5NO1xuICAgIHZhciBDID0gQ01ELkM7XG4gICAgdmFyIEwgPSBDTUQuTDtcbiAgICB2YXIgQSA9IENNRC5BO1xuICAgIHZhciBRID0gQ01ELlE7XG4gICAgdmFyIHN0ciA9IFtdO1xuICAgIHZhciBuUG9pbnQ7XG4gICAgdmFyIGNtZFN0cjtcbiAgICB2YXIgY21kO1xuICAgIHZhciBpO1xuICAgIHZhciB4aTtcbiAgICB2YXIgeWk7XG4gICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgdmFyIGRhdGFMZW5ndGggPSBwYXRoLmxlbigpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7KSB7XG4gICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICBjbWRTdHIgPSAnJztcbiAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgTTpcbiAgICAgICAgICBjbWRTdHIgPSAnIG0gJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTDpcbiAgICAgICAgICBjbWRTdHIgPSAnIGwgJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUTpcbiAgICAgICAgY2FzZSBDOlxuICAgICAgICAgIGNtZFN0ciA9ICcgYyAnO1xuICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgdmFyIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHkyID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MztcbiAgICAgICAgICB2YXIgeTM7XG5cbiAgICAgICAgICBpZiAoY21kID09PSBRKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB4MyA9IHgyO1xuICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAoeGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHlpICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geTE7XG4gICAgICAgICAgcG9pbnRzWzFdWzBdID0geDI7XG4gICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgcG9pbnRzWzJdWzBdID0geDM7XG4gICAgICAgICAgcG9pbnRzWzJdWzFdID0geTM7XG4gICAgICAgICAgeGkgPSB4MztcbiAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQTpcbiAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgIHZhciBzeCA9IDE7XG4gICAgICAgICAgdmFyIHN5ID0gMTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgU1JUIGZyb20gbWF0cml4XG4gICAgICAgICAgICB4ID0gbVs0XTtcbiAgICAgICAgICAgIHkgPSBtWzVdO1xuICAgICAgICAgICAgc3ggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgc3kgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdICsgYW5nbGU7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlOyAvLyBGSVhNRVxuICAgICAgICAgIC8vIHZhciBwc2kgPSBkYXRhW2krK107XG5cbiAgICAgICAgICBpKys7XG4gICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDAgPSBjeCArIGNvcyhzdGFydEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgIHZhciB5MCA9IGN5ICsgc2luKHN0YXJ0QW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHgxID0gY3ggKyBjb3MoZW5kQW5nbGUpICogcng7XG4gICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSB4MSkgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJRSB3b24ndCByZW5kZXIgYXJjaGVzIGRyYXduIGNvdW50ZXIgY2xvY2t3aXNlIGlmIHgwID09IHgxLlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPiAxZS0yKSB7XG4gICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gYmluYXJ5XG4gICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB4MCArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBjYXNlIGRyYXcgZnVsbCBjaXJjbGVcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UgJiYgeDAgPCBjeCB8fCAhY2xvY2t3aXNlICYmIHgwID4gY3gpIHtcbiAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHkxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiB5MCA8IGN5IHx8ICFjbG9ja3dpc2UgJiYgeTAgPiBjeSkge1xuICAgICAgICAgICAgICAgIHgxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ci5wdXNoKHR5cGUsIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgLSByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3ggKyByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh4MCAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHkwICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh5MSAqIHN5ICsgeSkgKiBaIC0gWjIpKTtcbiAgICAgICAgICB4aSA9IHgxO1xuICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB2YXIgcDAgPSBwb2ludHNbMF07XG4gICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdOyAvLyB4MCwgeTBcblxuICAgICAgICAgIHAwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdOyAvLyB4MSwgeTFcblxuICAgICAgICAgIHAxWzBdID0gcDBbMF0gKyBkYXRhW2krK107XG4gICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVswXSA9IHJvdW5kKHAxWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMFsxXSA9IHJvdW5kKHAwWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBzdHIucHVzaCggLy8geDAsIHkwXG4gICAgICAgICAgJyBtICcsIHAwWzBdLCBjb21tYSwgcDBbMV0sIC8vIHgxLCB5MFxuICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAwWzFdLCAvLyB4MSwgeTFcbiAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMVsxXSwgLy8geDAsIHkxXG4gICAgICAgICAgJyBsICcsIHAwWzBdLCBjb21tYSwgcDFbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgLy8gRklYTUUgVXBkYXRlIHhpLCB5aVxuICAgICAgICAgIHN0ci5wdXNoKCcgeCAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5Qb2ludCA+IDApIHtcbiAgICAgICAgc3RyLnB1c2goY21kU3RyKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgbSAmJiBhcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8g5LiNIHJvdW5kIOS8mumdnuW4uOaFolxuXG4gICAgICAgICAgc3RyLnB1c2gocm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSwgayA8IG5Qb2ludCAtIDEgPyBjb21tYSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBQYXRoLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdzaGFwZScpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ2ZpbGwnLCBzdHlsZSwgdGhpcyk7XG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIHZhciBuZWVkVHJhbnNmb3JtID0gbSAhPSBudWxsO1xuICAgIHZhciBzdHJva2VFbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHJva2UnKVswXTtcblxuICAgIGlmIChzdHJva2VFbCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDsgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgdGhpcy5tXyBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAgIC8vIGZvciB3aWR0aC5cblxuICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgdmFyIGRldCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgICAgIGxpbmVXaWR0aCAqPSBzcXJ0KGFicyhkZXQpKTtcbiAgICAgIH1cblxuICAgICAgc3Ryb2tlRWwud2VpZ2h0ID0gbGluZVdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCAodGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpKTtcblxuICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aC5zdWJQaXhlbE9wdGltaXplID0gZmFsc2U7XG4gICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBJTUFHRVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgaXNJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICByZXR1cm4gdHlwZW9mIGltZyA9PT0gJ29iamVjdCcgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7IC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgfTsgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcblxuXG4gIFpJbWFnZS5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7IC8vIEltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHRcblxuICAgIHZhciBvdztcbiAgICB2YXIgb2g7XG5cbiAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG5cbiAgICAgIGlmIChzcmMgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbWFnZVJ1bnRpbWVTdHlsZSA9IGltYWdlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVXaWR0aCA9IGltYWdlUnVudGltZVN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9ICdhdXRvJzsgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG5cbiAgICAgICAgb3cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgb2ggPSBpbWFnZS5oZWlnaHQ7IC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcblxuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9IG9sZFJ1bnRpbWVXaWR0aDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gb2xkUnVudGltZUhlaWdodDsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICB0aGlzLl9pbWFnZVNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgfVxuXG4gICAgICBpbWFnZSA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgc3cgPSBzdHlsZS5zV2lkdGg7XG4gICAgdmFyIHNoID0gc3R5bGUuc0hlaWdodDtcbiAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgdmFyIGhhc0Nyb3AgPSBzdyAmJiBzaDtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdmFyIHZtbEVsU3R5bGUgPSB2bWxFbC5zdHlsZTtcbiAgICB2YXIgaGFzUm90YXRpb24gPSBmYWxzZTtcbiAgICB2YXIgbTtcbiAgICB2YXIgc2NhbGVYID0gMTtcbiAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgc2NhbGVYID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgIHNjYWxlWSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuICAgICAgdmFyIHRyYW5zZm9ybUZpbHRlciA9IFtdO1xuICAgICAgdHJhbnNmb3JtRmlsdGVyLnB1c2goJ00xMT0nLCBtWzBdIC8gc2NhbGVYLCBjb21tYSwgJ00xMj0nLCBtWzJdIC8gc2NhbGVZLCBjb21tYSwgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSwgJ00yMj0nLCBtWzNdIC8gc2NhbGVZLCBjb21tYSwgJ0R4PScsIHJvdW5kKHggKiBzY2FsZVggKyBtWzRdKSwgY29tbWEsICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuICAgICAgdm1sRWxTdHlsZS5wYWRkaW5nID0gJzAgJyArIHJvdW5kKG1heFgpICsgJ3B4ICcgKyByb3VuZChtYXhZKSArICdweCAwJzsgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KCcgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobSkge1xuICAgICAgICB4ID0geCAqIHNjYWxlWCArIG1bNF07XG4gICAgICAgIHkgPSB5ICogc2NhbGVZICsgbVs1XTtcbiAgICAgIH1cblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgIHZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUVsID0gdGhpcy5faW1hZ2VFbDtcbiAgICB2YXIgY3JvcEVsID0gdGhpcy5fY3JvcEVsO1xuXG4gICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcblxuICAgIGlmIChoYXNDcm9wKSB7XG4gICAgICAvLyBOZWVkcyBrbm93IGltYWdlIG9yaWdpbmFsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGlmICghKG93ICYmIG9oKSkge1xuICAgICAgICB2YXIgdG1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgb2ggPSB0bXBJbWFnZS5oZWlnaHQ7IC8vIEFkanVzdCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGZpdCB0aGUgcmF0aW8gZGVzdGluYXRpb25TaXplIC8gc291cmNlU2l6ZVxuXG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnOyAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuXG4gICAgICAgICAgc2VsZi5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgc2VsZi5faW1hZ2VTcmMgPSBpbWFnZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3JvcEVsKSB7XG4gICAgICAgIGNyb3BFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjcm9wRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3JvcEVsU3R5bGUgPSBjcm9wRWwuc3R5bGU7XG4gICAgICBjcm9wRWxTdHlsZS53aWR0aCA9IHJvdW5kKChkdyArIHN4ICogZHcgLyBzdykgKiBzY2FsZVgpO1xuICAgICAgY3JvcEVsU3R5bGUuaGVpZ2h0ID0gcm91bmQoKGRoICsgc3kgKiBkaCAvIHNoKSAqIHNjYWxlWSk7XG4gICAgICBjcm9wRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KER4PScgKyAtc3ggKiBkdyAvIHN3ICogc2NhbGVYICsgJyxEeT0nICsgLXN5ICogZGggLyBzaCAqIHNjYWxlWSArICcpJztcblxuICAgICAgaWYgKCFjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChjcm9wRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9PSBjcm9wRWwpIHtcbiAgICAgICAgY3JvcEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBkdykgKyAncHgnO1xuICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIGRoKSArICdweCc7XG4gICAgICB2bWxFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcblxuICAgICAgaWYgKGNyb3BFbCAmJiBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWx0ZXJTdHIgPSAnJztcbiAgICB2YXIgYWxwaGEgPSBzdHlsZS5vcGFjaXR5O1xuXG4gICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgZmlsdGVyU3RyICs9ICcuQWxwaGEob3BhY2l0eT0nICsgcm91bmQoYWxwaGEgKiAxMDApICsgJykgJztcbiAgICB9XG5cbiAgICBmaWx0ZXJTdHIgKz0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLkFscGhhSW1hZ2VMb2FkZXIoc3JjPScgKyBpbWFnZSArICcsIFNpemluZ01ldGhvZD1zY2FsZSknO1xuICAgIGltYWdlRUxTdHlsZS5maWx0ZXIgPSBmaWx0ZXJTdHI7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9O1xuXG4gIFpJbWFnZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5fdm1sRWwgPSBudWxsO1xuICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgdGhpcy5faW1hZ2VFbCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBaSW1hZ2UucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogVEVYVFxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgREVGQVVMVF9TVFlMRV9OT1JNQUwgPSAnbm9ybWFsJztcbiAgdmFyIGZvbnRTdHlsZUNhY2hlID0ge307XG4gIHZhciBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gIHZhciBmb250RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB2YXIgZ2V0Rm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHJpbmcpIHtcbiAgICB2YXIgZm9udFN0eWxlID0gZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ107XG5cbiAgICBpZiAoIWZvbnRTdHlsZSkge1xuICAgICAgLy8gQ2xlYXIgY2FjaGVcbiAgICAgIGlmIChmb250U3R5bGVDYWNoZUNvdW50ID4gTUFYX0ZPTlRfQ0FDSEVfU0laRSkge1xuICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gZm9udEVsLnN0eWxlO1xuICAgICAgdmFyIGZvbnRGYW1pbHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdCgnLCcpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgZm9udFN0eWxlID0ge1xuICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICB2YXJpYW50OiBzdHlsZS5mb250VmFyaWFudCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgd2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgIGZhbWlseTogZm9udEZhbWlseSB8fCAnTWljcm9zb2Z0IFlhSGVpJ1xuICAgICAgfTtcbiAgICAgIGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddID0gZm9udFN0eWxlO1xuICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBmb250U3R5bGU7XG4gIH07XG5cbiAgdmFyIHRleHRNZWFzdXJlRWw7IC8vIE92ZXJ3cml0ZSBtZWFzdXJlIHRleHQgbWV0aG9kXG5cbiAgdGV4dENvbnRhaW4uJG92ZXJyaWRlKCdtZWFzdXJlVGV4dCcsIGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcblxuICAgIGlmICghdGV4dE1lYXN1cmVFbCkge1xuICAgICAgdGV4dE1lYXN1cmVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowOycgKyAncGFkZGluZzowO21hcmdpbjowO2JvcmRlcjpub25lO3doaXRlLXNwYWNlOnByZTsnO1xuICAgICAgdm1sQ29yZS5kb2MuYm9keS5hcHBlbmRDaGlsZCh0ZXh0TWVhc3VyZUVsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgfSBjYXRjaCAoZXgpIHsvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICB9XG5cbiAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnOyAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG5cbiAgICB0ZXh0TWVhc3VyZUVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgfTtcbiAgfSk7XG4gIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gIHZhciBkcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCwgcmVjdCwgdGV4dFJlY3QsIGZyb21UZXh0RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENvbnZlcnQgcmljaCB0ZXh0IHRvIHBsYWluIHRleHQuIFJpY2ggdGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluXG4gICAgLy8gSUU4LSwgYnV0IHRhZ3MgaW4gcmljaCB0ZXh0IHRlbXBsYXRlIHdpbGwgYmUgcmVtb3ZlZC5cblxuXG4gICAgaWYgKHN0eWxlLnJpY2gpIHtcbiAgICAgIHZhciBjb250ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgICAgIHRleHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGNvbnRlbnRCbG9jay5saW5lc1tpXS50b2tlbnM7XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGV4dExpbmUucHVzaCh0b2tlbnNbal0udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LnB1c2godGV4dExpbmUuam9pbignJykpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdGV4dC5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB2YXIgZm9udFN0eWxlID0gZ2V0Rm9udFN0eWxlKHN0eWxlLmZvbnQpOyAvLyBGSVhNRSBlbmNvZGVIdG1sQXR0cmlidXRlID9cblxuICAgIHZhciBmb250ID0gZm9udFN0eWxlLnN0eWxlICsgJyAnICsgZm9udFN0eWxlLnZhcmlhbnQgKyAnICcgKyBmb250U3R5bGUud2VpZ2h0ICsgJyAnICsgZm9udFN0eWxlLnNpemUgKyAncHggXCInICsgZm9udFN0eWxlLmZhbWlseSArICdcIic7XG4gICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIHZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS50ZXh0TGluZUhlaWdodCk7IC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuXG4gICAgaWYgKG0gJiYgIWZyb21UZXh0RWwpIHtcbiAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICB9XG5cbiAgICBpZiAoIWZyb21UZXh0RWwpIHtcbiAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247IC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcblxuICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5jYWxjdWxhdGVUZXh0UG9zaXRpb24gPyB0aGlzLmNhbGN1bGF0ZVRleHRQb3NpdGlvbih7fSwgc3R5bGUsIHJlY3QpIDogdGV4dENvbnRhaW4uY2FsY3VsYXRlVGV4dFBvc2l0aW9uKHt9LCBzdHlsZSwgcmVjdCk7XG4gICAgICAgIHggPSByZXMueDtcbiAgICAgICAgeSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJlY3QueDtcbiAgICAgIHkgPSByZWN0Lnk7XG4gICAgfVxuXG4gICAgeCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKHgsIHRleHRSZWN0LndpZHRoLCBhbGlnbik7XG4gICAgeSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKHksIHRleHRSZWN0LmhlaWdodCwgdmVydGljYWxBbGlnbik7IC8vIEZvcmNlIGJhc2VsaW5lICdtaWRkbGUnXG5cbiAgICB5ICs9IHRleHRSZWN0LmhlaWdodCAvIDI7IC8vIHZhciBmb250U2l6ZSA9IGZvbnRTdHlsZS5zaXplO1xuICAgIC8vIDEuNzUgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciwgYXMgdGhlcmUgaXMgbm8gaW5mbyBhYm91dCB0aGUgdGV4dCBiYXNlbGluZVxuICAgIC8vIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAvLyBjYXNlICd0b3AnOlxuICAgIC8vICAgICB5ICs9IGZvbnRTaXplIC8gMS43NTtcbiAgICAvLyAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgZGVmYXVsdDpcbiAgICAvLyAgICAgLy8gY2FzZSBudWxsOlxuICAgIC8vICAgICAvLyBjYXNlICdhbHBoYWJldGljJzpcbiAgICAvLyAgICAgLy8gY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgIC8vICAgICAvLyBjYXNlICdib3R0b20nOlxuICAgIC8vICAgICAgICAgeSAtPSBmb250U2l6ZSAvIDIuMjU7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyB9XG4gICAgLy8gc3dpdGNoIChhbGlnbikge1xuICAgIC8vICAgICBjYXNlICdsZWZ0JzpcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdjZW50ZXInOlxuICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aCAvIDI7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAncmlnaHQnOlxuICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aDtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vIGNhc2UgJ2VuZCc6XG4gICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAvLyBicmVhaztcbiAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdydGwnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAvLyBicmVhaztcbiAgICAvLyBkZWZhdWx0OlxuICAgIC8vICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAvLyB9XG5cbiAgICB2YXIgY3JlYXRlTm9kZSA9IHZtbENvcmUuY3JlYXRlTm9kZTtcbiAgICB2YXIgdGV4dFZtbEVsID0gdGhpcy5fdGV4dFZtbEVsO1xuICAgIHZhciBwYXRoRWw7XG4gICAgdmFyIHRleHRQYXRoRWw7XG4gICAgdmFyIHNrZXdFbDtcblxuICAgIGlmICghdGV4dFZtbEVsKSB7XG4gICAgICB0ZXh0Vm1sRWwgPSBjcmVhdGVOb2RlKCdsaW5lJyk7XG4gICAgICBwYXRoRWwgPSBjcmVhdGVOb2RlKCdwYXRoJyk7XG4gICAgICB0ZXh0UGF0aEVsID0gY3JlYXRlTm9kZSgndGV4dHBhdGgnKTtcbiAgICAgIHNrZXdFbCA9IGNyZWF0ZU5vZGUoJ3NrZXcnKTsgLy8gRklYTUUgV2h5IGhlcmUgaXMgbm90IGNhbW1lbCBjYXNlXG4gICAgICAvLyBBbGlnbiAnY2VudGVyJyBzZWVtcyB3cm9uZ1xuXG4gICAgICB0ZXh0UGF0aEVsLnN0eWxlWyd2LXRleHQtYWxpZ24nXSA9ICdsZWZ0JztcbiAgICAgIGluaXRSb290RWxTdHlsZSh0ZXh0Vm1sRWwpO1xuICAgICAgcGF0aEVsLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgdGV4dFBhdGhFbC5vbiA9IHRydWU7XG4gICAgICB0ZXh0Vm1sRWwuZnJvbSA9ICcwIDAnO1xuICAgICAgdGV4dFZtbEVsLnRvID0gJzEwMDAgMC4wNSc7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCBza2V3RWwpO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgcGF0aEVsKTtcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHRleHRQYXRoRWwpO1xuICAgICAgdGhpcy5fdGV4dFZtbEVsID0gdGV4dFZtbEVsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDov5nph4zmmK/lnKjliY3pnaIgYXBwZW5kQ2hpbGQg5L+d6K+B6aG65bqP55qE5YmN5o+Q5LiLXG4gICAgICBza2V3RWwgPSB0ZXh0Vm1sRWwuZmlyc3RDaGlsZDtcbiAgICAgIHBhdGhFbCA9IHNrZXdFbC5uZXh0U2libGluZztcbiAgICAgIHRleHRQYXRoRWwgPSBwYXRoRWwubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IFt4LCB5XTtcbiAgICB2YXIgdGV4dFZtbEVsU3R5bGUgPSB0ZXh0Vm1sRWwuc3R5bGU7IC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuXG4gICAgaWYgKG0gJiYgZnJvbVRleHRFbCkge1xuICAgICAgYXBwbHlUcmFuc2Zvcm0oY29vcmRzLCBjb29yZHMsIG0pO1xuICAgICAgc2tld0VsLm9uID0gdHJ1ZTtcbiAgICAgIHNrZXdFbC5tYXRyaXggPSBtWzBdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMl0udG9GaXhlZCgzKSArIGNvbW1hICsgbVsxXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzNdLnRvRml4ZWQoMykgKyAnLDAsMCc7IC8vIFRleHQgcG9zaXRpb25cblxuICAgICAgc2tld0VsLm9mZnNldCA9IChyb3VuZChjb29yZHNbMF0pIHx8IDApICsgJywnICsgKHJvdW5kKGNvb3Jkc1sxXSkgfHwgMCk7IC8vIExlZnQgdG9wIHBvaW50IGFzIG9yaWdpblxuXG4gICAgICBza2V3RWwub3JpZ2luID0gJzAgMCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSAnMHB4JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2tld0VsLm9uID0gZmFsc2U7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgIH1cblxuICAgIHRleHRQYXRoRWwuc3RyaW5nID0gZW5jb2RlSHRtbEF0dHJpYnV0ZSh0ZXh0KTsgLy8gVE9ET1xuXG4gICAgdHJ5IHtcbiAgICAgIHRleHRQYXRoRWwuc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgfSAvLyBFcnJvciBmb250IGZvcm1hdFxuICAgIGNhdGNoIChlKSB7fVxuXG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdmaWxsJywge1xuICAgICAgZmlsbDogc3R5bGUudGV4dEZpbGwsXG4gICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5XG4gICAgfSwgdGhpcyk7XG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdzdHJva2UnLCB7XG4gICAgICBzdHJva2U6IHN0eWxlLnRleHRTdHJva2UsXG4gICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5LFxuICAgICAgbGluZURhc2g6IHN0eWxlLmxpbmVEYXNoIHx8IG51bGwgLy8gc3R5bGUubGluZURhc2ggY2FuIGJlIGBmYWxzZWAuXG5cbiAgICB9LCB0aGlzKTtcbiAgICB0ZXh0Vm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBdHRhY2hlZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgIHRoaXMuX3RleHRWbWxFbCA9IG51bGw7XG4gIH07XG5cbiAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgbGlzdCA9IFtSZWN0VGV4dCwgRGlzcGxheWFibGUsIFpJbWFnZSwgUGF0aCwgVGV4dF07IC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvdG8gPSBsaXN0W2ldLnByb3RvdHlwZTtcbiAgICBwcm90by5kcmF3UmVjdFRleHQgPSBkcmF3UmVjdFRleHQ7XG4gICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICBwcm90by5hcHBlbmRSZWN0VGV4dCA9IGFwcGVuZFJlY3RUZXh0O1xuICB9XG5cbiAgVGV4dC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB7XG4gICAgICAgIHg6IHN0eWxlLnggfHwgMCxcbiAgICAgICAgeTogc3R5bGUueSB8fCAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG59IiwicmVxdWlyZShcIi4vZ3JhcGhpY1wiKTtcblxudmFyIF96cmVuZGVyID0gcmVxdWlyZShcIi4uL3pyZW5kZXJcIik7XG5cbnZhciByZWdpc3RlclBhaW50ZXIgPSBfenJlbmRlci5yZWdpc3RlclBhaW50ZXI7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxucmVnaXN0ZXJQYWludGVyKCd2bWwnLCBQYWludGVyKTsiLCJ2YXIgZ3VpZCA9IHJlcXVpcmUoXCIuL2NvcmUvZ3VpZFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgSGFuZGxlciA9IHJlcXVpcmUoXCIuL0hhbmRsZXJcIik7XG5cbnZhciBTdG9yYWdlID0gcmVxdWlyZShcIi4vU3RvcmFnZVwiKTtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG52YXIgQW5pbWF0aW9uID0gcmVxdWlyZShcIi4vYW5pbWF0aW9uL0FuaW1hdGlvblwiKTtcblxudmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoXCIuL2RvbS9IYW5kbGVyUHJveHlcIik7XG5cbi8qIVxuKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTElDRU5TRVxuKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiovXG52YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG52YXIgcGFpbnRlckN0b3JzID0ge1xuICBjYW52YXM6IFBhaW50ZXJcbn07XG52YXIgaW5zdGFuY2VzID0ge307IC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbnZhciB2ZXJzaW9uID0gJzQuMy4yJztcbi8qKlxuICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRvbSwgb3B0cykge1xuICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgcmV0dXJuIHpyO1xufVxuLyoqXG4gKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoenIpIHtcbiAgaWYgKHpyKSB7XG4gICAgenIuZGlzcG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGFpbnRlcihuYW1lLCBDdG9yKSB7XG4gIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG5cbmZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xufVxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbnZhciBaUmVuZGVyID0gZnVuY3Rpb24gKGlkLCBkb20sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IGlkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7IC8vIFRPRE8gV2ViR0xcblxuICBpZiAodXNlVk1MKSB7XG4gICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gIH0gZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgfVxuXG4gIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cywgaWQpO1xuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICB2YXIgaGFuZGVyUHJveHkgPSAhZW52Lm5vZGUgJiYgIWVudi53b3JrZXIgPyBuZXcgSGFuZGxlclByb3h5KHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCksIHBhaW50ZXIucm9vdCkgOiBudWxsO1xuICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSwgcGFpbnRlci5yb290KTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgKi9cblxuICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgIHN0YWdlOiB7XG4gICAgICB1cGRhdGU6IHpyVXRpbC5iaW5kKHRoaXMuZmx1c2gsIHRoaXMpXG4gICAgfVxuICB9KTtcbiAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9uZWVkc1JlZnJlc2g7IC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgLy8gRklYTUUg5pyJ54K5dWdseVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgfTtcbn07XG5cblpSZW5kZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcblxuICAvKipcbiAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWFg+e0oFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jb25maWdMYXllcikge1xuICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZCBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZENvbG9yXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLnNldEJhY2tncm91bmRDb2xvcikge1xuICAgICAgdGhpcy5wYWludGVyLnNldEJhY2tncm91bmRDb2xvcihiYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTsgLy8gQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7IC8vIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIHZhciBsb2cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nJyk7XG4gICAgLy8gaWYgKGxvZykge1xuICAgIC8vICAgICBsb2cuaW5uZXJIVE1MID0gbG9nLmlubmVySFRNTCArICc8YnI+JyArIChlbmQgLSBzdGFydCk7XG4gICAgLy8gfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWxsIHJlZnJlc2hcbiAgICovXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyaWdnZXJSZW5kZXJlZDtcblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRyaWdnZXJSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgdHJpZ2dlclJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyUmVuZGVyZWQgJiYgdGhpcy50cmlnZ2VyKCdyZW5kZXJlZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdmFyIGVsTWlycm9yID0gdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgcmV0dXJuIGVsTWlycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7IiwiaW1wb3J0IHsgcGlwZVZlcnRleERhdGEgfSBmcm9tIFwiLi9waXBlVmVydGV4RGF0YVwiO1xyXG4vKipcclxuICog5ZCE5Yqf6IO95rGg55qE5bGe5oCn77yM5YyF5ous77yaXHJcbiAqICAtIGlkXHJcbiAqICAtIOWQjeensFxyXG4gKiAgLSDlrZfkvZNcclxuICogIC0g5bem5LiK5ZKM5Y+z5LiL54K555qE5Z2Q5qCHXHJcbiAqL1xyXG5jb25zdCBibG9ja1ZlcnRleERhdGEgPSBbXHJcbiAgLy8g5ZCE5pa55Z2X5rWL6YeP5pWw5o2uXHJcbiAge1xyXG4gICAgaWQ6IFwiMVwiLFxyXG4gICAgbmFtZTogXCLmj5DmoIfnoZ3ljJbmu6TmsaBcIixcclxuICAgIGZvbnQ6IFwiMTZweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDFfMS5jb29yLnNsaWNlKDApWzBdLCAtMTgwXSxcclxuICAgIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSwgcGlwZVZlcnRleERhdGEuaW5wdXQzXzIuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgfSxcclxuICAvL3tpZDogJzFfYXR0YWNoJywgbmFtZTogJycsIGZvbnQ6ICcxNnB4IE1pY3Jvc29mdCBZYUhlaScsIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSwgLTE4MF0sIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDIwLCAtMTAwXX0sXHJcbiAge1xyXG4gICAgaWQ6IFwiMlwiLFxyXG4gICAgbmFtZTogXCLmj5DmoIflj43noZ3ljJbmsaBcIixcclxuICAgIGZvbnQ6IFwiMTZweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDJfMS5jb29yLnNsaWNlKDApWzBdLCAtMTgwXSxcclxuICAgIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSwgcGlwZVZlcnRleERhdGEuaW5wdXQzXzIuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgfSxcclxuICAvL3tpZDogJzJfYXR0YWNoJywgbmFtZTogJycsIGZvbnQ6ICcxNnB4IE1pY3Jvc29mdCBZYUhlaScsIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSwgLTE4MF0sIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSsyMCwgLTgwXX0sXHJcblxyXG4gIHtcclxuICAgIGlkOiBcIjNcIixcclxuICAgIG5hbWU6IFwi5o+Q5qCHXFxu5ruk5biDXFxu5ruk5rGgXCIsXHJcbiAgICBmb250OiBcIjEwcHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICB2ZXJ0ZXgxOiBbcGlwZVZlcnRleERhdGEuaW5wdXQzXzEuY29vci5zbGljZSgwKVswXSwgLTE4MF0sXHJcbiAgICB2ZXJ0ZXgyOiBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLmlucHV0M18yLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6IFwiNVwiLFxyXG4gICAgbmFtZTogXCLmianlu7pcXG7mu6TluINcXG7mu6TmsaBcIixcclxuICAgIGZvbnQ6IFwiMTFweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDZfMS5jb29yLnNsaWNlKDApWzBdICsgNTAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDVfMS5jb29yLnNsaWNlKDApWzBdLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogXCI2XCIsXHJcbiAgICBuYW1lOiBcIuaPkOagh+azteaIv1xcbuWPiuiHreawp1wiLFxyXG4gICAgZm9udDogXCIxM3B4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgdmVydGV4MTogW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0sIC0xODBdLFxyXG4gICAgdmVydGV4MjogW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0gKyAxMDAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0M18yLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6IFwiN1wiLFxyXG4gICAgbmFtZTogXCLmm53msJTmtLvmgKfngq3msaBcIixcclxuICAgIGZvbnQ6IFwiMTZweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgIHZlcnRleDE6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDdfMS5jb29yLnNsaWNlKDApWzBdLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIuY29vci5zbGljZSgwKVsxXSAtIDEyMF0sXHJcbiAgICB2ZXJ0ZXgyOiBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSwgcGlwZVZlcnRleERhdGEub3V0cHV0N18yLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6IFwiMTNcIixcclxuICAgIG5hbWU6IFwi57u85ZCI6L+b5Ye65rC05rGgXCIsXHJcbiAgICBmb250OiBcIjE0cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICB2ZXJ0ZXgxOiBbcGlwZVZlcnRleERhdGEuaW5wdXQxM18xLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDEzXzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgICB2ZXJ0ZXgyOiBbNzg0LCBwaXBlVmVydGV4RGF0YS5pbnB1dDEzXzIuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgfSxcclxuICAvL3tpZDogJzEzX2F0dGFjaCcsIG5hbWU6ICcnLCBmb250OiAnMTZweCBNaWNyb3NvZnQgWWFIZWknLCB2ZXJ0ZXgxOiBbcGlwZVZlcnRleERhdGEuaW5wdXQxM18xLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDEzXzEuY29vci5zbGljZSgwKVsxXS0yMF0sIHZlcnRleDI6IFs3ODQsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDEzXzEuY29vci5zbGljZSgwKVsxXV19LFxyXG4gIHtcclxuICAgIGlkOiBcIjE1XCIsXHJcbiAgICBuYW1lOiBcIui2hea7pOi9pumXtFwiLFxyXG4gICAgZm9udDogXCIxNnB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgdmVydGV4MTogW3BpcGVWZXJ0ZXhEYXRhLmlucHV0N18xLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxNV8yLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzUuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogXCIxN1wiLFxyXG4gICAgbmFtZTogXCLnu7zlkIjmjqfliLblrqRcIixcclxuICAgIGZvbnQ6IFwiMTZweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgIHZlcnRleDE6IFs3ODAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDEzXzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgICB2ZXJ0ZXgyOiBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSwgcGlwZVZlcnRleERhdGEuaW5wdXQxM18yLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIH0sXHJcblxyXG4gIHsgaWQ6IFwiNFwiLCBuYW1lOiBcIuaJqeW7uuW3peeoi+iwg+iKguaxoFwiLCBmb250OiBcIjE0cHggTWljcm9zb2Z0IFlhSGVpXCIsIHZlcnRleDE6IFsxMzAwLCA3NzBdLCB2ZXJ0ZXgyOiBbMTYwMCwgOTAwXSB9LFxyXG5cclxuICB7IGlkOiBcIjhcIiwgbmFtZTogXCLoh63msKflj5HnlJ/lmahcIiwgZm9udDogXCIxMnB4IE1pY3Jvc29mdCBZYUhlaVwiLCB2ZXJ0ZXgxOiBbMTQ1MCwgMTAwXSwgdmVydGV4MjogWzE1NjAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDdfMi5jb29yLnNsaWNlKDApWzFdXSB9LFxyXG4gIHsgaWQ6IFwiOVwiLCBuYW1lOiBcIuaxoeazpea1k+e8qeaxoFwiLCBmb250OiBcIjEycHggTWljcm9zb2Z0IFlhSGVpXCIsIHZlcnRleDE6IFsxNDUwLCAtNTBdLCB2ZXJ0ZXgyOiBbMTU2MCwgMzBdIH0sXHJcbiAgeyBpZDogXCIxMFwiLCBuYW1lOiBcIuiEseawtOacuuaIv+WKoFxcbuiNr+mZpOiHreezu+e7n1wiLCBmb250OiBcIjEzcHggTWljcm9zb2Z0IFlhSGVpXCIsIHZlcnRleDE6IFsxNjAwLCAtMTgwXSwgdmVydGV4MjogWzE3NTAsIC00MF0gfSxcclxuICB7IGlkOiBcIjExXCIsIG5hbWU6IFwi5Y+Y55S156uZXCIsIGZvbnQ6IFwiMTRweCBNaWNyb3NvZnQgWWFIZWlcIiwgdmVydGV4MTogWzE2MzAsIDUyXSwgdmVydGV4MjogWzE3NTAsIDE4Ml0gfSxcclxuICB7IGlkOiBcIjEyXCIsIG5hbWU6IFwi5ray5rCn56uZXCIsIGZvbnQ6IFwiMTJweCBNaWNyb3NvZnQgWWFIZWlcIiwgdmVydGV4MTogWzE0NTAsIC0xODBdLCB2ZXJ0ZXgyOiBbMTUwMCwgLTExMF0gfSxcclxuXHJcbiAge1xyXG4gICAgaWQ6IFwiMTRcIixcclxuICAgIG5hbWU6IFwi5omp5bu656Gd5YyW6L2m6Ze0XCIsXHJcbiAgICBmb250OiBcIjE2cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICB2ZXJ0ZXgxOiBbOTYwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgICB2ZXJ0ZXgyOiBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSwgcGlwZVZlcnRleERhdGEub3V0cHV0MTVfNS5jb29yLnNsaWNlKDApWzFdXSxcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiBcIjE0XCIsXHJcbiAgICBuYW1lOiBcIuaJqeW7uuWPjeehneWMluaxoFwiLFxyXG4gICAgZm9udDogXCIxNnB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgdmVydGV4MTogWzE1MTAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIHZlcnRleDI6IFsxNzUwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQxNV81LmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIH0sXHJcblxyXG4gIHtcclxuICAgIGlkOiBcIjE2XCIsXHJcbiAgICBuYW1lOiBcIumrmOaViFxcbuayiea3gOaxoFwiLFxyXG4gICAgZm9udDogXCIxNHB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgdmVydGV4MTogW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0sIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIHZlcnRleDI6IFsxNDAwLCA1MjBdLFxyXG4gIH0sXHJcblxyXG4gIHtcclxuICAgIGlkOiBcInVuZGVmaW5lZDFcIixcclxuICAgIG5hbWU6IFwiXCIsXHJcbiAgICBmb250OiBcIjE0cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICB2ZXJ0ZXgxOiBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSAtIDE4MCwgMjIwXSxcclxuICAgIHZlcnRleDI6IFtwaXBlVmVydGV4RGF0YS5pbnB1dDdfMi5jb29yLnNsaWNlKDApWzBdLCAyNTBdLFxyXG4gIH0sXHJcbiAgeyBpZDogXCJ1bmRlZmluZWQyXCIsIG5hbWU6IFwiXCIsIGZvbnQ6IFwiMTRweCBNaWNyb3NvZnQgWWFIZWlcIiwgdmVydGV4MTogW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0sIDIyMF0sIHZlcnRleDI6IFsxNzUwLCAyNTBdIH0sXHJcblxyXG4gIC8qXHJcbiAgICAgICAge2lkOiAnNF9hdHRhY2gnLCBuYW1lOiAnJywgZm9udDogJzE2cHggTWljcm9zb2Z0IFlhSGVpJywgdmVydGV4MTogWzU4NywgLTEyMF0sIHZlcnRleDI6IFs3ODQsIC04MF19LFxyXG4gICAgKi9cclxuXTtcclxuXHJcbmV4cG9ydCB7IGJsb2NrVmVydGV4RGF0YSB9O1xyXG4iLCJpbXBvcnQgeyBwaXBlRGF0YV9vcmlnaW4sIHBpcGVEYXRhX25vRGF0YSB9IGZyb20gXCIuL3BpcGVEYXRhXCI7XHJcbmltcG9ydCB7IGJsb2NrVmVydGV4RGF0YSB9IGZyb20gXCIuL2Jsb2NrVmVydGV4RGF0YVwiO1xyXG5pbXBvcnQgeyBwaXBlVmVydGV4RGF0YSwgbm9kZXMgfSBmcm9tIFwiLi9waXBlVmVydGV4RGF0YVwiO1xyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vICoqIGNvb3JNYXAuanNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgICDlnZDmoIfmmKDlsITvvIjmtYvph48tLT7nu5jliLbvvIlcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5sZXQgdGl0bGVfaGVpZ2h0ID0gMTAwO1xyXG5cclxubGV0IG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXHJcbiAgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gIG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblxyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVEYXRhX29yaWdpbi5sZW5ndGg7IGkrKykge1xyXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICBpZiAocGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMF0gPCBtaW5YKSBtaW5YID0gcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMF07XHJcbiAgICBpZiAocGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMF0gPiBtYXhYKSBtYXhYID0gcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMF07XHJcbiAgICBpZiAocGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMV0gPCBtaW5ZKSBtaW5ZID0gcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMV07XHJcbiAgICBpZiAocGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMV0gPiBtYXhZKSBtYXhZID0gcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3JbMV07XHJcbiAgfVxyXG59XHJcblxyXG5mb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrVmVydGV4RGF0YS5sZW5ndGg7IGkrKykge1xyXG4gIGlmIChibG9ja1ZlcnRleERhdGFbaV0udmVydGV4MVswXSA8IG1pblgpIG1pblggPSBibG9ja1ZlcnRleERhdGFbaV0udmVydGV4MVswXTtcclxuICBpZiAoYmxvY2tWZXJ0ZXhEYXRhW2ldLnZlcnRleDJbMF0gPiBtYXhYKSBtYXhYID0gYmxvY2tWZXJ0ZXhEYXRhW2ldLnZlcnRleDJbMF07XHJcbiAgaWYgKGJsb2NrVmVydGV4RGF0YVtpXS52ZXJ0ZXgxWzFdIDwgbWluWSkgbWluWSA9IGJsb2NrVmVydGV4RGF0YVtpXS52ZXJ0ZXgxWzFdO1xyXG4gIGlmIChibG9ja1ZlcnRleERhdGFbaV0udmVydGV4MlsxXSA+IG1heFkpIG1heFkgPSBibG9ja1ZlcnRleERhdGFbaV0udmVydGV4MlsxXTtcclxufVxyXG5cclxuLy8g6LCD5pW05ZCE566h57q/5Lul6YCC5bqU5bGP5bmVXHJcbmZvciAobGV0IG5vZGUgaW4gcGlwZVZlcnRleERhdGEpIHtcclxuICBwaXBlVmVydGV4RGF0YVtub2RlXS5jb29yWzBdID0gKChwaXBlVmVydGV4RGF0YVtub2RlXS5jb29yWzBdIC0gbWluWCkgKiB3aW5kb3cuaW5uZXJXaWR0aCkgLyAobWF4WCAtIG1pblgpIC8gMiArIHdpbmRvdy5pbm5lcldpZHRoIC8gNDtcclxuICBwaXBlVmVydGV4RGF0YVtub2RlXS5jb29yWzFdID1cclxuICAgICgoKHBpcGVWZXJ0ZXhEYXRhW25vZGVdLmNvb3JbMV0gLSBtaW5ZKSAqICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aXRsZV9oZWlnaHQpKSAvIChtYXhZIC0gbWluWSkpICogMC45OCArIHRpdGxlX2hlaWdodDtcclxufVxyXG5sZXQgcGlwZVZlcnRleERhdGFfb3JpZ2luID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwaXBlVmVydGV4RGF0YSkpOyAvLyDkv53nlZnljp/lp4vlnZDmoIfnmoTmi7fotJ1cclxuXHJcbmxldCBwaXBlc19ub0RhdGFfZHJhd0RhdGEgPSBuZXcgQXJyYXkocGlwZURhdGFfbm9EYXRhLmxlbmd0aCk7IC8vIOaXoOaVsOaNruWdkOagh+eCuVxyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVzX25vRGF0YV9kcmF3RGF0YS5sZW5ndGg7IGkrKykge1xyXG4gIHBpcGVzX25vRGF0YV9kcmF3RGF0YVtpXSA9IG5ldyBBcnJheShwaXBlRGF0YV9ub0RhdGFbaV0ubGVuZ3RoKTtcclxuICBmb3IgKGxldCBzZWdtZW50ID0gMDsgc2VnbWVudCA8IHBpcGVEYXRhX25vRGF0YVtpXS5sZW5ndGg7IHNlZ21lbnQrKykge1xyXG4gICAgcGlwZXNfbm9EYXRhX2RyYXdEYXRhW2ldW3NlZ21lbnRdID0gbmV3IEFycmF5KDIpO1xyXG4gICAgcGlwZXNfbm9EYXRhX2RyYXdEYXRhW2ldW3NlZ21lbnRdWzBdID0gKChwaXBlRGF0YV9ub0RhdGFbaV1bc2VnbWVudF1bMF0gLSBtaW5YKSAqIHdpbmRvdy5pbm5lcldpZHRoKSAvIChtYXhYIC0gbWluWCkgLyAyICsgd2luZG93LmlubmVyV2lkdGggLyA0O1xyXG4gICAgcGlwZXNfbm9EYXRhX2RyYXdEYXRhW2ldW3NlZ21lbnRdWzFdID1cclxuICAgICAgKCgocGlwZURhdGFfbm9EYXRhW2ldW3NlZ21lbnRdWzFdIC0gbWluWSkgKiAod2luZG93LmlubmVySGVpZ2h0IC0gdGl0bGVfaGVpZ2h0KSkgLyAobWF4WSAtIG1pblkpKSAqIDAuOTggKyB0aXRsZV9oZWlnaHQ7XHJcbiAgfVxyXG59XHJcbmxldCBwaXBlc19ub0RhdGFfZHJhd0RhdGFfb3JpZ2luID0gbmV3IEFycmF5KHBpcGVzX25vRGF0YV9kcmF3RGF0YS5sZW5ndGgpO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVzX25vRGF0YV9kcmF3RGF0YV9vcmlnaW4ubGVuZ3RoOyBpKyspIHtcclxuICBwaXBlc19ub0RhdGFfZHJhd0RhdGFfb3JpZ2luW2ldID0gbmV3IEFycmF5KHBpcGVzX25vRGF0YV9kcmF3RGF0YVtpXS5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZXNfbm9EYXRhX2RyYXdEYXRhX29yaWdpbltpXS5sZW5ndGg7IGorKykge1xyXG4gICAgcGlwZXNfbm9EYXRhX2RyYXdEYXRhX29yaWdpbltpXVtqXSA9IHBpcGVzX25vRGF0YV9kcmF3RGF0YVtpXVtqXS5zbGljZSgwKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIOiwg+aVtOWQhOawtOaxoOS7pemAguW6lOWxj+W5lVxyXG5sZXQgYmxvY2tEYXRhX2ZpdCA9IGJsb2NrVmVydGV4RGF0YS5zbGljZSgwKTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0RhdGFfZml0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdID0gKChibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMF0gLSBtaW5YKSAqIHdpbmRvdy5pbm5lcldpZHRoKSAvIChtYXhYIC0gbWluWCkgLyAyICsgd2luZG93LmlubmVyV2lkdGggLyA0O1xyXG4gIGJsb2NrRGF0YV9maXRbaV0udmVydGV4MlswXSA9ICgoYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzBdIC0gbWluWCkgKiB3aW5kb3cuaW5uZXJXaWR0aCkgLyAobWF4WCAtIG1pblgpIC8gMiArIHdpbmRvdy5pbm5lcldpZHRoIC8gNDtcclxuICBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0gPSAoKChibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0gLSBtaW5ZKSAqICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aXRsZV9oZWlnaHQpKSAvIChtYXhZIC0gbWluWSkpICogMC45OCArIHRpdGxlX2hlaWdodDtcclxuICBibG9ja0RhdGFfZml0W2ldLnZlcnRleDJbMV0gPSAoKChibG9ja0RhdGFfZml0W2ldLnZlcnRleDJbMV0gLSBtaW5ZKSAqICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aXRsZV9oZWlnaHQpKSAvIChtYXhZIC0gbWluWSkpICogMC45OCArIHRpdGxlX2hlaWdodDtcclxufVxyXG5cclxuLy8g6LCD5pW06Iqx6YeM6IOh5ZOo55qE6IqC54K5XHJcbmxldCBub2Rlc19vcmlnaW4gPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gIG5vZGVzW2ldWzBdID0gKChub2Rlc1tpXVswXSAtIG1pblgpICogd2luZG93LmlubmVyV2lkdGgpIC8gKG1heFggLSBtaW5YKSAvIDIgKyB3aW5kb3cuaW5uZXJXaWR0aCAvIDQ7XHJcbiAgbm9kZXNbaV1bMV0gPSAoKChub2Rlc1tpXVsxXSAtIG1pblkpICogKHdpbmRvdy5pbm5lckhlaWdodCAtIHRpdGxlX2hlaWdodCkpIC8gKG1heFkgLSBtaW5ZKSkgKiAwLjk4ICsgdGl0bGVfaGVpZ2h0O1xyXG4gIG5vZGVzX29yaWdpbltpXSA9IG5ldyBBcnJheSgyKTtcclxuICBub2Rlc19vcmlnaW5baV1bMF0gPSBub2Rlc1tpXVswXTtcclxuICBub2Rlc19vcmlnaW5baV1bMV0gPSBub2Rlc1tpXVsxXTtcclxufVxyXG5cclxuZXhwb3J0IHsgYmxvY2tEYXRhX2ZpdCwgcGlwZXNfbm9EYXRhX2RyYXdEYXRhLCBwaXBlc19ub0RhdGFfZHJhd0RhdGFfb3JpZ2luIH07XHJcbiIsIi8vIOe6v+aAp+aPkuWAvFxyXG5jb25zdCBsaW5lYXJJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIHByb3ApIHtcclxuICByZXR1cm4gdmFsMSArIHByb3AgKiAodmFsMiAtIHZhbDEpO1xyXG59O1xyXG5cclxuLy8g55Sf5oiQ5LiA5LiqKG1pbiwgbWF4XeiMg+WbtOWGheeahOmaj+acuuaVsFxyXG5jb25zdCByYW5kTnVtID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGxpbmVhckludGVycG9sYXRpb24sIHJhbmROdW0gfTtcclxuIiwiaW1wb3J0IHsgcGlwZVZlcnRleERhdGEgfSBmcm9tIFwiLi9waXBlVmVydGV4RGF0YVwiO1xyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vICoqIHBpcGVEYXRhLmpzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gICAg5pW05p2h566h57q/5pWw5o2uXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxubGV0IHBpcGVEYXRhX29yaWdpbiA9IFtcclxuICB7IG5hbWU6IFwicGlwZTFcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxM18xLCBwaXBlVmVydGV4RGF0YS5qNDcsIHBpcGVWZXJ0ZXhEYXRhLmo0NiwgcGlwZVZlcnRleERhdGEuajEsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MV8xXSB9LFxyXG4gIHsgbmFtZTogXCJwaXBlMlwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLmozLCBwaXBlVmVydGV4RGF0YS5qNCwgcGlwZVZlcnRleERhdGEuajZdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUzXCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0MV8xLCBwaXBlVmVydGV4RGF0YS5pbnB1dDJfMV0gfSxcclxuICB7IG5hbWU6IFwicGlwZTRcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5qNCwgcGlwZVZlcnRleERhdGEuajcsIHBpcGVWZXJ0ZXhEYXRhLmo5XSB9LFxyXG4gIHsgbmFtZTogXCJwaXBlNVwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDJfMSwgcGlwZVZlcnRleERhdGEuaW5wdXQzXzFdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGU2XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLCBwaXBlVmVydGV4RGF0YS5pbnB1dDZfMV0gfSxcclxuICB7XHJcbiAgICBuYW1lOiBcInBpcGU3XCIsXHJcbiAgICB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDZfMSwgcGlwZVZlcnRleERhdGEuajE0LCBwaXBlVmVydGV4RGF0YS5qMTUsIHBpcGVWZXJ0ZXhEYXRhLmoxNiwgcGlwZVZlcnRleERhdGEuajE4LCBwaXBlVmVydGV4RGF0YS5qMjBdLFxyXG4gIH0sXHJcbiAgeyBuYW1lOiBcInBpcGU4XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEuajE3LCBwaXBlVmVydGV4RGF0YS5pbnB1dDdfMV0gfSxcclxuICB7IG5hbWU6IFwicGlwZTlcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIsIHBpcGVWZXJ0ZXhEYXRhLmoyMiwgcGlwZVZlcnRleERhdGEuajIwXSB9LFxyXG4gIHtcclxuICAgIG5hbWU6IFwicGlwZTEwXCIsXHJcbiAgICB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzEsIHBpcGVWZXJ0ZXhEYXRhLmoxMywgcGlwZVZlcnRleERhdGEuajEyLCBwaXBlVmVydGV4RGF0YS5qMTEsIHBpcGVWZXJ0ZXhEYXRhLmoxMCwgcGlwZVZlcnRleERhdGEuaW5wdXQzXzJdLFxyXG4gIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUxMVwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDZfMiwgcGlwZVZlcnRleERhdGEuajIzLCBwaXBlVmVydGV4RGF0YS5qMjQsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0N18yXSB9LFxyXG4gIHsgbmFtZTogXCJwaXBlMTJcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5qMjQsIHBpcGVWZXJ0ZXhEYXRhLmoyNV8xLCBwaXBlVmVydGV4RGF0YS5qMjVfMiwgcGlwZVZlcnRleERhdGEuajI2LCBwaXBlVmVydGV4RGF0YS5qMjddIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUxM1wiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDdfMywgcGlwZVZlcnRleERhdGEuajI4LCBwaXBlVmVydGV4RGF0YS5qMjksIHBpcGVWZXJ0ZXhEYXRhLmozMF0gfSxcclxuICB7IG5hbWU6IFwicGlwZTE0XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0MTVfMywgcGlwZVZlcnRleERhdGEuajMwLCBwaXBlVmVydGV4RGF0YS5qMzNdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUxNVwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzQsIHBpcGVWZXJ0ZXhEYXRhLmozMywgcGlwZVZlcnRleERhdGEuajM0LCBwaXBlVmVydGV4RGF0YS5qMzUsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTdfMl0gfSxcclxuICB7IG5hbWU6IFwicGlwZTE2XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0NV8xLCBwaXBlVmVydGV4RGF0YS5pbnB1dDZfMl0gfSxcclxuICB7IG5hbWU6IFwicGlwZTE3XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEuajIwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzFdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUxOFwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLmoyMSwgcGlwZVZlcnRleERhdGEuajM3LCBwaXBlVmVydGV4RGF0YS5qMzZdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUxOVwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzUsIHBpcGVWZXJ0ZXhEYXRhLmozNiwgcGlwZVZlcnRleERhdGEuaW5wdXQxN18xXSB9LFxyXG4gIHtcclxuICAgIG5hbWU6IFwicGlwZTIwXCIsXHJcbiAgICB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzIsIHBpcGVWZXJ0ZXhEYXRhLmozOCwgcGlwZVZlcnRleERhdGEuajM5LCBwaXBlVmVydGV4RGF0YS5qNDAsIHBpcGVWZXJ0ZXhEYXRhLmo0MSwgcGlwZVZlcnRleERhdGEuaW5wdXQ1XzFdLFxyXG4gIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUyMVwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDdfMSwgcGlwZVZlcnRleERhdGEuajQyLCBwaXBlVmVydGV4RGF0YS5qNDMsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTNfMV0gfSxcclxuICB7IG5hbWU6IFwicGlwZTIyXCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0MTNfMiwgcGlwZVZlcnRleERhdGEuajQ4LCBwaXBlVmVydGV4RGF0YS5qNDddIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUyM1wiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDEzXzMsIHBpcGVWZXJ0ZXhEYXRhLmo0OSwgcGlwZVZlcnRleERhdGEuajQ4XSB9LFxyXG4gIHsgbmFtZTogXCJwaXBlMjRcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxM180LCBwaXBlVmVydGV4RGF0YS5qNTAsIHBpcGVWZXJ0ZXhEYXRhLmo0OV0gfSxcclxuICB7IG5hbWU6IFwicGlwZTI1XCIsIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0MTNfNSwgcGlwZVZlcnRleERhdGEuajUxLCBwaXBlVmVydGV4RGF0YS5qNTBdIH0sXHJcbiAgeyBuYW1lOiBcInBpcGUyNlwiLCB2ZXJ0aWNlczogW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDE3XzEsIHBpcGVWZXJ0ZXhEYXRhLmo1OSwgcGlwZVZlcnRleERhdGEuajU2IC8qLCBbODA1LCA5OTBdKi9dIH0sXHJcbiAge1xyXG4gICAgbmFtZTogXCJwaXBlMjdcIixcclxuICAgIHZlcnRpY2VzOiBbcGlwZVZlcnRleERhdGEub3V0cHV0MTdfMiwgcGlwZVZlcnRleERhdGEuajUyLCBwaXBlVmVydGV4RGF0YS5qNTMsIHBpcGVWZXJ0ZXhEYXRhLmo1NSwgcGlwZVZlcnRleERhdGEuajU2LCBwaXBlVmVydGV4RGF0YS5fajYwXSxcclxuICB9LFxyXG4gIHsgbmFtZTogXCJwaXBlMjhcIiwgdmVydGljZXM6IFtwaXBlVmVydGV4RGF0YS5vdXRzaWRlLCBwaXBlVmVydGV4RGF0YS5pbnB1dDEzXzJdIH0sXHJcbiAgLy97bmFtZTogJ3BpcGUyOScsIHZlcnRpY2VzOiBbWzc4OSwgOTkwXSwgWzc2MSwgOTkwXV19XHJcbl07XHJcbmxldCBwaXBlRGF0YV9ub0RhdGEgPSBbXHJcbiAgW1xyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDFfMS5jb29yLnNsaWNlKDApWzBdLCAtMTYwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTYwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDYwLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDYwLCAtMzVdLFxyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0gKyAyMCwgLTM1XSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDZfMS5jb29yLnNsaWNlKDApWzBdICsgMjAsIDIwMF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ2XzEuY29vci5zbGljZSgwKVswXSArIDcwLCAyMDBdLFxyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0gKyA3MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDFfMS5jb29yLnNsaWNlKDApWzBdLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQxXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTMwXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDZfMS5jb29yLnNsaWNlKDApWzBdICsgMjAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDVfMS5jb29yLnNsaWNlKDApWzFdICsgNTBdLFxyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLmlucHV0Nl8xLmNvb3Iuc2xpY2UoMClbMF0gKyA1MCwgcGlwZVZlcnRleERhdGEub3V0cHV0NV8xLmNvb3Iuc2xpY2UoMClbMV0gKyA1MF0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ2XzEuY29vci5zbGljZSgwKVswXSArIDIwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ1XzEuY29vci5zbGljZSgwKVsxXSArIDkwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDZfMS5jb29yLnNsaWNlKDApWzBdICsgNTAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDVfMS5jb29yLnNsaWNlKDApWzFdICsgOTBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDJfMS5jb29yLnNsaWNlKDApWzBdLCAtMTYwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTYwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSArIDYwLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSArIDYwLCAtMzVdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLm91dHB1dDJfMS5jb29yLnNsaWNlKDApWzBdLCAtMTMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQyXzEuY29vci5zbGljZSgwKVswXSArIDMwLCAtMTMwXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQzXzEuY29vci5zbGljZSgwKVswXSwgLTE2MF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0gKyAyMCwgLTE2MF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0gKyAyMCwgLTM1XSxcclxuICBdLFxyXG4gIFtcclxuICAgIFtwaXBlVmVydGV4RGF0YS5vdXRwdXQzXzEuY29vci5zbGljZSgwKVswXSwgLTEwMF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0gKyAyMCwgLTEwMF0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0sIC04MF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEub3V0cHV0M18xLmNvb3Iuc2xpY2UoMClbMF0gKyAyMCwgLTgwXSxcclxuICBdLFxyXG5cclxuICBbXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSwgMjM1XSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDZfMS5jb29yLnNsaWNlKDApWzBdLCAyMzVdLFxyXG4gIF0sXHJcblxyXG4gIFtcclxuICAgIFsxNzAwLCAyNTBdLFxyXG4gICAgWzE3MDAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG5cclxuICBbXHJcbiAgICBbMTE1MCwgMjUwXSxcclxuICAgIFsxMTUwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgXSxcclxuXHJcbiAgW1xyXG4gICAgWzEwMjAsIDI1MF0sXHJcbiAgICBbMTAyMCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIF0sXHJcblxyXG4gIFtcclxuICAgIFsxMzAwLCAyNTBdLFxyXG4gICAgWzEzMDAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG5cclxuICAvLyA55rGh5rOl5rWT57yp5rGg5LiK5LiLXHJcbiAgW1xyXG4gICAgWzE0MDAsIDQzNV0sXHJcbiAgICBbMTQyMCwgNDM1XSxcclxuICAgIFsxNDIwLCA2MF0sXHJcbiAgICBbMTUyMCwgNjBdLFxyXG4gICAgWzE1MjAsIDMwXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFsxNDgwLCA2MF0sXHJcbiAgICBbMTQ4MCwgMzBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzE0ODAsIC01MF0sXHJcbiAgICBbMTQ4MCwgLTgwXSxcclxuICAgIFsxNjAwLCAtODBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzE1MjAsIC01MF0sXHJcbiAgICBbMTUyMCwgLTgwXSxcclxuICBdLFxyXG5cclxuICBbXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ2XzEuY29vci5zbGljZSgwKVswXSwgNDM1XSxcclxuICAgIFsxMjMwLCA0MzVdLFxyXG4gICAgWzEyMzAsIDcwMF0sXHJcbiAgICBbMTcwMCwgNzAwXSxcclxuICAgIFsxNzAwLCA4MDBdLFxyXG4gICAgWzE2MDAsIDgwMF0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ2XzEuY29vci5zbGljZSgwKVswXSwgNDc1XSxcclxuICAgIFsxMjMwLCA0NzVdLFxyXG4gIF0sXHJcblxyXG4gIFtcclxuICAgIFsxNjcwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgICBbMTY3MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV0gLSAzMF0sXHJcbiAgICBbMTQ4MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV0gLSAzMF0sXHJcbiAgICBbMTQ4MCwgcGlwZVZlcnRleERhdGEub3V0cHV0N18yLmNvb3Iuc2xpY2UoMClbMV0gKyA0NTBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzE2MDAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIFsxNjAwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXSAtIDMwXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDdfMi5jb29yLnNsaWNlKDApWzBdLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIuY29vci5zbGljZSgwKVsxXSAtIDMwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDdfMi5jb29yLnNsaWNlKDApWzBdICsgMzAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDdfMi5jb29yLnNsaWNlKDApWzFdIC0gMzBdLFxyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLmlucHV0N18yLmNvb3Iuc2xpY2UoMClbMF0gKyAzMCwgcGlwZVZlcnRleERhdGEub3V0cHV0N18yLmNvb3Iuc2xpY2UoMClbMV0gKyA0NTBdLFxyXG4gICAgW3BpcGVWZXJ0ZXhEYXRhLmlucHV0N18yLmNvb3Iuc2xpY2UoMClbMF0gKyA1NTAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDdfMi5jb29yLnNsaWNlKDApWzFdICsgNDUwXSxcclxuICAgIFtwaXBlVmVydGV4RGF0YS5pbnB1dDdfMi5jb29yLnNsaWNlKDApWzBdICsgNTUwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIuY29vci5zbGljZSgwKVsxXSArIDY3MF0sXHJcbiAgICBbMTYwMCwgcGlwZVZlcnRleERhdGEub3V0cHV0N18yLmNvb3Iuc2xpY2UoMClbMV0gKyA2NzBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzk4MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gICAgWzk4MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV0gLSAzMF0sXHJcbiAgICBbcGlwZVZlcnRleERhdGEuaW5wdXQ3XzIuY29vci5zbGljZSgwKVswXSArIDMwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXSAtIDMwXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFsxMDgwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgICBbMTA4MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV0gLSAzMF0sXHJcbiAgXSxcclxuXHJcbiAgW1xyXG4gICAgWzE2MzUsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdXSxcclxuICAgIFsxNjM1LCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXSAtIDYwXSxcclxuICAgIFsxMzUwLCBwaXBlVmVydGV4RGF0YS5pbnB1dDE1XzEuY29vci5zbGljZSgwKVsxXSAtIDYwXSxcclxuICAgIFsxMzUwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQ3XzIuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbMTA1MCwgcGlwZVZlcnRleERhdGEuaW5wdXQxNV8xLmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gICAgWzEwNTAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdIC0gNjBdLFxyXG4gICAgWzEzNTAsIHBpcGVWZXJ0ZXhEYXRhLmlucHV0MTVfMS5jb29yLnNsaWNlKDApWzFdIC0gNjBdLFxyXG4gIF0sXHJcblxyXG4gIFtcclxuICAgIFsxNDUwLCA5MDBdLFxyXG4gICAgWzE0NTAsIDk1MF0sXHJcbiAgICBbMTc1MCwgOTUwXSxcclxuICBdLFxyXG5cclxuICBbXHJcbiAgICBbMTQyMCwgNzcwXSxcclxuICAgIFsxNDIwLCA3NDBdLFxyXG4gICAgWzE2NTAsIDc0MF0sXHJcbiAgICBbMTY1MCwgNjcwXSxcclxuICAgIFsxNjUwLCA2NjBdLFxyXG4gICAgWzEwMDAsIDY2MF0sXHJcbiAgICBbMTAwMCwgcGlwZVZlcnRleERhdGEub3V0cHV0MTVfNS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFsxNDUwLCA3NzBdLFxyXG4gICAgWzE0NTAsIDc0MF0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbMTQ4MCwgNzcwXSxcclxuICAgIFsxNDgwLCA3NDBdLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzEwMzAsIDY2MF0sXHJcbiAgICBbMTAzMCwgcGlwZVZlcnRleERhdGEub3V0cHV0MTVfNS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFsxMTAwLCA2NjBdLFxyXG4gICAgWzExMDAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzUuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbMTEzMCwgNjYwXSxcclxuICAgIFsxMTMwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQxNV81LmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzE1MzAsIDY2MF0sXHJcbiAgICBbMTUzMCwgcGlwZVZlcnRleERhdGEub3V0cHV0MTVfNS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG4gIFtcclxuICAgIFsxNTYwLCA2NjBdLFxyXG4gICAgWzE1NjAsIHBpcGVWZXJ0ZXhEYXRhLm91dHB1dDE1XzUuY29vci5zbGljZSgwKVsxXV0sXHJcbiAgXSxcclxuICBbXHJcbiAgICBbMTYwMCwgNjYwXSxcclxuICAgIFsxNjAwLCBwaXBlVmVydGV4RGF0YS5vdXRwdXQxNV81LmNvb3Iuc2xpY2UoMClbMV1dLFxyXG4gIF0sXHJcbiAgW1xyXG4gICAgWzE2MzAsIDY2MF0sXHJcbiAgICBbMTYzMCwgcGlwZVZlcnRleERhdGEub3V0cHV0MTVfNS5jb29yLnNsaWNlKDApWzFdXSxcclxuICBdLFxyXG5dO1xyXG5cclxuZXhwb3J0IHsgcGlwZURhdGFfb3JpZ2luLCBwaXBlRGF0YV9ub0RhdGEgfTtcclxuIiwiLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyAqKiBwaXBlVmVydGV4RGF0YS5qc1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIOi/memHjOWumuS5ieS6huaJgOacieeahOaVsOaNrueCuVxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmNvbnN0IHBpcGVWZXJ0ZXhEYXRhID0ge1xyXG4gIC8vIERhdGEgcG9pbnRzIG9uIHBpcGVzXHJcbiAgajE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNTE3LCAtMTA1XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGozOiB7IHVzZTogdHJ1ZSwgY29vcjogWzUxNywgLTEwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo0OiB7IHVzZTogdHJ1ZSwgY29vcjogWzgyMCwgLTEwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo2OiB7IHVzZTogdHJ1ZSwgY29vcjogWzgyMCwgLTEwNF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNzogeyB1c2U6IHRydWUsIGNvb3I6IFsxMDk2LCAtMTBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajk6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTA5NiwgLTEwN10sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMTA6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTE1NywgMTVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajExOiB7IHVzZTogdHJ1ZSwgY29vcjogWzU4MiwgMTVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajEyOiB7IHVzZTogdHJ1ZSwgY29vcjogWzU4MiwgMjMxXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoxMzogeyB1c2U6IHRydWUsIGNvb3I6IFs4MzMsIDIzMV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMTQ6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTIyNSwgLTEwMF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMTU6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTIyNSwgNDBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajE2OiB7IHVzZTogdHJ1ZSwgY29vcjogWzU5NiwgNDBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajE3OiB7IHVzZTogdHJ1ZSwgY29vcjogWzU5NiwgMTEwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoxODogeyB1c2U6IHRydWUsIGNvb3I6IFs1OTYsIDE5Nl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMjA6IHsgdXNlOiB0cnVlLCBjb29yOiBbNzk1LCAxOTVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajIxOiB7IHVzZTogdHJ1ZSwgY29vcjogWzkxMCwgMTk1XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoyMjogeyB1c2U6IHRydWUsIGNvb3I6IFs5MzksIDE5NV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMjM6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTI0MCwgLTcwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoyNDogeyB1c2U6IHRydWUsIGNvb3I6IFsxMjQwLCAxMDVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajI1XzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTI0MCwgMTM1XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoyNV8yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzEyMDIsIDEzNV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMjY6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTIwMiwgMTg5XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGoyNzogeyB1c2U6IHRydWUsIGNvb3I6IFs5NzUsIDE4OV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMjg6IHsgdXNlOiB0cnVlLCBjb29yOiBbOTc1LCAyMjRdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajI5OiB7IHVzZTogdHJ1ZSwgY29vcjogWzg5MCwgMjI0XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGozMDogeyB1c2U6IHRydWUsIGNvb3I6IFs4OTAsIDQ1MF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMzM6IHsgdXNlOiB0cnVlLCBjb29yOiBbODkwLCA1MTldLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajM0OiB7IHVzZTogdHJ1ZSwgY29vcjogWzkzMCwgNTE5XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGozNTogeyB1c2U6IHRydWUsIGNvb3I6IFs5NDUsIDU0M10sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMzY6IHsgdXNlOiB0cnVlLCBjb29yOiBbODI4LCA2NDBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajM3OiB7IHVzZTogdHJ1ZSwgY29vcjogWzkxMCwgNjQwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGozODogeyB1c2U6IHRydWUsIGNvb3I6IFs4NzUsIDM4MF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqMzk6IHsgdXNlOiB0cnVlLCBjb29yOiBbODc1LCAyNzBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajQwOiB7IHVzZTogdHJ1ZSwgY29vcjogWzEzODAsIDI3MF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNDE6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTM4MCwgMTExXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo0MjogeyB1c2U6IHRydWUsIGNvb3I6IFs1NTksIDEyOV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNDM6IHsgdXNlOiB0cnVlLCBjb29yOiBbNTU5LCA3NDFdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajQ2OiB7IHVzZTogdHJ1ZSwgY29vcjogWzUxNywgNjM4XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo0NzogeyB1c2U6IHRydWUsIGNvb3I6IFs2MzIsIDYzOF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNDg6IHsgdXNlOiB0cnVlLCBjb29yOiBbNjY1LCA2MzhdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajQ5OiB7IHVzZTogdHJ1ZSwgY29vcjogWzY5OCwgNjM4XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo1MDogeyB1c2U6IHRydWUsIGNvb3I6IFs3MzEsIDYzOF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNTE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNzYzLCA2MzhdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgajUyOiB7IHVzZTogdHJ1ZSwgY29vcjogWzExMDAsIDk0M10sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNTM6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTAzMCwgMTAxNl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNTU6IHsgdXNlOiB0cnVlLCBjb29yOiBbODY2LCAxMDE2XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGo1NjogeyB1c2U6IHRydWUsIGNvb3I6IFs4NjYsIDk5MF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBqNTk6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTAwMCwgOTg5XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG5cclxuICBfajYwOiB7IHVzZTogdHJ1ZSwgY29vcjogWzU1MCwgOTkwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHNpZGU6IHsgdXNlOiB0cnVlLCBjb29yOiBbNzUwLCAxMDUwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG5cclxuICAvLyDlkITlip/og73msaDnmoTovpPlhaXlkozovpPlh7roioLngrlcclxuICBpbnB1dDFfMTogeyB1c2U6IHRydWUsIGNvb3I6IFs1ODcsIC0xMDVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MV8xOiB7IHVzZTogdHJ1ZSwgY29vcjogWzc4NCwgLTEwNV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDJfMTogeyB1c2U6IHRydWUsIGNvb3I6IFs4NzcsIC0xMDVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0Ml8xOiB7IHVzZTogdHJ1ZSwgY29vcjogWzEwNzQsIC0xMDVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgaW5wdXQzXzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTE0NywgLTEwNV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDNfMjogeyB1c2U6IHRydWUsIGNvb3I6IFsxMTU3LCAtNThdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0M18xOiB7IHVzZTogdHJ1ZSwgY29vcjogWzExODksIC0xMjJdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgaW5wdXQ1XzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTM2NSwgMTExXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHB1dDVfMTogeyB1c2U6IHRydWUsIGNvb3I6IFsxMzMwLCA1Nl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDZfMTogeyB1c2U6IHRydWUsIGNvb3I6IFsxMjU3LCAtMTIyXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGlucHV0Nl8yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzEzMzAsIC01OF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQ2XzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTI1NywgLTEwMV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQ2XzI6IHsgdXNlOiB0cnVlLCBjb29yOiBbMTI1NywgLTcwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGlucHV0N18xOiB7IHVzZTogdHJ1ZSwgY29vcjogWzYxMCwgMTEwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGlucHV0N18yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzExODMsIDEwNV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQ3XzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNjEwLCAxMjldLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0N18yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzkzOSwgMTc4XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHB1dDdfMzogeyB1c2U6IHRydWUsIGNvb3I6IFs5NzUsIDE3OF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDEzXzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNjE1LCA3NDFdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgaW5wdXQxM18yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzc1MCwgODc1XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHB1dDEzXzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNjMyLCA2NzZdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTNfMjogeyB1c2U6IHRydWUsIGNvb3I6IFs2NjUsIDY3Nl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQxM18zOiB7IHVzZTogdHJ1ZSwgY29vcjogWzY5OSwgNjc2XSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHB1dDEzXzQ6IHsgdXNlOiB0cnVlLCBjb29yOiBbNzMxLCA2NzZdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTNfNTogeyB1c2U6IHRydWUsIGNvb3I6IFs3NjMsIDY3Nl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDE1XzE6IHsgdXNlOiB0cnVlLCBjb29yOiBbNzk1LCAzNzBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTVfMTogeyB1c2U6IHRydWUsIGNvb3I6IFs4MzMsIDM3MF0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQxNV8yOiB7IHVzZTogdHJ1ZSwgY29vcjogWzg1NywgMzgwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIG91dHB1dDE1XzM6IHsgdXNlOiB0cnVlLCBjb29yOiBbODU3LCA0NTBdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTVfNDogeyB1c2U6IHRydWUsIGNvb3I6IFs4NTcsIDUxOV0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBvdXRwdXQxNV81OiB7IHVzZTogdHJ1ZSwgY29vcjogWzgyOCwgNjAwXSwgc3BlZWQ6IG51bGwsIHRlbXBlcmF0dXJlOiBudWxsLCBwcmVzc3VyZTogbnVsbCB9LFxyXG4gIGlucHV0MTdfMTogeyB1c2U6IHRydWUsIGNvb3I6IFs4MjgsIDY3Nl0sIHNwZWVkOiBudWxsLCB0ZW1wZXJhdHVyZTogbnVsbCwgcHJlc3N1cmU6IG51bGwgfSxcclxuICBpbnB1dDE3XzI6IHsgdXNlOiB0cnVlLCBjb29yOiBbOTQ1LCA2NzZdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTdfMTogeyB1c2U6IHRydWUsIGNvb3I6IFsxMDAwLCA4NzVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbiAgb3V0cHV0MTdfMjogeyB1c2U6IHRydWUsIGNvb3I6IFsxMTAwLCA4NzVdLCBzcGVlZDogbnVsbCwgdGVtcGVyYXR1cmU6IG51bGwsIHByZXNzdXJlOiBudWxsIH0sXHJcbn07XHJcblxyXG5jb25zdCBub2RlcyA9IFtcclxuICBbcGlwZVZlcnRleERhdGEuajEuY29vci5zbGljZSgwKVswXSwgLTUwLCAwXSxcclxuICBbcGlwZVZlcnRleERhdGEuajYuY29vci5zbGljZSgwKVswXSwgLTUwLCAwXSxcclxuICBbcGlwZVZlcnRleERhdGEuajkuY29vci5zbGljZSgwKVswXSwgLTcwLCAwXSxcclxuICBbcGlwZVZlcnRleERhdGEuajMwLmNvb3Iuc2xpY2UoMClbMF0sIDQ4NSwgMF0sXHJcbiAgW3BpcGVWZXJ0ZXhEYXRhLmoyMS5jb29yLnNsaWNlKDApWzBdLCA0MjUsIDBdLFxyXG4gIFtwaXBlVmVydGV4RGF0YS5qMjYuY29vci5zbGljZSgwKVswXSwgMTYwLCAwXSxcclxuXHJcbiAgWzcwMCwgcGlwZVZlcnRleERhdGEuajE4LmNvb3Iuc2xpY2UoMClbMV0sIDFdLFxyXG4gIFtwaXBlVmVydGV4RGF0YS5qMS5jb29yLnNsaWNlKDApWzBdLCA0NTAsIDJdLFxyXG4gIFtwaXBlVmVydGV4RGF0YS5qMS5jb29yLnNsaWNlKDApWzBdLCAzNTAsIDNdLFxyXG5dO1xyXG5cclxuZXhwb3J0IHsgcGlwZVZlcnRleERhdGEsIG5vZGVzIH07XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIl9fd2VicGFja19yZXF1aXJlX18uYiA9IGRvY3VtZW50LmJhc2VVUkkgfHwgc2VsZi5sb2NhdGlvbi5ocmVmO1xuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiaW1wb3J0ICogYXMgenJlbmRlciBmcm9tIFwienJlbmRlclwiO1xyXG5pbXBvcnQgeyBwaXBlVmVydGV4RGF0YSB9IGZyb20gXCIuL3BpcGVWZXJ0ZXhEYXRhXCI7XHJcbmltcG9ydCB7IHBpcGVEYXRhX29yaWdpbiB9IGZyb20gXCIuL3BpcGVEYXRhXCI7XHJcbmltcG9ydCB7IGJsb2NrRGF0YV9maXQsIHBpcGVzX25vRGF0YV9kcmF3RGF0YSwgcGlwZXNfbm9EYXRhX2RyYXdEYXRhX29yaWdpbiB9IGZyb20gXCIuL2Nvb3JNYXBcIjtcclxuaW1wb3J0IHsgbGluZWFySW50ZXJwb2xhdGlvbiB9IGZyb20gXCIuL21hdGhVdGlsXCI7XHJcbmltcG9ydCBub2RlX3BpcGVfbWFwIGZyb20gXCIuL25vZGVfcGlwZV9tYXAuanNvblwiO1xyXG5pbXBvcnQgb3V0cHV0IGZyb20gXCIuL291dHB1dC5qc29uXCI7XHJcbmltcG9ydCBcIi4vc3R5bGUuY3NzXCI7XHJcblxyXG5jb25zb2xlLmxvZyh6cmVuZGVyKTtcclxuXHJcbmNvbnN0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21haW5cIik7XHJcbmNvbnN0IG1hZ25pZmllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFnbmlmaWVyXCIpO1xyXG5jb25zdCB6ciA9IHpyZW5kZXIuaW5pdChtYWluKTtcclxuXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gKiogdG9vbFRpcC5qc1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vICDmsLTmsaDmj5DnpLrmoYblkoznrqHpgZPmj5DnpLrmoYZcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyDmsLTmsaDmj5DnpLrmoYZcclxuY2xhc3MgYmxvY2tJbmZvVG9vbHRpcCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmluZm9CbG9jayA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMjAwLFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIHI6IFsxMF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgZmlsbDogXCIjMDAwXCIsXHJcbiAgICAgICAgc2hhZG93Qmx1cjogMCxcclxuICAgICAgICBzaGFkb3dDb2xvcjogXCIjMDAwXCIsXHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgfSxcclxuICAgICAgemxldmVsOiAzLFxyXG4gICAgICBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHpyLmFkZCh0aGlzLmluZm9CbG9jayk7XHJcblxyXG4gICAgLy8g5qCH6aKYXHJcbiAgICB0aGlzLnRpdGxlID0gbmV3IHpyZW5kZXIuUmVjdCh7XHJcbiAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCLovabpl7Tkv6Hmga9cIixcclxuICAgICAgICB0ZXh0RmlsbDogXCIjREREXCIsXHJcbiAgICAgICAgZm9udDogXCIxNnB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB9LFxyXG4gICAgICB6bGV2ZWw6IDMsXHJcbiAgICAgIHNpbGVudDogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgenIuYWRkKHRoaXMudGl0bGUpO1xyXG4gIH1cclxuICBkaXNwbGF5KHgsIHksIHdhdGVySGVpZ2h0KSB7XHJcbiAgICB0aGlzLmluZm9CbG9jay5hdHRyKHtcclxuICAgICAgLy8g5pi+56S65o+Q56S65qGGXHJcbiAgICAgIHNoYXBlOiB7IHg6IHggKyA1LCB5OiB5ICsgNSB9LFxyXG4gICAgICBzdHlsZTogeyBvcGFjaXR5OiAwLjcgfSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy50aXRsZS5hdHRyKHtcclxuICAgICAgLy8g5pi+56S65o+Q56S65qGG5qCH6aKYXHJcbiAgICAgIHNoYXBlOiB7IHg6IHggKyA1LCB5OiB5ICsgMjEgfSxcclxuICAgICAgc3R5bGU6IHsgb3BhY2l0eTogMSB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHZhbmlzaCgpIHtcclxuICAgIHRoaXMuaW5mb0Jsb2NrLmF0dHIoeyBzdHlsZTogeyBvcGFjaXR5OiAwIH0gfSk7XHJcbiAgICB0aGlzLnRpdGxlLmF0dHIoeyBzdHlsZTogeyBvcGFjaXR5OiAwIH0gfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyDnrqHpgZPmj5DnpLrmoYZcclxuY2xhc3MgcGlwZUluZm9Ub29sVGlwIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuaW5mb0Jsb2NrID0gbmV3IHpyZW5kZXIuUmVjdCh7XHJcbiAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMDAsXHJcbiAgICAgICAgcjogWzEwXSxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcIiMwMDBcIixcclxuICAgICAgICBzaGFkb3dCbHVyOiAwLFxyXG4gICAgICAgIHNoYWRvd0NvbG9yOiBcIiMwMDBcIixcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB9LFxyXG4gICAgICB6bGV2ZWw6IDMsXHJcbiAgICAgIHNpbGVudDogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgenIuYWRkKHRoaXMuaW5mb0Jsb2NrKTtcclxuXHJcbiAgICAvLyDmoIfpophcclxuICAgIHRoaXMudGl0bGUgPSBuZXcgenJlbmRlci5SZWN0KHtcclxuICAgICAgc2hhcGU6IHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZToge1xyXG4gICAgICAgIGZpbGw6IFwidHJhbnNwYXJlbnRcIixcclxuICAgICAgICB0ZXh0OiBcIueuoemBk+S/oeaBr1wiLFxyXG4gICAgICAgIHRleHRGaWxsOiBcIiNERERcIixcclxuICAgICAgICBmb250OiBcIjE2cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHpsZXZlbDogMyxcclxuICAgICAgc2lsZW50OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB6ci5hZGQodGhpcy50aXRsZSk7XHJcblxyXG4gICAgLy8g5rWB6YCf5Zu+5qCHXHJcbiAgICB0aGlzLnZlbG9jaXR5X2ljb24gPSBuZXcgenJlbmRlci5JbWFnZSh7XHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAzNSxcclxuICAgICAgICBoZWlnaHQ6IDM1LFxyXG4gICAgICAgIGltYWdlOiBcIi4vaWNvbnMvdmVsb2NpdHkucG5nXCIsXHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgfSxcclxuICAgICAgemxldmVsOiAzLFxyXG4gICAgICBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHpyLmFkZCh0aGlzLnZlbG9jaXR5X2ljb24pO1xyXG5cclxuICAgIC8vIOa1gemAn+agh+etvlxyXG4gICAgdGhpcy52ZWxvY2l0eV9sYWJlbCA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCLmtYHpgJ/vvJpcIixcclxuICAgICAgICB0ZXh0RmlsbDogXCIjMjU5RERFXCIsXHJcbiAgICAgICAgZm9udDogXCIxNHB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB9LFxyXG4gICAgICB6bGV2ZWw6IDMsXHJcbiAgICAgIHNpbGVudDogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgenIuYWRkKHRoaXMudmVsb2NpdHlfbGFiZWwpO1xyXG5cclxuICAgIC8vIOa1gemAn+aVsOWAvFxyXG4gICAgdGhpcy52ZWxvY2l0eV92YWx1ZSA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCJudWxsXCIsXHJcbiAgICAgICAgdGV4dEZpbGw6IFwiI0RERFwiLFxyXG4gICAgICAgIGZvbnQ6IFwiMTRweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgICAgICB0ZXh0QWxpZ246IFwibGVmdFwiLFxyXG4gICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHpsZXZlbDogMyxcclxuICAgICAgc2lsZW50OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB6ci5hZGQodGhpcy52ZWxvY2l0eV92YWx1ZSk7XHJcblxyXG4gICAgLy8g5rip5bqm5Zu+5qCHXHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlX2ljb24gPSBuZXcgenJlbmRlci5JbWFnZSh7XHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAzNSxcclxuICAgICAgICBoZWlnaHQ6IDM1LFxyXG4gICAgICAgIGltYWdlOiBcIi4vaWNvbnMvdGVtcGVyYXR1cmUucG5nXCIsXHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgfSxcclxuICAgICAgemxldmVsOiAzLFxyXG4gICAgICBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHpyLmFkZCh0aGlzLnRlbXBlcmF0dXJlX2ljb24pO1xyXG5cclxuICAgIC8vIOa4qeW6puagh+etvlxyXG4gICAgdGhpcy50ZW1wZXJhdHVyZV9sYWJlbCA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCLmuKnluqbvvJpcIixcclxuICAgICAgICB0ZXh0RmlsbDogXCIjRjg3MTE1XCIsXHJcbiAgICAgICAgZm9udDogXCIxNHB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB9LFxyXG4gICAgICB6bGV2ZWw6IDMsXHJcbiAgICAgIHNpbGVudDogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgenIuYWRkKHRoaXMudGVtcGVyYXR1cmVfbGFiZWwpO1xyXG5cclxuICAgIC8vIOa4qeW6puaVsOWAvFxyXG4gICAgdGhpcy50ZW1wZXJhdHVyZV92YWx1ZSA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCJudWxsXCIsXHJcbiAgICAgICAgdGV4dEZpbGw6IFwiI0RERFwiLFxyXG4gICAgICAgIGZvbnQ6IFwiMTRweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgICAgICB0ZXh0QWxpZ246IFwibGVmdFwiLFxyXG4gICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHpsZXZlbDogMyxcclxuICAgICAgc2lsZW50OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB6ci5hZGQodGhpcy50ZW1wZXJhdHVyZV92YWx1ZSk7XHJcblxyXG4gICAgLy8g5Y6L5Yqb5Zu+5qCHXHJcbiAgICB0aGlzLnByZXNzdXJlX2ljb24gPSBuZXcgenJlbmRlci5JbWFnZSh7XHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAzNSxcclxuICAgICAgICBoZWlnaHQ6IDM1LFxyXG4gICAgICAgIGltYWdlOiBcIi4vaWNvbnMvcHJlc3N1cmUucG5nXCIsXHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgfSxcclxuICAgICAgemxldmVsOiAzLFxyXG4gICAgICBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHpyLmFkZCh0aGlzLnByZXNzdXJlX2ljb24pO1xyXG5cclxuICAgIC8vIOWOi+WKm+agh+etvlxyXG4gICAgdGhpcy5wcmVzc3VyZV9sYWJlbCA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCLljovlipvvvJpcIixcclxuICAgICAgICB0ZXh0RmlsbDogXCIjMkVFOEI2XCIsXHJcbiAgICAgICAgZm9udDogXCIxNHB4IE1pY3Jvc29mdCBZYUhlaVwiLFxyXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB9LFxyXG4gICAgICB6bGV2ZWw6IDMsXHJcbiAgICAgIHNpbGVudDogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgenIuYWRkKHRoaXMucHJlc3N1cmVfbGFiZWwpO1xyXG5cclxuICAgIC8vIOWOi+WKm+aVsOWAvFxyXG4gICAgdGhpcy5wcmVzc3VyZV92YWx1ZSA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gICAgICBzaGFwZToge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgdGV4dDogXCJudWxsXCIsXHJcbiAgICAgICAgdGV4dEZpbGw6IFwiI0RERFwiLFxyXG4gICAgICAgIGZvbnQ6IFwiMTRweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgICAgICB0ZXh0QWxpZ246IFwibGVmdFwiLFxyXG4gICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIH0sXHJcbiAgICAgIHpsZXZlbDogMyxcclxuICAgICAgc2lsZW50OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB6ci5hZGQodGhpcy5wcmVzc3VyZV92YWx1ZSk7XHJcbiAgfVxyXG4gIGRpc3BsYXkoeCwgeSwgdmVsb2NpdHksIHRlbXBlcmF0dXJlLCBwcmVzc3VyZSkge1xyXG4gICAgdGhpcy5pbmZvQmxvY2suYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuuaPkOekuuahhlxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgNSwgeTogeSArIDUgfSxcclxuICAgICAgc3R5bGU6IHsgb3BhY2l0eTogMC43IH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMudGl0bGUuYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuuaPkOekuuahhuagh+mimFxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgNSwgeTogeSArIDIxIH0sXHJcbiAgICAgIHN0eWxlOiB7IG9wYWNpdHk6IDEgfSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy52ZWxvY2l0eV9pY29uLmF0dHIoe1xyXG4gICAgICAvLyDmmL7npLrmtYHpgJ/lm77moIdcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICB4OiB4ICsgMjAsXHJcbiAgICAgICAgeTogeSArIDU1LFxyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMudmVsb2NpdHlfbGFiZWwuYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuua1gemAn+agh+etvlxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgNzAsIHk6IHkgKyA2NSB9LFxyXG4gICAgICBzdHlsZTogeyBvcGFjaXR5OiAxIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMudmVsb2NpdHlfdmFsdWUuYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuua1gemAn+aVsOWAvFxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgOTYsIHk6IHkgKyA2NSB9LFxyXG4gICAgICBzdHlsZTogeyB0ZXh0OiB2ZWxvY2l0eSwgb3BhY2l0eTogMSB9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlX2ljb24uYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuua4qeW6puWbvuagh1xyXG4gICAgICBzdHlsZToge1xyXG4gICAgICAgIHg6IHggKyAyMCxcclxuICAgICAgICB5OiB5ICsgMTA1LFxyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMudGVtcGVyYXR1cmVfbGFiZWwuYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuua4qeW6puagh+etvlxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgNzAsIHk6IHkgKyAxMTUgfSxcclxuICAgICAgc3R5bGU6IHsgb3BhY2l0eTogMSB9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlX3ZhbHVlLmF0dHIoe1xyXG4gICAgICAvLyDmmL7npLrmuKnluqbmlbDlgLxcclxuICAgICAgc2hhcGU6IHsgeDogeCArIDk2LCB5OiB5ICsgMTE1IH0sXHJcbiAgICAgIHN0eWxlOiB7IHRleHQ6IHRlbXBlcmF0dXJlLCBvcGFjaXR5OiAxIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMucHJlc3N1cmVfaWNvbi5hdHRyKHtcclxuICAgICAgLy8g5pi+56S65Y6L5Yqb5Zu+5qCHXHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgeDogeCArIDIwLFxyXG4gICAgICAgIHk6IHkgKyAxNTUsXHJcbiAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wcmVzc3VyZV9sYWJlbC5hdHRyKHtcclxuICAgICAgLy8g5pi+56S65Y6L5Yqb5qCH562+XHJcbiAgICAgIHNoYXBlOiB7IHg6IHggKyA3MCwgeTogeSArIDE2NSB9LFxyXG4gICAgICBzdHlsZTogeyBvcGFjaXR5OiAxIH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMucHJlc3N1cmVfdmFsdWUuYXR0cih7XHJcbiAgICAgIC8vIOaYvuekuuWOi+WKm+aVsOWAvFxyXG4gICAgICBzaGFwZTogeyB4OiB4ICsgOTYsIHk6IHkgKyAxNjUgfSxcclxuICAgICAgc3R5bGU6IHsgdGV4dDogcHJlc3N1cmUsIG9wYWNpdHk6IDEgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuICB2YW5pc2goKSB7XHJcbiAgICB0aGlzLmluZm9CbG9jay5hdHRyKHsgc3R5bGU6IHsgb3BhY2l0eTogMCB9IH0pO1xyXG4gICAgdGhpcy50aXRsZS5hdHRyKHsgc3R5bGU6IHsgb3BhY2l0eTogMCB9IH0pO1xyXG4gICAgdGhpcy50ZW1wZXJhdHVyZV9pY29uLmF0dHIoeyBzdHlsZTogeyBvcGFjaXR5OiAwIH0gfSk7XHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlX2xhYmVsLmF0dHIoeyBzdHlsZTogeyBvcGFjaXR5OiAwIH0gfSk7XHJcbiAgICB0aGlzLnRlbXBlcmF0dXJlX3ZhbHVlLmF0dHIoeyBzdHlsZTogeyBvcGFjaXR5OiAwIH0gfSk7XHJcbiAgICB0aGlzLnZlbG9jaXR5X2ljb24uYXR0cih7IHN0eWxlOiB7IG9wYWNpdHk6IDAgfSB9KTtcclxuICAgIHRoaXMudmVsb2NpdHlfbGFiZWwuYXR0cih7IHN0eWxlOiB7IG9wYWNpdHk6IDAgfSB9KTtcclxuICAgIHRoaXMudmVsb2NpdHlfdmFsdWUuYXR0cih7IHN0eWxlOiB7IG9wYWNpdHk6IDAgfSB9KTtcclxuICAgIHRoaXMucHJlc3N1cmVfaWNvbi5hdHRyKHsgc3R5bGU6IHsgb3BhY2l0eTogMCB9IH0pO1xyXG4gICAgdGhpcy5wcmVzc3VyZV9sYWJlbC5hdHRyKHsgc3R5bGU6IHsgb3BhY2l0eTogMCB9IH0pO1xyXG4gICAgdGhpcy5wcmVzc3VyZV92YWx1ZS5hdHRyKHsgc3R5bGU6IHsgb3BhY2l0eTogMCB9IH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyAqKiBkcmF3LmpzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gICAg5a6e6ZmF57uY5Yi277yI5qCH6aKY5ZKM566h572R77yJ5Lul5Y+K5o+Q56S65qGG55qE5Lqk5LqSXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxubGV0IHBpcGVJbmZvQmxvY2sgPSBuZXcgcGlwZUluZm9Ub29sVGlwKCk7IC8vIOeuoemBk+aPkOekuuahhlxyXG5sZXQgYmxvY2tJbmZvQmxvY2sgPSBuZXcgYmxvY2tJbmZvVG9vbHRpcCgpOyAvLyDmsLTmsaDmj5DnpLrmoYZcclxuXHJcbmxldCBwaXBlX2RyYXdEYXRhID0gbmV3IEFycmF5KHBpcGVEYXRhX29yaWdpbi5sZW5ndGgpO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVfZHJhd0RhdGEubGVuZ3RoOyBpKyspIHtcclxuICBwaXBlX2RyYXdEYXRhW2ldID0gbmV3IEFycmF5KHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICBwaXBlX2RyYXdEYXRhW2ldW2pdID0gcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW2pdLmNvb3Iuc2xpY2UoMCk7XHJcbiAgfVxyXG59XHJcbi8vIOWOn+Wni+aVsOaNrua3seaLt+i0nVxyXG5sZXQgcGlwZV9kcmF3RGF0YV9vcmlnaW4gPSBuZXcgQXJyYXkocGlwZV9kcmF3RGF0YS5sZW5ndGgpO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVfZHJhd0RhdGFfb3JpZ2luLmxlbmd0aDsgaSsrKSB7XHJcbiAgcGlwZV9kcmF3RGF0YV9vcmlnaW5baV0gPSBuZXcgQXJyYXkocGlwZV9kcmF3RGF0YVtpXS5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZV9kcmF3RGF0YV9vcmlnaW5baV0ubGVuZ3RoOyBqKyspIHtcclxuICAgIHBpcGVfZHJhd0RhdGFfb3JpZ2luW2ldW2pdID0gcGlwZV9kcmF3RGF0YVtpXVtqXS5zbGljZSgwKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIOagh+mimOaWh+Wtl1xyXG4vLyBsZXQgdGl0bGUgPSBuZXcgenJlbmRlci5SZWN0KHtcclxuLy8gICBzaGFwZToge1xyXG4vLyAgICAgeDogMCxcclxuLy8gICAgIHk6IDAsXHJcbi8vICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXHJcbi8vICAgICBoZWlnaHQ6IDEwMCxcclxuLy8gICB9LFxyXG4vLyAgIHN0eWxlOiB7XHJcbi8vICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXHJcbi8vICAgICB0ZXh0OiBcIueuoee9keiuoeeul+S4jumihOitpuezu+e7n1wiLFxyXG4vLyAgICAgLy90ZXh0RmlsbDogJyM3QkZGRjgnLFxyXG4vLyAgICAgdGV4dEZpbGw6IFwiIzczOTRDRlwiLFxyXG4vLyAgICAgZm9udDogXCIzNnB4IExFWFVTIOeugOeyl+m7kSBVXCIsXHJcbi8vICAgICBmb250V2VpZ2h0OiBcImxpZ2h0ZXJcIixcclxuLy8gICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuLy8gICB9LFxyXG4vLyAgIHNpbGVudDogdHJ1ZSxcclxuLy8gfSk7XHJcbi8vIHpyLmFkZCh0aXRsZSk7XHJcblxyXG4vLyDnu5jliLbluKbmlbDmja7nmoTnrqHpgZNcclxubGV0IHBpcGVfbnVtID0gcGlwZV9kcmF3RGF0YS5sZW5ndGg7XHJcbmxldCBwaXBlcyA9IG5ldyBBcnJheShwaXBlX251bSk7IC8vIOS/neWtmOaJgOacieeuoemBk1xyXG5sZXQgcGlwZXNfZmxvdyA9IG5ldyBBcnJheShwaXBlX251bSk7IC8vIOS/neWtmOaJgOacieeuoemBk+eahOa1geWKqOaViOaenFxyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVfbnVtOyBpKyspIHtcclxuICAvLyDnrqHpgZPmnKzkvZNcclxuICBwaXBlc1tpXSA9IG5ldyB6cmVuZGVyLlBvbHlsaW5lKHtcclxuICAgIHNoYXBlOiB7XHJcbiAgICAgIHBvaW50czogcGlwZV9kcmF3RGF0YVtpXSxcclxuICAgIH0sXHJcbiAgICBzdHlsZToge1xyXG4gICAgICBzdHJva2U6IFwiI0ZGMFwiLFxyXG4gICAgICBsaW5lV2lkdGg6IDUsXHJcbiAgICB9LFxyXG4gICAgemxldmVsOiAxLFxyXG4gIH0pO1xyXG4gIHBpcGVzW2ldXHJcbiAgICAub24oXCJtb3VzZW1vdmVcIiwgKGUpID0+IHtcclxuICAgICAgLy8gdG9vbHRpcOS6pOS6klxyXG4gICAgICBwaXBlc1tpXS5hdHRyKHtcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgc2hhZG93Qmx1cjogMTAsXHJcbiAgICAgICAgICBzaGFkb3dDb2xvcjogXCIjRkYwXCIsXHJcbiAgICAgICAgfSwgLy8g566h57q/6auY5Lqu77yI6Zi05b2x77yJXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwaXBlRGF0YV9vcmlnaW5baV0ubmFtZSk7XHJcbiAgICAgIC8vIOiuoeeul+m8oOagh+aMh+WQkeS9jee9rueahOa1gemAn+OAgea4qeW6puOAgeWOi+WKm1xyXG4gICAgICBsZXQgbV9zcGVlZCA9IGxpbmVhckludGVycG9sYXRpb24oXHJcbiAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzWzBdLnNwZWVkLFxyXG4gICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0uc3BlZWQsXHJcbiAgICAgICAgenJlbmRlci52ZWN0b3IuZGlzdGFuY2UoW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSwgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV0pIC9cclxuICAgICAgICAgIHpyZW5kZXIudmVjdG9yLmRpc3RhbmNlKFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlcy5sZW5ndGggLSAxXS5jb29yWzBdLFxyXG4gICAgICAgICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0uY29vclsxXSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV1cclxuICAgICAgICAgIClcclxuICAgICAgKS50b0ZpeGVkKDIpO1xyXG4gICAgICBsZXQgbV90ZW1wZXJhdHVyZSA9IGxpbmVhckludGVycG9sYXRpb24oXHJcbiAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzWzBdLnRlbXBlcmF0dXJlLFxyXG4gICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0udGVtcGVyYXR1cmUsXHJcbiAgICAgICAgenJlbmRlci52ZWN0b3IuZGlzdGFuY2UoW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSwgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV0pIC9cclxuICAgICAgICAgIHpyZW5kZXIudmVjdG9yLmRpc3RhbmNlKFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlcy5sZW5ndGggLSAxXS5jb29yWzBdLFxyXG4gICAgICAgICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0uY29vclsxXSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV1cclxuICAgICAgICAgIClcclxuICAgICAgKS50b0ZpeGVkKDIpO1xyXG4gICAgICBsZXQgbV9wcmVzc3VyZSA9IGxpbmVhckludGVycG9sYXRpb24oXHJcbiAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzWzBdLnByZXNzdXJlLFxyXG4gICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0ucHJlc3N1cmUsXHJcbiAgICAgICAgenJlbmRlci52ZWN0b3IuZGlzdGFuY2UoW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSwgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV0pIC9cclxuICAgICAgICAgIHpyZW5kZXIudmVjdG9yLmRpc3RhbmNlKFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgcGlwZURhdGFfb3JpZ2luW2ldLnZlcnRpY2VzW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlcy5sZW5ndGggLSAxXS5jb29yWzBdLFxyXG4gICAgICAgICAgICAgIHBpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1twaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXMubGVuZ3RoIC0gMV0uY29vclsxXSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW3BpcGVEYXRhX29yaWdpbltpXS52ZXJ0aWNlc1swXS5jb29yWzBdLCBwaXBlRGF0YV9vcmlnaW5baV0udmVydGljZXNbMF0uY29vclsxXV1cclxuICAgICAgICAgIClcclxuICAgICAgKS50b0ZpeGVkKDIpO1xyXG4gICAgICBwaXBlSW5mb0Jsb2NrLmRpc3BsYXkoZS5vZmZzZXRYLCBlLm9mZnNldFksIG1fc3BlZWQgKyBcIiBtL3NcIiwgbV90ZW1wZXJhdHVyZSArIFwiIMKwQ1wiLCBtX3ByZXNzdXJlICsgXCIgS1BhXCIpO1xyXG4gICAgfSlcclxuICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcGlwZXNbaV0uYXR0cih7XHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIHNoYWRvd0JsdXI6IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBpcGVJbmZvQmxvY2sudmFuaXNoKCk7XHJcbiAgICB9KTtcclxuICB6ci5hZGQocGlwZXNbaV0pO1xyXG5cclxuICAvLyDnrqHpgZPmtYHliqhcclxuICBwaXBlc19mbG93W2ldID0gbmV3IHpyZW5kZXIuUG9seWxpbmUoe1xyXG4gICAgc2hhcGU6IHtcclxuICAgICAgcG9pbnRzOiBwaXBlX2RyYXdEYXRhW2ldLFxyXG4gICAgfSxcclxuICAgIHN0eWxlOiB7XHJcbiAgICAgIHN0cm9rZTogXCIjMjgyQzM0XCIsXHJcbiAgICAgIGxpbmVXaWR0aDogMyxcclxuICAgICAgbGluZURhc2g6IFs1LCA1XSxcclxuICAgICAgb3BhY2l0eTogMC43LFxyXG4gICAgfSxcclxuICAgIHpsZXZlbDogMSxcclxuICAgIHNpbGVudDogdHJ1ZSxcclxuICB9KTtcclxuICBwaXBlc19mbG93W2ldXHJcbiAgICAuYW5pbWF0ZShcInN0eWxlXCIsIHRydWUpXHJcbiAgICAud2hlbigxMDAwLCB7XHJcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAtMSAqIDEwLFxyXG4gICAgfSlcclxuICAgIC5kb25lKGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgLnN0YXJ0KCk7XHJcbiAgenIuYWRkKHBpcGVzX2Zsb3dbaV0pO1xyXG59XHJcblxyXG4vLyDnu5jliLbkuI3luKbmlbDmja7nmoTnrqHpgZNcclxubGV0IHBpcGVzX25vRGF0YSA9IEFycmF5KHBpcGVzX25vRGF0YV9kcmF3RGF0YS5sZW5ndGgpO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IHBpcGVzX25vRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gIHBpcGVzX25vRGF0YVtpXSA9IG5ldyB6cmVuZGVyLlBvbHlsaW5lKHtcclxuICAgIHNoYXBlOiB7XHJcbiAgICAgIHBvaW50czogcGlwZXNfbm9EYXRhX2RyYXdEYXRhW2ldLFxyXG4gICAgfSxcclxuICAgIHN0eWxlOiB7XHJcbiAgICAgIHN0cm9rZTogXCIjRkYwXCIsXHJcbiAgICAgIGxpbmVXaWR0aDogNSxcclxuICAgICAgb3BhY2l0eTogMC4zLFxyXG4gICAgfSxcclxuICAgIHpsZXZlbDogMSxcclxuICB9KTtcclxuICB6ci5hZGQocGlwZXNfbm9EYXRhW2ldKTtcclxufVxyXG5sZXQgcGlwZXNfbm9EYXRhX2Zsb3cgPSBBcnJheShwaXBlc19ub0RhdGFfZHJhd0RhdGEubGVuZ3RoKTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCBwaXBlc19ub0RhdGFfZmxvdy5sZW5ndGg7IGkrKykge1xyXG4gIHBpcGVzX25vRGF0YV9mbG93W2ldID0gbmV3IHpyZW5kZXIuUG9seWxpbmUoe1xyXG4gICAgc2hhcGU6IHtcclxuICAgICAgcG9pbnRzOiBwaXBlc19ub0RhdGFfZHJhd0RhdGFbaV0sXHJcbiAgICB9LFxyXG4gICAgc3R5bGU6IHtcclxuICAgICAgc3Ryb2tlOiBcIiMyODJDMzRcIixcclxuICAgICAgbGluZVdpZHRoOiAzLFxyXG4gICAgICBsaW5lRGFzaDogWzUsIDVdLFxyXG4gICAgICBvcGFjaXR5OiAwLjcsXHJcbiAgICB9LFxyXG4gICAgemxldmVsOiAxLFxyXG4gICAgc2lsZW50OiB0cnVlLFxyXG4gIH0pO1xyXG4gIHBpcGVzX25vRGF0YV9mbG93W2ldXHJcbiAgICAuYW5pbWF0ZShcInN0eWxlXCIsIHRydWUpXHJcbiAgICAud2hlbigxMDAwLCB7XHJcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAtMSAqIDEwLFxyXG4gICAgfSlcclxuICAgIC5kb25lKGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgLnN0YXJ0KCk7XHJcbiAgenIuYWRkKHBpcGVzX25vRGF0YV9mbG93W2ldKTtcclxufVxyXG5cclxuLy8g57uY5Yi25rC05rGgXHJcbmxldCBibG9ja19udW0gPSBibG9ja0RhdGFfZml0Lmxlbmd0aDtcclxubGV0IGJsb2Nrc19vdXRlciA9IG5ldyBBcnJheShibG9ja19udW0pO1xyXG5sZXQgYmxvY2tzX2lubmVyID0gbmV3IEFycmF5KGJsb2NrX251bSk7XHJcbmZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tfbnVtOyBpKyspIHtcclxuICAvLyDlpJbmoYZcclxuICBibG9ja3Nfb3V0ZXJbaV0gPSBuZXcgenJlbmRlci5SZWN0KHtcclxuICAgIHNoYXBlOiB7XHJcbiAgICAgIHg6IGJsb2NrRGF0YV9maXRbaV0udmVydGV4MVswXSxcclxuICAgICAgeTogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzFdLFxyXG4gICAgICB3aWR0aDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzBdIC0gYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdLFxyXG4gICAgICBoZWlnaHQ6IGJsb2NrRGF0YV9maXRbaV0udmVydGV4MlsxXSAtIGJsb2NrRGF0YV9maXRbaV0udmVydGV4MVsxXSxcclxuICAgIH0sXHJcbiAgICBzdHlsZToge1xyXG4gICAgICBmaWxsOiBcIiMzQTY2QjZcIixcclxuICAgIH0sXHJcbiAgICB6bGV2ZWw6IDIsXHJcbiAgfSk7XHJcbiAgYmxvY2tzX291dGVyW2ldXHJcbiAgICAub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgYmxvY2tJbmZvQmxvY2suZGlzcGxheShlLm9mZnNldFgsIGUub2Zmc2V0WSwgXCIyNiBrbS9oXCIpO1xyXG4gICAgfSlcclxuICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmxvY2tJbmZvQmxvY2sudmFuaXNoKCk7XHJcbiAgICB9KTtcclxuICB6ci5hZGQoYmxvY2tzX291dGVyW2ldKTtcclxuXHJcbiAgLy8g5YaF5qGGXHJcbiAgYmxvY2tzX2lubmVyW2ldID0gbmV3IHpyZW5kZXIuUmVjdCh7XHJcbiAgICBzaGFwZToge1xyXG4gICAgICB4OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMF0gKyA0LFxyXG4gICAgICB5OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0gKyA0LFxyXG4gICAgICB3aWR0aDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzBdIC0gYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdIC0gOCxcclxuICAgICAgaGVpZ2h0OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDJbMV0gLSBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0gLSA4LFxyXG4gICAgfSxcclxuICAgIHN0eWxlOiB7XHJcbiAgICAgIC8vZmlsbDogJyMyODJjMzQnLFxyXG4gICAgICBmaWxsOiBcIiMxQTJFNTFcIixcclxuICAgICAgdGV4dDogYmxvY2tEYXRhX2ZpdFtpXS5uYW1lLFxyXG4gICAgICB0ZXh0RmlsbDogXCIjN2JmZmY4XCIsXHJcbiAgICAgIGZvbnQ6IGJsb2NrRGF0YV9maXRbaV0uZm9udCxcclxuICAgIH0sXHJcbiAgICB6bGV2ZWw6IDIsXHJcbiAgfSk7XHJcbiAgYmxvY2tzX2lubmVyW2ldXHJcbiAgICAub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgYmxvY2tJbmZvQmxvY2suZGlzcGxheShlLm9mZnNldFgsIGUub2Zmc2V0WSwgXCIyNiBrbS9oXCIpO1xyXG4gICAgfSlcclxuICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmxvY2tJbmZvQmxvY2sudmFuaXNoKCk7XHJcbiAgICB9KTtcclxuICB6ci5hZGQoYmxvY2tzX2lubmVyW2ldKTtcclxufVxyXG5cclxuLy8g5pyA5ZCO5Yqg5LiK6Iqx6YeM6IOh5ZOo55qE6IqC54K5XHJcbi8qXHJcbmxldCBmbG93ZXJOb2RlcyA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xyXG5jb25zdCBkcmF3Tm9kZV9ob3VyZ2xhc3MgPSBmdW5jdGlvbiAoenIsIHgsIHksIGRpcmVjKSB7XHJcbiAgICBsZXQgaG91cmdsYXNzID0gbmV3IHpyZW5kZXIuUG9seWxpbmUoe1xyXG4gICAgICAgIHN0eWxlOiB7c3Ryb2tlOiAnIzBDQycsIGxpbmVXaWR0aDogMn0sXHJcbiAgICAgICAgemxldmVsOiAyLCBzaWxlbnQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHN3aXRjaCAoZGlyZWMpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIGhvdXJnbGFzcy5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4IC0gNSwgeSAtIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCArIDUsIHkgLSA1XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggLSA1LCB5ICsgNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgNSwgeSArIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCAtIDUsIHkgLSA1XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggKyA1LCB5IC0gNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgaG91cmdsYXNzLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggKyA1LCB5IC0gNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4IC0gNSwgeSArIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCAtIDUsIHkgLSA1XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggKyA1LCB5ICsgNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgNSwgeSAtIDVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCAtIDUsIHkgKyA1XSxcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBob3VyZ2xhc3MuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCwgeSAtIDhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCArIDYsIHkgKyA0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggLSA2LCB5ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4LCB5IC0gOF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgaG91cmdsYXNzID0gbmV3IHpyZW5kZXIuR3JvdXAoKTtcclxuICAgICAgICAgICAgbGV0IHRtcFJjdDEgPSBuZXcgenJlbmRlci5SZWN0KHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7eDogeCAtIDEwLCB5OiB5IC0gMjgsIHdpZHRoOiAyMCwgaGVpZ2h0OiA1Nn0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge3N0cm9rZTogJyMwQ0MnLCBsaW5lV2lkdGg6IDIsIGZpbGw6ICd0cmFuc3BhcmVudCd9LFxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAyLCBzaWxlbnQ6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCB0bXBSY3QyID0gbmV3IHpyZW5kZXIuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge3g6IHggLSA2LCB5OiB5IC0gMjIsIHdpZHRoOiAxMiwgaGVpZ2h0OiA0NX0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge3N0cm9rZTogJyMwQ0MnLCBsaW5lV2lkdGg6IDIsIGZpbGw6ICd0cmFuc3BhcmVudCd9LFxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAyLCBzaWxlbnQ6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCB0bXBQb2x5bGluZSA9IG5ldyB6cmVuZGVyLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7cG9pbnRzOiBbW3ggLSA2LCB5IC0gMjJdLCBbeCArIDYsIHkgLSAxMl0sIFt4IC0gNiwgeSAtIDJdLCBbeCArIDYsIHkgKyA2XSwgW3ggLSA2LCB5ICsgMThdLCBbeCwgeSArIDIzXSwgXX0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge3N0cm9rZTogJyMwQ0MnLCBsaW5lV2lkdGg6IDJ9LFxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAyLCBzaWxlbnQ6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhvdXJnbGFzcy5hZGQodG1wUmN0MSk7XHJcbiAgICAgICAgICAgIGhvdXJnbGFzcy5hZGQodG1wUmN0Mik7XHJcbiAgICAgICAgICAgIGhvdXJnbGFzcy5hZGQodG1wUG9seWxpbmUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHpyLmFkZChob3VyZ2xhc3MpO1xyXG4gICAgcmV0dXJuIGhvdXJnbGFzcztcclxufVxyXG5cclxuZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgZmxvd2VyTm9kZXNbaV0gPSBkcmF3Tm9kZV9ob3VyZ2xhc3MoenIsIG5vZGVzW2ldWzBdLCBub2Rlc1tpXVsxXSwgbm9kZXNbaV1bMl0pO1xyXG59XHJcbiovXHJcblxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vICoqIG1hZ25pZnkuanNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgICDmoYbpgInmlL7lpKfjgIHnp7vliqjnmoTop4blm77mk43kvZxcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5sZXQgbWFnbmlmeSA9IDE7IC8vIOe8qeaUvuWAjeaVsFxyXG5sZXQgdG90YWxNYWduaWZ5ID0gMTtcclxubGV0IG1hZ25pZnlNb2RlID0gZmFsc2U7IC8vIOahhumAieaUvuWkp+aooeW8j1xyXG5sZXQgaGF2ZV9leGVjX21hZyA9IGZhbHNlOyAvLyDmoIforrDmmK/lkKblt7Lnu4/miafooYzov4fmoYbpgInmlL7lpKdcclxubGV0IG1hZ25pZnlfbWF4ID0gNixcclxuICBtYWduaWZ5X21pbiA9IDAuNTtcclxuXHJcbm1hZ25pZmllci5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghbWFnbmlmeU1vZGUpIHtcclxuICAgIG1hZ25pZnlNb2RlID0gdHJ1ZTsgLy8g5pS+5aSn5qih5byPXHJcbiAgICBtYWduaWZpZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi9pY29ucy9yZXNldC5wbmcpXCI7XHJcbiAgICBoYXZlX2V4ZWNfbWFnID0gZmFsc2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIG1hZ25pZnlNb2RlID0gZmFsc2U7XHJcbiAgICBtYWduaWZpZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi9pY29ucy9tYWduaWZpZXIucG5nKVwiO1xyXG5cclxuICAgIHRvdGFsTWFnbmlmeSA9IDE7XHJcbiAgICAvLyDov5jljp/mlrnlnZdcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tfbnVtOyBpKyspIHtcclxuICAgICAgYmxvY2tzX291dGVyW2ldLmF0dHIoe1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICB4OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMF0sXHJcbiAgICAgICAgICB5OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0sXHJcbiAgICAgICAgICB3aWR0aDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzBdIC0gYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdLFxyXG4gICAgICAgICAgaGVpZ2h0OiBibG9ja0RhdGFfZml0W2ldLnZlcnRleDJbMV0gLSBibG9ja0RhdGFfZml0W2ldLnZlcnRleDFbMV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIGJsb2Nrc19pbm5lcltpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgeDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdICsgNCxcclxuICAgICAgICAgIHk6IGJsb2NrRGF0YV9maXRbaV0udmVydGV4MVsxXSArIDQsXHJcbiAgICAgICAgICB3aWR0aDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzBdIC0gYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzBdIC0gOCxcclxuICAgICAgICAgIGhlaWdodDogYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgyWzFdIC0gYmxvY2tEYXRhX2ZpdFtpXS52ZXJ0ZXgxWzFdIC0gOCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBmb250OiBibG9ja0RhdGFfZml0W2ldLmZvbnQsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyDov5jljp/nrqHpgZNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZV9udW07IGkrKykge1xyXG4gICAgICAvLyDmr4/mnaHnrqHpgZNcclxuICAgICAgcGlwZXNbaV0uYXR0cih7XHJcbiAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBwaXBlX2RyYXdEYXRhX29yaWdpbltpXSB9LFxyXG4gICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogNSB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcGlwZXNfZmxvd1tpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZTogeyBwb2ludHM6IHBpcGVfZHJhd0RhdGFfb3JpZ2luW2ldIH0sXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIGxpbmVXaWR0aDogMyxcclxuICAgICAgICAgIGxpbmVEYXNoOiBbNSwgNV0sXHJcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcGlwZXNfZmxvd1tpXVxyXG4gICAgICAgIC5hbmltYXRlKFwic3R5bGVcIiwgdHJ1ZSlcclxuICAgICAgICAud2hlbigxMDAwLCB7IGxpbmVEYXNoT2Zmc2V0OiAtMSAqIDEwIH0pXHJcbiAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICAvLyDov5jljp/kuI3luKbmlbDmja7nmoTnrqHpgZNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZXNfbm9EYXRhX2Zsb3cubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcGlwZXNfbm9EYXRhW2ldLmF0dHIoe1xyXG4gICAgICAgIHNoYXBlOiB7IHBvaW50czogcGlwZXNfbm9EYXRhX2RyYXdEYXRhX29yaWdpbltpXSB9LFxyXG4gICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogNSB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcGlwZXNfbm9EYXRhX2Zsb3dbaV0uYXR0cih7XHJcbiAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBwaXBlc19ub0RhdGFfZHJhd0RhdGFfb3JpZ2luW2ldIH0sXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIGxpbmVXaWR0aDogMyxcclxuICAgICAgICAgIGxpbmVEYXNoOiBbNSwgNV0sXHJcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcGlwZXNfbm9EYXRhX2Zsb3dbaV1cclxuICAgICAgICAuYW5pbWF0ZShcInN0eWxlXCIsIHRydWUpXHJcbiAgICAgICAgLndoZW4oMTAwMCwgeyBsaW5lRGFzaE9mZnNldDogLTEgKiAxMCB9KVxyXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgICAgIC5zdGFydCgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmxldCBzZWxlY3RGcmFtZSA9IG5ldyB6cmVuZGVyLlJlY3Qoe1xyXG4gIC8vIOmAieahhlxyXG4gIHNoYXBlOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcclxuICBzdHlsZTogeyBmaWxsOiBcIiMwMDBcIiwgb3BhY2l0eTogMC40LCBsaW5lV2lkdGg6IDEsIHN0cm9rZTogXCIjRkZGXCIsIGxpbmVEYXNoOiBbNV0gfSxcclxuICB6bGV2ZWw6IDEwLFxyXG59KTtcclxuXHJcbi8vIOW8gOWni+m8oOagh+ahhumAiVxyXG5sZXQgc3RhcnRTZWxlY3QgPSBmYWxzZTtcclxubGV0IHN0YXJ0WCwgc3RhcnRZLCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodDsgLy8g6YCJ5qGG6LW35aeL5L2N572u5LiO5a696auYXHJcbm1haW4ub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xyXG4gIGlmIChtYWduaWZ5TW9kZSkge1xyXG4gICAgaWYgKGhhdmVfZXhlY19tYWcpIHtcclxuICAgICAgbW91c2VEcmFnID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0U2VsZWN0ID0gdHJ1ZTtcclxuICAgICAgenIuYWRkKHNlbGVjdEZyYW1lKTtcclxuICAgICAgc3RhcnRYID0gZS5jbGllbnRYO1xyXG4gICAgICBzdGFydFkgPSBlLmNsaWVudFk7XHJcbiAgICAgIHNlbGVjdEZyYW1lLmF0dHIoeyBzaGFwZTogeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IDAsIGhlaWdodDogMCB9IH0pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxubWFpbi5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgaWYgKCFoYXZlX2V4ZWNfbWFnICYmIHN0YXJ0U2VsZWN0KSBzZWxlY3RGcmFtZS5hdHRyKHsgc2hhcGU6IHsgd2lkdGg6IGUuY2xpZW50WCAtIHN0YXJ0WCwgaGVpZ2h0OiBlLmNsaWVudFkgLSBzdGFydFkgfSB9KTtcclxuICBpZiAobW91c2VEcmFnKSB7XHJcbiAgICAvLyDmm7TmlrDmsLTmsaBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tfbnVtOyBpKyspIHtcclxuICAgICAgYmxvY2tzX291dGVyW2ldLmF0dHIoe1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICB4OiBibG9ja3Nfb3V0ZXJbaV0uc2hhcGUueCArIGUubW92ZW1lbnRYLFxyXG4gICAgICAgICAgeTogYmxvY2tzX291dGVyW2ldLnNoYXBlLnkgKyBlLm1vdmVtZW50WSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgYmxvY2tzX2lubmVyW2ldLmF0dHIoe1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICB4OiBibG9ja3NfaW5uZXJbaV0uc2hhcGUueCArIGUubW92ZW1lbnRYLFxyXG4gICAgICAgICAgeTogYmxvY2tzX2lubmVyW2ldLnNoYXBlLnkgKyBlLm1vdmVtZW50WSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIOabtOaWsOeuoemBk1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXBlX251bTsgaSsrKSB7XHJcbiAgICAgIC8vIOavj+adoeeuoemBk1xyXG4gICAgICBsZXQgcGlwZU5ld0Nvb3JzID0gbmV3IEFycmF5KHBpcGVzW2ldLnNoYXBlLnBvaW50cy5sZW5ndGgpOyAvLyDmmK/kuIDkuKpuLWJ5LTLnmoTmlbDnu4TvvIznlKjkuo7kuLTml7bkv53lrZjmlrDnmoTmipjnur/lnZDmoIdcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwaXBlc1tpXS5zaGFwZS5wb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBwaXBlTmV3Q29vcnNbal0gPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzW2pdWzBdID0gcGlwZXNbaV0uc2hhcGUucG9pbnRzW2pdWzBdICsgZS5tb3ZlbWVudFg7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzW2pdWzFdID0gcGlwZXNbaV0uc2hhcGUucG9pbnRzW2pdWzFdICsgZS5tb3ZlbWVudFk7XHJcbiAgICAgIH1cclxuICAgICAgcGlwZXNbaV0uYXR0cih7IHNoYXBlOiB7IHBvaW50czogcGlwZU5ld0Nvb3JzIH0gfSk7XHJcbiAgICAgIHBpcGVzX2Zsb3dbaV0uYXR0cih7IHNoYXBlOiB7IHBvaW50czogcGlwZU5ld0Nvb3JzIH0gfSk7XHJcbiAgICB9XHJcbiAgICAvLyDmm7TmlrDml6DmlbDmja7nmoTnrqHpgZNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZXNfbm9EYXRhX2RyYXdEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBwaXBlTmV3Q29vcnNfbm9EYXRhID0gbmV3IEFycmF5KHBpcGVzX25vRGF0YVtpXS5zaGFwZS5wb2ludHMubGVuZ3RoKTsgLy8g5piv5LiA5Liqbi1ieS0y55qE5pWw57uE77yM55So5LqO5Li05pe25L+d5a2Y5paw55qE5oqY57q/5Z2Q5qCHXHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHBpcGVOZXdDb29yc19ub0RhdGFbal0gPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzX25vRGF0YVtqXVswXSA9IHBpcGVzX25vRGF0YVtpXS5zaGFwZS5wb2ludHNbal1bMF0gKyBlLm1vdmVtZW50WDtcclxuICAgICAgICBwaXBlTmV3Q29vcnNfbm9EYXRhW2pdWzFdID0gcGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50c1tqXVsxXSArIGUubW92ZW1lbnRZO1xyXG4gICAgICB9XHJcbiAgICAgIHBpcGVzX25vRGF0YVtpXS5hdHRyKHsgc2hhcGU6IHsgcG9pbnRzOiBwaXBlTmV3Q29vcnNfbm9EYXRhIH0gfSk7XHJcbiAgICAgIHBpcGVzX25vRGF0YV9mbG93W2ldLmF0dHIoeyBzaGFwZTogeyBwb2ludHM6IHBpcGVOZXdDb29yc19ub0RhdGEgfSB9KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbm1haW4ub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcclxuICAvLyDmoYbpgInlrozmr5VcclxuICBpZiAobWFnbmlmeU1vZGUpXHJcbiAgICBpZiAoaGF2ZV9leGVjX21hZykge1xyXG4gICAgICBtb3VzZURyYWcgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhhdmVfZXhlY19tYWcgPSB0cnVlO1xyXG4gICAgICBzdGFydFNlbGVjdCA9IGZhbHNlO1xyXG4gICAgICBzdGFydFggPSBzZWxlY3RGcmFtZS5zaGFwZS54O1xyXG4gICAgICBzdGFydFkgPSBzZWxlY3RGcmFtZS5zaGFwZS55O1xyXG4gICAgICBmcmFtZVdpZHRoID0gTWF0aC5hYnMoc2VsZWN0RnJhbWUuc2hhcGUud2lkdGgpO1xyXG4gICAgICBmcmFtZUhlaWdodCA9IChmcmFtZVdpZHRoICogd2luZG93LmlubmVySGVpZ2h0KSAvIHdpbmRvdy5pbm5lcldpZHRoOyAvLyDojrflj5bpgInmoYbmnIDnu4jlrr3pq5hcclxuICAgICAgenIucmVtb3ZlKHNlbGVjdEZyYW1lKTsgLy8g56e76Zmk6YCJ5qGGXHJcbiAgICAgIHRvdGFsTWFnbmlmeSA9IHdpbmRvdy5pbm5lcldpZHRoIC8gZnJhbWVXaWR0aCA+IG1hZ25pZnlfbWF4ID8gbWFnbmlmeV9tYXggOiB3aW5kb3cuaW5uZXJXaWR0aCAvIGZyYW1lV2lkdGg7XHJcblxyXG4gICAgICAvLyDmlL7lpKfmlrnlnZdcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja19udW07IGkrKykge1xyXG4gICAgICAgIGJsb2Nrc19vdXRlcltpXS5hdHRyKHtcclxuICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHg6IChibG9ja3Nfb3V0ZXJbaV0uc2hhcGUueCAtIHN0YXJ0WCkgKiB0b3RhbE1hZ25pZnksXHJcbiAgICAgICAgICAgIHk6IChibG9ja3Nfb3V0ZXJbaV0uc2hhcGUueSAtIHN0YXJ0WSkgKiB0b3RhbE1hZ25pZnksXHJcbiAgICAgICAgICAgIHdpZHRoOiBibG9ja3Nfb3V0ZXJbaV0uc2hhcGUud2lkdGggKiB0b3RhbE1hZ25pZnksXHJcbiAgICAgICAgICAgIGhlaWdodDogYmxvY2tzX291dGVyW2ldLnNoYXBlLmhlaWdodCAqIHRvdGFsTWFnbmlmeSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmxvY2tzX2lubmVyW2ldLmF0dHIoe1xyXG4gICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgeDogKGJsb2Nrc19pbm5lcltpXS5zaGFwZS54IC0gc3RhcnRYKSAqIHRvdGFsTWFnbmlmeSxcclxuICAgICAgICAgICAgeTogKGJsb2Nrc19pbm5lcltpXS5zaGFwZS55IC0gc3RhcnRZKSAqIHRvdGFsTWFnbmlmeSxcclxuICAgICAgICAgICAgd2lkdGg6IGJsb2Nrc19pbm5lcltpXS5zaGFwZS53aWR0aCAqIHRvdGFsTWFnbmlmeSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBibG9ja3NfaW5uZXJbaV0uc2hhcGUuaGVpZ2h0ICogdG90YWxNYWduaWZ5LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGZvbnQ6XHJcbiAgICAgICAgICAgICAgcGFyc2VJbnQoYmxvY2tEYXRhX2ZpdFtpXS5mb250LnNsaWNlKDAsIGJsb2NrRGF0YV9maXRbaV0uZm9udC5pbmRleE9mKFwicHhcIikpKSAqIHRvdGFsTWFnbmlmeSArXHJcbiAgICAgICAgICAgICAgYmxvY2tEYXRhX2ZpdFtpXS5mb250LnN1YnN0cihibG9ja0RhdGFfZml0W2ldLmZvbnQuaW5kZXhPZihcInB4XCIpKSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8g5pS+5aSn566h6YGTXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZV9udW07IGkrKykge1xyXG4gICAgICAgIC8vIOavj+adoeeuoemBk1xyXG4gICAgICAgIGxldCBwaXBlTmV3Q29vcnMgPSBuZXcgQXJyYXkocGlwZXNbaV0uc2hhcGUucG9pbnRzLmxlbmd0aCk7IC8vIOaYr+S4gOS4qm4tYnktMueahOaVsOe7hO+8jOeUqOS6juS4tOaXtuS/neWtmOaWsOeahOaKmOe6v+WdkOagh1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZXNbaV0uc2hhcGUucG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICBwaXBlTmV3Q29vcnNbal0gPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgICBwaXBlTmV3Q29vcnNbal1bMF0gPSAocGlwZXNbaV0uc2hhcGUucG9pbnRzW2pdWzBdIC0gc3RhcnRYKSAqIHRvdGFsTWFnbmlmeTtcclxuICAgICAgICAgIHBpcGVOZXdDb29yc1tqXVsxXSA9IChwaXBlc1tpXS5zaGFwZS5wb2ludHNbal1bMV0gLSBzdGFydFkpICogdG90YWxNYWduaWZ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwaXBlc1tpXS5hdHRyKHtcclxuICAgICAgICAgIHNoYXBlOiB7IHBvaW50czogcGlwZU5ld0Nvb3JzIH0sXHJcbiAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDUgKiB0b3RhbE1hZ25pZnkgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwaXBlc19mbG93W2ldLmF0dHIoe1xyXG4gICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBwaXBlTmV3Q29vcnMgfSxcclxuICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMyAqIHRvdGFsTWFnbmlmeSxcclxuICAgICAgICAgICAgbGluZURhc2g6IFs1ICogdG90YWxNYWduaWZ5LCA1ICogdG90YWxNYWduaWZ5XSxcclxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBpcGVzX2Zsb3dbaV1cclxuICAgICAgICAgIC5hbmltYXRlKFwic3R5bGVcIiwgdHJ1ZSlcclxuICAgICAgICAgIC53aGVuKDEwMDAsIHsgbGluZURhc2hPZmZzZXQ6IC0xICogKDEwICogdG90YWxNYWduaWZ5KSB9KVxyXG4gICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyDmlL7lpKfkuI3luKbmlbDmja7nmoTnrqHpgZNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXBlc19ub0RhdGFfZHJhd0RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcGlwZU5ld0Nvb3JzX25vRGF0YSA9IG5ldyBBcnJheShwaXBlc19ub0RhdGFbaV0uc2hhcGUucG9pbnRzLmxlbmd0aCk7IC8vIOaYr+S4gOS4qm4tYnktMuaVsOe7hO+8jOS4tOaXtuS/neWtmFxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgcGlwZU5ld0Nvb3JzX25vRGF0YVtqXSA9IG5ldyBBcnJheSgyKTtcclxuICAgICAgICAgIHBpcGVOZXdDb29yc19ub0RhdGFbal1bMF0gPSAocGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50c1tqXVswXSAtIHN0YXJ0WCkgKiB0b3RhbE1hZ25pZnk7XHJcbiAgICAgICAgICBwaXBlTmV3Q29vcnNfbm9EYXRhW2pdWzFdID0gKHBpcGVzX25vRGF0YVtpXS5zaGFwZS5wb2ludHNbal1bMV0gLSBzdGFydFkpICogdG90YWxNYWduaWZ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGlwZXNfbm9EYXRhW2ldLmF0dHIoe1xyXG4gICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBwaXBlTmV3Q29vcnNfbm9EYXRhIH0sXHJcbiAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDUgKiB0b3RhbE1hZ25pZnkgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwaXBlc19ub0RhdGFfZmxvd1tpXS5hdHRyKHtcclxuICAgICAgICAgIHNoYXBlOiB7IHBvaW50czogcGlwZU5ld0Nvb3JzX25vRGF0YSB9LFxyXG4gICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgbGluZVdpZHRoOiAzICogdG90YWxNYWduaWZ5LFxyXG4gICAgICAgICAgICBsaW5lRGFzaDogWzUgKiB0b3RhbE1hZ25pZnksIDUgKiB0b3RhbE1hZ25pZnldLFxyXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGlwZXNfbm9EYXRhX2Zsb3dbaV1cclxuICAgICAgICAgIC5hbmltYXRlKFwic3R5bGVcIiwgdHJ1ZSlcclxuICAgICAgICAgIC53aGVuKDEwMDAsIHsgbGluZURhc2hPZmZzZXQ6IC0xICogKDEwICogdG90YWxNYWduaWZ5KSB9KVxyXG4gICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8g57yp5pS+XHJcbm1haW4ub25tb3VzZXdoZWVsID0gZnVuY3Rpb24gKGUpIHtcclxuICBpZiAobWFnbmlmeU1vZGUpIHtcclxuICAgIG1hZ25pZnkgPSAxICsgTWF0aC5yb3VuZChlLnpyRGVsdGEpICogMC4wNjsgLy8g5YCN5pWw5pu05pawXHJcbiAgICBpZiAodG90YWxNYWduaWZ5ICogbWFnbmlmeSA+PSBtYWduaWZ5X21heCB8fCB0b3RhbE1hZ25pZnkgKiBtYWduaWZ5IDw9IG1hZ25pZnlfbWluKSBtYWduaWZ5ID0gMTsgLy8g57yp5pS+6ZmQ5Yi2XHJcbiAgICB0b3RhbE1hZ25pZnkgKj0gbWFnbmlmeTtcclxuICAgIC8vIOaUvuWkp+aWueWdl1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja19udW07IGkrKykge1xyXG4gICAgICBibG9ja3Nfb3V0ZXJbaV0uYXR0cih7XHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgIHg6IG1hZ25pZnkgKiAoYmxvY2tzX291dGVyW2ldLnNoYXBlLnggLSBlLmNsaWVudFgpICsgZS5jbGllbnRYLFxyXG4gICAgICAgICAgeTogbWFnbmlmeSAqIChibG9ja3Nfb3V0ZXJbaV0uc2hhcGUueSAtIGUuY2xpZW50WSkgKyBlLmNsaWVudFksXHJcbiAgICAgICAgICB3aWR0aDogYmxvY2tzX291dGVyW2ldLnNoYXBlLndpZHRoICogbWFnbmlmeSxcclxuICAgICAgICAgIGhlaWdodDogYmxvY2tzX291dGVyW2ldLnNoYXBlLmhlaWdodCAqIG1hZ25pZnksXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIGJsb2Nrc19pbm5lcltpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgeDogbWFnbmlmeSAqIChibG9ja3NfaW5uZXJbaV0uc2hhcGUueCAtIGUuY2xpZW50WCkgKyBlLmNsaWVudFgsXHJcbiAgICAgICAgICB5OiBtYWduaWZ5ICogKGJsb2Nrc19pbm5lcltpXS5zaGFwZS55IC0gZS5jbGllbnRZKSArIGUuY2xpZW50WSxcclxuICAgICAgICAgIHdpZHRoOiBibG9ja3NfaW5uZXJbaV0uc2hhcGUud2lkdGggKiBtYWduaWZ5LFxyXG4gICAgICAgICAgaGVpZ2h0OiBibG9ja3NfaW5uZXJbaV0uc2hhcGUuaGVpZ2h0ICogbWFnbmlmeSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBmb250OlxyXG4gICAgICAgICAgICBwYXJzZUludChibG9ja0RhdGFfZml0W2ldLmZvbnQuc2xpY2UoMCwgYmxvY2tEYXRhX2ZpdFtpXS5mb250LmluZGV4T2YoXCJweFwiKSkpICogdG90YWxNYWduaWZ5ICtcclxuICAgICAgICAgICAgYmxvY2tEYXRhX2ZpdFtpXS5mb250LnN1YnN0cihibG9ja0RhdGFfZml0W2ldLmZvbnQuaW5kZXhPZihcInB4XCIpKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIOaUvuWkp+euoemBk1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXBlX251bTsgaSsrKSB7XHJcbiAgICAgIC8vIOavj+adoeeuoemBk1xyXG4gICAgICBsZXQgcGlwZU5ld0Nvb3JzID0gbmV3IEFycmF5KHBpcGVzW2ldLnNoYXBlLnBvaW50cy5sZW5ndGgpOyAvLyDmmK/kuIDkuKpuLWJ5LTLnmoTmlbDnu4TvvIznlKjkuo7kuLTml7bkv53lrZjmlrDnmoTmipjnur/lnZDmoIdcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwaXBlc1tpXS5zaGFwZS5wb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBwaXBlTmV3Q29vcnNbal0gPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzW2pdWzBdID0gbWFnbmlmeSAqIChwaXBlc1tpXS5zaGFwZS5wb2ludHNbal1bMF0gLSBlLmNsaWVudFgpICsgZS5jbGllbnRYO1xyXG4gICAgICAgIHBpcGVOZXdDb29yc1tqXVsxXSA9IG1hZ25pZnkgKiAocGlwZXNbaV0uc2hhcGUucG9pbnRzW2pdWzFdIC0gZS5jbGllbnRZKSArIGUuY2xpZW50WTtcclxuICAgICAgfVxyXG4gICAgICBwaXBlc1tpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZTogeyBwb2ludHM6IHBpcGVOZXdDb29ycyB9LFxyXG4gICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogNSAqIHRvdGFsTWFnbmlmeSB9LFxyXG4gICAgICB9KTtcclxuICAgICAgcGlwZXNfZmxvd1tpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZTogeyBwb2ludHM6IHBpcGVOZXdDb29ycyB9LFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBsaW5lV2lkdGg6IDMgKiB0b3RhbE1hZ25pZnksXHJcbiAgICAgICAgICBsaW5lRGFzaDogWzUgKiB0b3RhbE1hZ25pZnksIDUgKiB0b3RhbE1hZ25pZnldLFxyXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBpcGVzX2Zsb3dbaV1cclxuICAgICAgICAuYW5pbWF0ZShcInN0eWxlXCIsIHRydWUpXHJcbiAgICAgICAgLndoZW4oMTAwMCwgeyBsaW5lRGFzaE9mZnNldDogLTEgKiAoMTAgKiB0b3RhbE1hZ25pZnkpIH0pXHJcbiAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICAvLyDmlL7lpKfml6DmlbDmja7nmoTnrqHpgZNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZXNfbm9EYXRhX2RyYXdEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBwaXBlTmV3Q29vcnNfbm9EYXRhID0gbmV3IEFycmF5KHBpcGVzX25vRGF0YVtpXS5zaGFwZS5wb2ludHMubGVuZ3RoKTsgLy8g5piv5LiA5Liqbi1ieS0y55qE5pWw57uE77yM55So5LqO5Li05pe25L+d5a2Y5paw55qE5oqY57q/5Z2Q5qCHXHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHBpcGVOZXdDb29yc19ub0RhdGFbal0gPSBuZXcgQXJyYXkoMik7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzX25vRGF0YVtqXVswXSA9IG1hZ25pZnkgKiAocGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50c1tqXVswXSAtIGUuY2xpZW50WCkgKyBlLmNsaWVudFg7XHJcbiAgICAgICAgcGlwZU5ld0Nvb3JzX25vRGF0YVtqXVsxXSA9IG1hZ25pZnkgKiAocGlwZXNfbm9EYXRhW2ldLnNoYXBlLnBvaW50c1tqXVsxXSAtIGUuY2xpZW50WSkgKyBlLmNsaWVudFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBpcGVzX25vRGF0YVtpXS5hdHRyKHtcclxuICAgICAgICBzaGFwZTogeyBwb2ludHM6IHBpcGVOZXdDb29yc19ub0RhdGEgfSxcclxuICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDUgKiB0b3RhbE1hZ25pZnkgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBpcGVzX25vRGF0YV9mbG93W2ldLmF0dHIoe1xyXG4gICAgICAgIHNoYXBlOiB7IHBvaW50czogcGlwZU5ld0Nvb3JzX25vRGF0YSB9LFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBsaW5lV2lkdGg6IDMgKiB0b3RhbE1hZ25pZnksXHJcbiAgICAgICAgICBsaW5lRGFzaDogWzUgKiB0b3RhbE1hZ25pZnksIDUgKiB0b3RhbE1hZ25pZnldLFxyXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBpcGVzX25vRGF0YV9mbG93W2ldXHJcbiAgICAgICAgLmFuaW1hdGUoXCJzdHlsZVwiLCB0cnVlKVxyXG4gICAgICAgIC53aGVuKDEwMDAsIHsgbGluZURhc2hPZmZzZXQ6IC0xICogKDEwICogdG90YWxNYWduaWZ5KSB9KVxyXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgICAgIC5zdGFydCgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vIOaLluWKqFxyXG5sZXQgbW91c2VEcmFnID0gZmFsc2U7XHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gKiogZGF0YUluaXRpYWxpemUuanNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyDliJ3lp4vljJbmlbDmja7ngrnnmoTnm7jlhbPlsZ7mgKfvvIjmtYHpgJ/jgIHmuKnluqbjgIHljovlipvvvIlcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5mb3IgKGxldCBub2RlIGluIHBpcGVWZXJ0ZXhEYXRhKSB7XHJcbiAgcGlwZVZlcnRleERhdGFbbm9kZV0uc3BlZWQgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xyXG4gIHBpcGVWZXJ0ZXhEYXRhW25vZGVdLnRlbXBlcmF0dXJlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcclxuICBwaXBlVmVydGV4RGF0YVtub2RlXS5wcmVzc3VyZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XHJcbn1cclxuZm9yIChsZXQgcCBvZiBvdXRwdXQpIHtcclxuICBsZXQgc3BlZWQgPSBwLnNwZWVkLnRvRml4ZWQoNCk7XHJcbiAgbGV0IHBpcGVfaWQgPSBcImdcIiArIHAucGlwZTtcclxuICBmb3IgKGxldCBtYXAgb2Ygbm9kZV9waXBlX21hcCkge1xyXG4gICAgaWYgKG1hcFtcInBpcGVfaWRcIl0gPT0gcGlwZV9pZCkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInNwZWVkID1cIiwgc3BlZWQpO1xyXG4gICAgICBwaXBlVmVydGV4RGF0YVttYXBbXCJub2RlX2lkXCJdWzBdXS5zcGVlZCA9IHBhcnNlRmxvYXQoc3BlZWQpO1xyXG4gICAgICBwaXBlVmVydGV4RGF0YVttYXBbXCJub2RlX2lkXCJdWzFdXS5zcGVlZCA9IHBhcnNlRmxvYXQoc3BlZWQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vICoqIGRhdGFVcGRhdGUuanNcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgVXBkYXRlIHNwZWVkLCB0ZW1wZXJhdHVyZSwgcHJlc3N1cmUgb2YgZGF0YSBwb2ludHNcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgZm9yIChsZXQgbm9kZSBpbiBwaXBlVmVydGV4RGF0YSkge1xyXG4gICAgLy8gcGlwZVZlcnRleERhdGFbbm9kZV0uc3BlZWQgKz0gcmFuZE51bSgtMSwgMSk7XHJcbiAgICAvLyBwaXBlVmVydGV4RGF0YVtub2RlXS50ZW1wZXJhdHVyZSArPSByYW5kTnVtKC0xLCAxKTtcclxuICAgIC8vIHBpcGVWZXJ0ZXhEYXRhW25vZGVdLnByZXNzdXJlICs9IHJhbmROdW0oLTEsIDEpO1xyXG4gIH1cclxufSwgMTAwMCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==